%!PS-Adobe-2.0
%%Creator: dvips(k) 5.991 Copyright 2011 Radical Eye Software
%%Title: /Users/fred/depotsGithub/G3DM64/./MonCoursG3D_M64.dvi
%%CreationDate: Wed Nov 14 18:15:56 2012
%%Pages: 22
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: NewCenturySchlbk-Roman NewCenturySchlbk-Bold
%%+ Fourier-Math-Letters-Italic NewCenturySchlbk-Italic
%%+ Fourier-Math-Letters Fourier-Math-Symbols CMMI10 CMR10 CMSY7 CMR7
%%+ stmary10 CMSY10 Helvetica-Bold Fourier-Math-Extension
%%+ Fourier-Math-BlackBoard
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: /usr/texbin/dvips -o
%+ /Users/fred/depotsGithub/G3DM64/./MonCoursG3D_M64.ps
%+ /Users/fred/depotsGithub/G3DM64/./MonCoursG3D_M64.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2012.11.14:1815
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.09, 2011/10/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep div cvi def
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  XA Shift sub YA Shift sub moveto 
  gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
  Symbol show grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    startAngle rotate Symbol show 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} 
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if
    Symbol show 
    grestore
  }
  pathforall 
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 594 2011-10-31 18:13:18Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.02, 2012/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 130 2009-08-27 08:55:03Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 440 2010-12-28 21:06:39Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.13, 2011/11/21.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.06, 2011/09/18
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  mtrx setmatrix TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  pop pop pop pop 
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Created the     : Sat 20 March 2004
% Last Mod        : $Date: 2010/10/02 $
% Version         : 0.62 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 328 2010-05-24 15:56:43Z herbert $
% PostScript prologue for pstricks-add.tex.
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-solides3d.pro 0 0
%!
% PostScript prologue for pst-solides3d.tex.
% Version 4.20, 2010/04/27
%
%% COPYRIGHT 2009/10 by Jean-Paul Vignault
%% opacity changes by Herbert Voss
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN
%% archives in directory macros/latex/base/lppl.txt.
%
/SolidesDict 100 dict def
/SolidesbisDict 100 dict def
SolidesDict begin

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les variables globales gerees par PSTricks %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %% les lignes dessous sont a decommenter si l on veut utiliser le
%% %% fichier solides.pro independamment du package PSTricks
%% /Dobs 20 def
%% /THETA 20 def
%% /PHI 50 def
%% /Decran 30 def
%% /XpointVue {Dobs Cos1Cos2 mul} def
%% /YpointVue {Dobs Sin1Cos2 mul} def
%% /ZpointVue {Dobs Sin2 mul} def
%% /xunit 28.14 def
%% /solidhollow false def
%% /solidbiface false def
%% /xunit 28.45 def
%% /tracelignedeniveau? true def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% /solidgrid true def
/aretescachees true def
/defaultsolidmode 2 def
%
/Stroke { strokeopacity .setopacityalpha stroke } def
/Fill { fillopacity .setopacityalpha fill } def
%
%% variables globales specifiques a PSTricks
%% /activationgestioncouleurs true def
/xmin -10 def
/xmax 10 def
/ymin -10 def
/ymax 10 def

/fillstyle {} def
/startest false def
/cm {} def
/cm_1 {} def
/yunit {xunit} def
/angle_repere 90 def

/hadjust 2.5 def
/vadjust 2.5 def
/pl@n-en-cours false def

/pointilles { [6.25 3.75] 1.25 setdash } def
/stockcurrentcpath {} def
/newarrowpath {} def
/chaine 15 string def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% choix d une fonte accentuee pour le .ps %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/ReEncode { exch findfont
dup length dict begin { 1 index /FID eq {pop pop} {def} ifelse
}forall /Encoding ISOLatin1Encoding def currentdict end definefont
pop }bind def
/Font /Times-Roman /ISOfont ReEncode /ISOfont def
%Font findfont 10 scalefont setfont

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% extrait de color.pro pour pouvoir recuperer ses couleurs %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GreenYellow{0.15 0 0.69 0 setcmykcolor}def
/Yellow{0 0 1 0 setcmykcolor}def
/Goldenrod{0 0.10 0.84 0 setcmykcolor}def
/Dandelion{0 0.29 0.84 0 setcmykcolor}def
/Apricotq{0 0.32 0.52 0 setcmykcolor}def
/Peach{0 0.50 0.70 0 setcmykcolor}def
/Melon{0 0.46 0.50 0 setcmykcolor}def
/YellowOrange{0 0.42 1 0 setcmykcolor}def
/Orange{0 0.61 0.87 0 setcmykcolor}def
/BurntOrange{0 0.51 1 0 setcmykcolor}def
/Bittersweet{0 0.75 1 0.24 setcmykcolor}def
/RedOrange{0 0.77 0.87 0 setcmykcolor}def
/Mahogany{0 0.85 0.87 0.35 setcmykcolor}def
/Maroon{0 0.87 0.68 0.32 setcmykcolor}def
/BrickRed{0 0.89 0.94 0.28 setcmykcolor}def
/Red{0 1 1 0 setcmykcolor}def
/OrangeRed{0 1 0.50 0 setcmykcolor}def
/RubineRed{0 1 0.13 0 setcmykcolor}def
/WildStrawberry{0 0.96 0.39 0 setcmykcolor}def
/Salmon{0 0.53 0.38 0 setcmykcolor}def
/CarnationPink{0 0.63 0 0 setcmykcolor}def
/Magenta{0 1 0 0 setcmykcolor}def
/VioletRed{0 0.81 0 0 setcmykcolor}def
/Rhodamine{0 0.82 0 0 setcmykcolor}def
/Mulberry{0.34 0.90 0 0.02 setcmykcolor}def
/RedViolet{0.07 0.90 0 0.34 setcmykcolor}def
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}def
/Lavender{0 0.48 0 0 setcmykcolor}def
/Thistle{0.12 0.59 0 0 setcmykcolor}def
/Orchid{0.32 0.64 0 0 setcmykcolor}def
/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}def
/Purple{0.45 0.86 0 0 setcmykcolor}def
/Plum{0.50 1 0 0 setcmykcolor}def
/Violet{0.79 0.88 0 0 setcmykcolor}def
/RoyalPurple{0.75 0.90 0 0 setcmykcolor}def
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}def
/Periwinkle{0.57 0.55 0 0 setcmykcolor}def
/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}def
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}def
/MidnightBlue{0.98 0.13 0 0.43 setcmykcolor}def
/NavyBlue{0.94 0.54 0 0 setcmykcolor}def
/RoyalBlue{1 0.50 0 0 setcmykcolor}def
/Blue{1 1 0 0 setcmykcolor}def
/Cerulean{0.94 0.11 0 0 setcmykcolor}def
/Cyan{1 0 0 0 setcmykcolor}def
/ProcessBlue{0.96 0 0 0 setcmykcolor}def
/SkyBlue{0.62 0 0.12 0 setcmykcolor}def
/Turquoise{0.85 0 0.20 0 setcmykcolor}def
/TealBlue{0.86 0 0.34 0.02 setcmykcolor}def
/Aquamarine{0.82 0 0.30 0 setcmykcolor}def
/BlueGreen{0.85 0 0.33 0 setcmykcolor}def
/Emerald{1 0 0.50 0 setcmykcolor}def
/JungleGreen{0.99 0 0.52 0 setcmykcolor}def
/SeaGreen{0.69 0 0.50 0 setcmykcolor}def
/Green{1 0 1 0 setcmykcolor}def
/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}def
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}def
/LimeGreen{0.50 0 1 0 setcmykcolor}def
/YellowGreen{0.44 0 0.74 0 setcmykcolor}def
/SpringGreen{0.26 0 0.76 0 setcmykcolor}def
/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}def
/RawSienna{0 0.72 1 0.45 setcmykcolor}def
/Sepia{0 0.83 1 0.70 setcmykcolor}def
/Brown{0 0.81 1 0.60 setcmykcolor}def
/Tan{0.14 0.42 0.56 0 setcmykcolor}def
/Gray{0 0 0 0.50 setcmykcolor}def
/Black{0 0 0 1 setcmykcolor}def
/White{0 0 0 0 setcmykcolor}def
%% fin de l extrait color.pro

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             autres couleurs                        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/bleu {0 0 1 setrgbcolor} def
/rouge {1 0 0 setrgbcolor} def
/vert {0 .5 0 setrgbcolor} def
/gris {.4 .4 .4 setrgbcolor} def
/jaune {1 1 0 setrgbcolor} def
/noir {0 0 0 setrgbcolor} def
/blanc {1 1 1 setrgbcolor} def
/orange {1 .65 0 setrgbcolor} def
/rose {1 .01 .58  setrgbcolor} def
/cyan {1 0 0 0 setcmykcolor} def
/magenta {0 1 0 0 setcmykcolor} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             definition du point de vue             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% pour la 3D conventionnelle
%% Dony : graphisme scientifique : page 187
%% Editeur : Masson

%% calcul des coefficients de la matrice
%% de transformation
/Sin1 {THETA sin} def
/Sin2 {PHI sin} def
/Cos1 {THETA cos} def
/Cos2 {PHI cos} def
/Cos1Sin2 {Cos1 Sin2 mul} def
/Sin1Sin2 {Sin1 Sin2 mul} def
/Cos1Cos2 {Cos1 Cos2 mul} def
/Sin1Cos2 {Sin1 Cos2 mul} def

/3dto2d {
6 dict begin
   /Zcote exch def
   /Yordonnee exch def
   /Xabscisse exch def
   /xObservateur
      Xabscisse Sin1 mul neg Yordonnee Cos1 mul add
   def
   /yObservateur
      Xabscisse Cos1Sin2 mul neg Yordonnee Sin1Sin2 mul sub Zcote Cos2
      mul add
   def
   /zObservateur
      Xabscisse neg Cos1Cos2 mul Yordonnee Sin1Cos2 mul sub Zcote Sin2
      mul sub Dobs add
   def
   %% maintenant on depose les resultats sur la pile
   Decran xObservateur mul zObservateur div cm
   Decran yObservateur mul zObservateur div cm
end
} def

/getpointVue {
   XpointVue
   YpointVue
   ZpointVue
} def

/GetCamPos {
   getpointVue
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         jps modifie pour PSTricks                  %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/solid {continu} def
/dashed {pointilles} def
/dotted { [2] 0 setdash } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             geometrie basique                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% syntaxe~: [x1 y1 ... xn yn] ligne
/ligne {
gsave
   newpath
      dup 0 getp smoveto
      ligne_
      starfill
   Stroke
grestore
} def

%% syntaxe~: [x1 y1 ... xn yn] ligne_
/ligne_ {
   reversep
   aload length 2 idiv
   {
      slineto
   } repeat
} def

%% syntaxe~: [x1 y1 ... xn yn] polygone
/polygone* {
1 dict begin
   /startest {true} def
   polygone
end
} def

/polygone_ {
   newpath
      aload length 2 idiv
      3 copy pop
      smoveto
      {
         slineto
      } repeat
   closepath
} def

/polygone {
   gsave
      polygone_
      starfill
      currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
} def

%% syntaxe : x y point
/point {
gsave
   1 setlinecap
   newpath
      smoveto
      0 0 rlineto
      5 setlinewidth
   Stroke
grestore
} def

/point_ {
   1 setlinecap
   5 setlinewidth
      smoveto
      0 0 rlineto
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%          insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%              le repere jps                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### AAAopacity ###

%% les parametres pour la gestion de la transparence

/setstrokeopacity { /strokeopacity exch def } def
/setfillopacity { /fillopacity exch def } def

%% d apres un code de Jean-Michel Sarlat
%% http://melusine.eu.org/syracuse/swf/pdf2swf/setdash/
%% Mise en reserve de la procedure stroke originelle.
/sysstroke {systemdict /stroke get exec} def
/sysfill {systemdict /fill get exec} def
/sysatan {systemdict /atan get exec} def
/atan {2 copy 0 0 eqp {pop pop 0} {sysatan} ifelse} def
% Mise en place de la nouvelle procedure
/Stroke { /strokeopacity where { /strokeopacity get }{ 1 } ifelse
   .setopacityalpha sysstroke
} def
/Fill { /fillopacity where { /fillopacity get }{ 1 } ifelse
   .setopacityalpha sysfill
} def

%%%%% ### AAAscale ###
%%%%%%%%%%%%%%%% les deplacements a l echelle %%%%%%%%%%%%%%%%%%%

 /v@ct_I {xunit 0} def
 /v@ct_J {angle_repere cos yunit mul angle_repere sin yunit mul} def

/xscale {} def
/yscale {} def

/xscale-1 {} def
/yscale-1 {} def

/gtransform {} def
/gtransform-1 {} def

/jtoppoint {
2 dict begin
   gtransform
   /y exch yscale def
   /x exch xscale def
   v@ct_I x mulv
   v@ct_J y mulv
   addv
end
} def

/rptojpoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
   ptojpoint
} def

/rptoppoint {
   xtranslate ytranslate 
   3 1 roll         %% xA yB yA xB 
   4 1 roll         %% xB xA yB yA 
   sub neg 3 1 roll %% yB-yA xB xA 
   sub neg exch
} def

/ptojpoint {
4 dict begin
   /Y exch yscale-1 def
   /X exch xscale-1 def
   /y Y yunit angle_repere sin mul div def
   /x X y yunit mul angle_repere cos mul sub xunit div def
   x y
   gtransform-1
end
} def

/smoveto {
   jtoppoint
   moveto
} def

/srmoveto {
   jtoppoint
   rmoveto
} def

/slineto {
   jtoppoint
   lineto
} def

/srlineto {
   jtoppoint
   rlineto
} def

/stranslate {
   jtoppoint
   translate
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%            methodes numeriques                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solve2nddegre ###
%% syntaxe : a b c solve2nddegre --> x1 x2
/solve2nddegre {
5 dict begin
   /@c exch def
   /@b exch def
   /@a exch def
   /delt@ @b dup mul 4 @a mul @c mul sub def
   @b neg delt@ sqrt sub 2 @a mul div
   @b neg delt@ sqrt add 2 @a mul div
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  la 2D                             %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  points                            %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### tripointangle ###
%% syntaxe : A B C tripointangle --> angle ABC
/tripointangle {
9 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   B C angle
   B A angle
   sub
end   
} def

%%%%% ### angle ###
%% syntaxe : A B angle
%% --> num, l'angle defini par le vecteur AB dans le repere orthonorme jps 
/angle {
   vecteur exch atan
   dup 180 gt 
      {360 sub}
   if
} def

%% syntaxe : A B pangle
%% --> num, l'angle defini par le vecteur AB dans le repere postscript
/pangle {
   jtoppoint exchp jtoppoint exchp vecteur exch atan
   dup 180 gt 
	 {360 sub}
   if
} def

%%%%% ### setxrange ###
/setxrange {
   /xmax exch def
   /xmin exch def
} def

%%%%% ### setyrange ###
/setyrange {
   /ymax exch def
   /ymin exch def
} def

%%%%% ### defpoint ###
%% syntaxe : xA yA /A defpoint
/defpoint {
1 dict begin
   /t@mp@r@ire exch def
   [ 3 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### milieu ###
%% syntaxe~: A B milieu 
/milieu {  
                %% xA yA xB yB
   3 -1 roll    %% xA xB yB yA 
   add 2 div    %% xA xB yM
   3 1 roll     %% yM xA xB 
   add 2 div    %% yM xM
   exch
} def

%%%%% ### parallelopoint ###
%% syntaxe : A B C parallelopoint --> point D, tel que ABCD parallelogramme
/parallelopoint {
11 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /d1 {A B C paral} def
   /d2 {B C A paral} def
   d1 d2 interdroite
end
} def

%%%%% ### translatepoint ###
%% syntaxe : A u translatepoint --> B image de A par la translation de vecteur u
/translatepoint {
   addv
} def

%%%%% ### rotatepoint ###
%% syntaxe : B A r rotatepoint --> C image de B par la rotation de centre A,
%% d'angle r (en degre)
%% En prenant les affixes des pts associes, il vient
%%    (zC - zA) = (zB-zA) e^(ir)
%% soit 
%%    zC = (zB-zA) e^(ir) + zA
/rotatepoint {     %% B, A, r
   5 copy          %% B, A, r, B, A, r
   cos 5 1 roll    %% B, A, r, cos r, B, A
   4 1 roll        %% B, A, r, cos r, yA, B, xA
   4 1 roll        %% B, A, r, cos r, A, B 
   vecteur         %% B, A, r, cos r, xB-xA, yB-yA
   4 -1 roll sin   %% B, A, cos r, xB-xA, yB-yA, sin r
   4 copy mul      %% B, A, cos r, xB-xA, yB-yA, sin r, cos r, xB-xA, (yB-yA) sin r
   7 1 roll mul    %% B, A, (yB-yA) sin r, cos r, xB-xA, yB-yA, sin r, cos r (xB-xA)
   5 1 roll        %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, yB-yA, sin r
   exch            %% B, A, (yB-yA) sin r, cos r (xB-xA), cos r, xB-xA, sin r, yB-yA
   4 -1 roll mul   %% B, A, (yB-yA) sin r, cos r (xB-xA), xB-xA, sin r, (yB-yA)cos r
   3 1 roll mul    %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r, (xB-xA) sin r
   add             %% B, A, (yB-yA) sin r, cos r (xB-xA), (yB-yA) cos r +(xB-xA) sin r
   3 1 roll        %% B, A, (yB-yA) cos r + (xB-xA) sin r, (yB-yA) sin r, cos r (xB-xA), 
   exch sub        %% B, A, (yB-yA) cos r + (xB-xA) sin r, cos r (xB-xA)-(yB-yA) sin r 
   exch            %% B, zA, (zB-zA) e^(ir)
   addv
   3 -1 roll pop
   3 -1 roll pop
} def

%%%%% ### hompoint ###
%% syntaxe : B A alpha hompoint -> le point A' tel que AA' = alpha AB
/hompoint {
   5 copy
   pop
   vecteur      %% vecteur BA
   3 -1 roll
   neg
   mulv   %% alpha x vecteur AB
   addv
   4 -1 roll
   4 -1 roll
   pop pop
} def

%%%%% ### orthoproj ###
%% syntaxe : A D orthoproj --> B, le projete orthogonal de A sur D
/orthoproj {
   6 -1 roll
   6 -1 roll            %% D A
   6 copy               %% D A D A
   7 -1 roll pop
   7 -1 roll pop        %% D D A
   perp 
   interdroite
} def

%% syntaxe : A projx --> le projete orthogonal de A sur Ox
/projx {
   pop 0
} def

%% syntaxe : A projy --> le projete orthogonal de A sur Oy
/projy {
   exch pop 0 exch
} def

%%%%% ### sympoint ###
%% syntaxe : A I sympoint --> point A', le symetrique de A par rapport
%% au point I
/sympoint {
   4 copy
   pop pop
   vecteur 
   -2 mulv
   addv
} def

%%%%% ### axesympoint ###
%% syntaxe : A D axesympoint --> point B, le symetrique de A par rapport
%% a la droite D
/axesympoint {
2 dict begin
   6 copy
   pop pop pop pop
   /yA exch def
   /xA exch def
   orthoproj 
   xA yA vecteur 
   -2 mulv
   xA yA addv
end   
} def

%%%%% ### cpoint ###
%% syntaxe : alpha C cpoint -> M, le point du cercle C correspondant a
%% l'angle alpha
/cpoint {           %% a, xI, yI, r 
1 dict begin
   dup              %% a, xI, yI, r, r
   5 -1 roll        %% xI, yI, r, r, a
   /alpha exch def  
   alpha cos mul    %% xI, yI, r, r cos a
   exch
   alpha sin mul    %% xI, yI, r cos a, r sin a
   3 -1 roll add    %% xI, r cos a, yI + r sin a
   3 1 roll         %% yI + r sin a, xI, r cos a, 
   add exch         %% xI + r cos a, yI + r sin a
end
} def

%%%%% ### xdpoint ###
%% x A B xdpoint : le point de la droite (AB) d'abscisse x
/xdpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /x exch def
   /a pt1 pt2 coeffdir def
   /b pt1 pt2 ordorig def
   x dup a mul b add
end   
} def

%%%%% ### ydpoint ###
%% y A B ydpoint : le point de la droite (AB) d'ordonnee y
/ydpoint {
5 dict begin
   /pt2 defpoint
   /pt1 defpoint
   /y exch def
   pt1 pt2 verticale? 
      {
         pt1 pop y
      }
      {
         /a pt1 pt2 coeffdir def
         /b pt1 pt2 ordorig def
         y b sub a div y
      }
   ifelse
end   
} def

%%%%% ### ordonnepoints ###
%% syntaxe : xA yA xB yB ordonnepoints --> idem si yB>yA ou si yB=yA
%% avec xB>xA, sinon xB yB xA yA
/ordonnepoints {
   4 copy
   exch pop             %% ... xA, yA, yB
   lt                   %% yA < yB ?
      {pop}                     %% oui, c'est fini
      {                         %% non : yA >= yB
         pop 4 copy  
         exch pop               %% ... xA, yA, yB
         eq                     %% yA = yB ?
            {
               3 copy                   %% oui, yA = yB
               pop pop                  %% ... xA, xB
               le                       %% xA =< xB ?
                  {}                          %% oui, c'est fini
                  {                           %% non, on echange A et B
                     4 -1 roll
                     4 -1 roll
                  }
               ifelse
            }
            {                           %% non : yA < yB => on echange A et B
               pop
               4 -1 roll
               4 -1 roll
            }
         ifelse
      } 
   ifelse
} def

%%%%% ### distance ###
%% syntaxe~: A B distance
/distance {      %% xA yA xB yB
   vecteur       %% x y
   dup mul exch  %% y^2 x
   dup mul       %% y^2 x^2
   add
   sqrt
} def

%%%%% ### dup ###
/dupp {2 copy} def
/dupc {3 copy} def
/dupd {4 copy} def

%%%%% ### fin insertion ###
/interdroites {interdroite} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 vecteurs                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### vecteur ###
%% syntaxe~: A B vecteur
/vecteur {
                %% xA yA xB yB 
   3 -1 roll    %% xA xB yB yA 
   sub          %% xA xB yB-yA 
   3 1 roll     %% yB-yA xA xB 
   exch sub     %% yB-yA xB-xA 
   exch
} def

%%%%% ### normalize ###
%% syntaxe : u normalize -> u / ||u||
/normalize {
2 dict begin
   /u defpoint
   /n u norme def
   u 1 n div mulv
end
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### subv ###
%% syntaxe : u v subv --> u - v
/subv {	%% xA yA xB yB
   -1 mulv
   addv
} def

%%%%% ### mulv ###
%% syntaxe : u a mulv --> au
/mulv {   %% xA, yA, a
   dup          %% xA, yA, a, a
   3 1 roll     %% xA, a, yA, a
   mul 3 1 roll %% ayA, xA, a
   mul exch
} def

%%%%% ### scalprod ###
%% syntaxe : u v scalprod --> le produit scalaire de u par v
/scalprod {
2 dict begin
   /y' exch def
   exch 
   /y exch def
   mul y y' mul add
end
} def

%%%%% ### normal ###
%% syntaxe : u normal --> v tel u.v = 0
/normal {
   neg exch
} def

%%%%% ### norme ###
%% syntaxe : u norme --> |u|
/norme {
   dup mul
   exch
   dup mul
   add sqrt
} def

%%%%% ### oldarrow ###
%% syntaxe : A B oldarrow --> trace fleche en B, direction AB
/oldarrow {
4 dict begin
gsave
   /B defpoint
   /A defpoint
   oldarrowscale scale
   oldarrowangle rotate
   newpath 
   B smoveto
   A B vecteur normalize /u defpoint
   u neg exch /v defpoint
   u oldarrowpointe neg mulv rmoveto %% ainsi c'est la pointe qui est en (0, 0)
   %% le pt extremal arriere haut
      u oldarrowplume neg mulv        %% l'abscisse
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul mulv addv %% l'ordonnee
   rlineto
      u oldarrowplume oldarrowpointe add mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto 
      u oldarrowplume oldarrowpointe add neg mulv
      v oldarrow@ngle sin oldarrow@ngle cos div oldarrowplume mul neg mulv addv
   rlineto
   closepath Fill
grestore
end
} def

/oldarrowpointe {xunit 5 div} def
/oldarrowplume {xunit 10 div} def 
/oldarrow@ngle 45 def        
/oldarrowscale {1 1} def
/oldarrowangle 0 def     %% pour l'utilisateur

%%%%% ### drawvecteur ###
%% syntaxe : A B drawvecteur
/drawvecteur {
2 dict begin
   /B defpoint
   /A defpoint
   [A B] ligne
   A B oldarrow
end
} def

%%%%% ### orthovecteur ###
%% syntaxe : u orthovecteur --> v, vecteur orthogonal a u
/orthovecteur {
   neg exch
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  cercles                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### defcercle ###
%% syntaxe : A r /d defcercle
/defcercle {
1 dict begin
   /t@mp@r@ire exch def
   [ 4 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### interdroitecercle ###
%% intersection de la droite y = ax+b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%% { --       b - y                   2          2           3
%% { |  x = - -----, y = (b + a x0 + a  y0 + (2 a  b y0 - 2 a  b x0 +
%% { --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%% 
%%    -- 
%%     |,
%%    -- 
%%     --       b - y                   2          2           3
%%     |  x = - -----, y = (b + a x0 + a  y0 - (2 a  b y0 - 2 a  b x0 +
%%     --         a
%% 
%%       3          2  2    2  2    4  2    2   2    4   2             2
%%    2 a  x0 y0 - a  b  + a  r  + a  r  - a  y0  - a  x0 )^(1/2)) / (a  + 1)
%% 
%%    -- }
%%     | }
%%    -- }

%% intersection de la droite x = a avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[x = a, y = y0 + (2 a x0 - a  + r  - x0 )   ],
%% 
%%                                2    2     2 1/2
%%    [x = a, y = y0 - (2 a x0 - a  + r  - x0 )   ]}

%% intersection de la droite y = b avec le cercle (x-x0)^2 + (y-y0)^2 = r^2
%%                              2    2     2 1/2
%% {[y = b, x = x0 + (2 b y0 - b  + r  - y0 )   ],
%% 
%%                                2    2     2 1/2
%%    [y = b, x = x0 - (2 b y0 - b  + r  - y0 )   ]}

%% syntaxe : D I r interdroitecercle
/interdroitecercle {
16 dict begin
   /r exch def
   /y0 exch def
   /x0 exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def

   xA yA xB yB verticale?

   %% la droite est verticale
   {
      /xpt1 xA def
      /xpt2 xA def
      /quantite 
         2 xA mul x0 mul xA dup mul sub r dup mul add x0 dup mul sub sqrt
      def
      /ypt1
         y0 quantite add
      def
      /ypt2
         y0 quantite sub
      def
   }

   %% la droite n'est pas verticale
   {
      /a xA yA xB yB coeffdir def
      /b xA yA xB yB ordorig def

      0 a eq 
      %% la droite est horizontale
      {
         /quantite
            2 b mul y0 mul 
            b dup mul sub
            r dup mul add
            y0 dup mul sub
            sqrt
         def
         /xpt1 
            x0 quantite add
         def
         /xpt2 
            x0 quantite sub
         def
         /ypt1 b def
         /ypt2 b def
      } 

      %% la droite n'est pas horizontale
      {
         /quantite1 
            b 
            a x0 mul add
            a dup mul y0 mul add
         def
         /quantite2
            2 a dup mul mul b mul y0 mul 
            2 a 3 exp mul b mul x0 mul sub
            2 a 3 exp mul x0 mul y0 mul add
            a dup mul b dup mul mul sub
            a dup mul r dup mul mul add
            a 4 exp r dup mul mul add
            a dup mul y0 dup mul mul sub
            a 4 exp x0 dup mul mul sub 
            sqrt 
         def
         /quantite3 
            a dup mul 1 add 
         def
         /ypt1
            quantite1 quantite2 add quantite3 div
         def
         /xpt1 
            ypt1 b sub a div 
         def
         /ypt2
            quantite1 quantite2 sub quantite3 div
         def
         /xpt2 
            ypt2 b sub a div 
         def
      } 
      ifelse
   }
   ifelse
   
   xpt1 ypt1 
   xpt2 ypt2 
   ordonnepoints
end
} def

%%%%% ### intercercle ###
%% syntaxe : cerc1 cerc2 intercercle --> A B les points d'intersection
%% des 2 cercles, tries par 'ordonnepoints'
/intercercle {
12 dict begin
   /r2 exch def
   /y2 exch def
   /x2 exch def
   /r1 exch def
   /y1 exch def
   /x1 exch def

   %% on translate pour se ramener a (x1, y1) = (0, 0)
   x2 y2 x1 y1 subv
   /y2 exch def
   /x2 exch def

   %% on prepare l'equation du 2nd degre

%%                    2       2    2
%%   {y = RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ), x = 1/2 (-2 y2
%% 
%%                     2       2    2
%%         RootOf((4 x2  + 4 y2 ) _Z
%% 
%%                  3        2              2       2            4
%%          + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z + x2
%% 
%%               4       2    2       2   2       2    2        2   2
%%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
%% 
%%               4     4        2   2        2    2       2     2     2
%%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ ) + r1~  + x2  + y2
%% 
%%               2
%%          - r2~ )/x2}

   %% coeff pour le degre 2
   /a 
      %%                    2       2    2
      %%   {y = RootOf((4 x2  + 4 y2 ) _Z
      4 x2 dup mul mul
      4 y2 dup mul mul add
   def

   %% coeff pour le degre 1
   %%
   /b 
      %%                    3        2              2       2        
      %%            + (-4 y2  - 4 r1~  y2 + 4 y2 r2~  - 4 x2  y2) _Z 
      -4 y2 3 exp mul
      4 r1 dup mul mul y2 mul sub
      4 r2 dup mul mul y2 mul add
      4 x2 dup mul mul y2 mul sub
   def

   %% coeff pour le degre 0
   %%
   /c {
      %%              4
      %%          + x2
      x2 4 exp
      %% 
      %%               4       2    2       2   2       2    2        2   2
      %%          + r2~  - 2 y2  r2~  + 2 x2  y2  - 2 x2  r2~  - 2 r1~  x2
      r2 4 exp add
      2 y2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul y2 dup mul mul add
      2 x2 dup mul mul r2 dup mul mul sub
      2 x2 dup mul mul r1 dup mul mul sub
      %% 
      %%               4     4        2   2        2    2
      %%          + r1~  + y2  + 2 r1~  y2  - 2 r1~  r2~ )
      r1 4 exp add
      y2 4 exp add
      2 r1 dup mul mul y2 dup mul mul add
      2 r1 dup mul mul r2 dup mul mul sub
   } def

   a b c solve2nddegre
   /Y1 exch def
   /Y0 exch def
   
   /X0
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y0 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def
   
   /X1
      %% x = 1/2 (-2 y2  Y
      -2 y2 mul Y1 mul
      %% 
      %%        2     2     2
      %% + r1~  + x2  + y2
      r1 dup mul add
      x2 dup mul add
      y2 dup mul add
      %% 
      %%                 2
      %%            - r2~ )/x2}
      r2 dup mul sub
   
      2 x2 mul div
   def

   %% on depose le resultat, en n'oubliant pas de retranslater en sens
   %% inverse

   X0 Y0 x1 y1 addv
   X1 Y1 x1 y1 addv
   ordonnepoints
end
} def

%%%%% ### ABcercle ###
%% syntaxe : A B C ABcercle --> le cercle passant par A, B, C
/ABcercle {
3 dict begin
   /@3 defpoint
   /@2 defpoint
   /@1 defpoint
   @1 @2 mediatrice
   @1 @3 mediatrice
   interdroite
   dupp
   @3 distance
end   
} def

%%%%% ### diamcercle ###
%% syntaxe : A B diamcercle --> le cercle de diametre [AB]
/diamcercle {
   4 copy
   distance 2 div
   5 1 roll 
   milieu
   3 -1 roll 
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  droites                           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### horizontale ###
%% syntaxe : y horizontale 
/horizontale {
1 dict begin
   /y exch def
   xmin y xmax y
end
} def

%%%%% ### coeffdir ###
%% syntaxe~: A B coeffdir
/coeffdir {
   vecteur exch div
} def

%%%%% ### ordorig ###
%% syntaxe : A B ordorig
%% attention, la droite est supposee ne pas etre verticale
/ordorig {
   /dr@ite 4 array def
   dr@ite 3 3 -1 roll put
   dr@ite 2 3 -1 roll put
   dr@ite 1 3 -1 roll put
   dr@ite 0 3 -1 roll put
   dr@ite aload pop coeffdir /c@eff exch def
   dr@ite aload pop pop pop  %% xA yA
   exch                      %% yA xA 
   c@eff mul neg add
} def

%%%%% ### verticale ###
%% syntaxe~: A B verticale?
/verticale? {
   pop 2 1 roll pop
   eq
} def

%% syntaxe : x verticale
/verticale {
1 dict begin
   /x exch def
   x ymin x ymax
end
} def

%%%%% ### droite ###
%% %% syntaxe : A B droite
%% /droite {
%% gsave
%% 6 dict begin
%%    /yB exch def
%%    /xB exch def
%%    /yA exch def
%%    /xA exch def
%%    xA yA xB yB
%%    eqp
%%       {}
%%       { 
%%          xA yA xB yB
%%    	 verticale?
%%    	 {
%%    	 newpath
%%    	    xA ymin smoveto
%%    	    xA ymax slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 {
%%    	 newpath
%%    	    /alpha xA yA xB yB coeffdir def
%%    	    /beta xA yA xB yB ordorig def
%%    	    xmin dup alpha mul beta add smoveto
%%    	    xmax dup alpha mul beta add slineto
%%             stockcurrentcpath
%%    	 stroke
%%    	 }
%%    	 ifelse
%%       }
%%    ifelse
%% end
%% grestore
%% } def

%% syntaxe : A B droite
/droite {
gsave
6 dict begin
   /B defpoint
   /A defpoint
   A pop B pop eq {
      %% droite verticale
      newpath
         A pop ymin smoveto
	 A pop ymax slineto
         stockcurrentcpath
      Stroke
   } {
      %% on cherche le point le + a gauche
      xmin A B xdpoint /C defpoint
      C exch pop ymin lt {
         %% trop a gauche
	 ymin A B ydpoint /C defpoint
      } if
      C exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /C defpoint
      } if
      %% on cherche le point le + a droite
      xmax A B xdpoint /D defpoint
      D exch pop ymin lt {
         %% trop a droite
	 ymin A B ydpoint /D defpoint
      } if
      D exch pop ymax gt {
         %% trop a gauche
	 ymax A B ydpoint /D defpoint
      } if
      newpath
         C smoveto
         D slineto
         stockcurrentcpath
     Stroke
   } ifelse
end
grestore
} def

%%%%% ### defdroite ###
%% syntaxe : A B /d defdroite
/defdroite {
1 dict begin
   /t@mp@r@ire exch def
   [ 5 1 roll ] cvx t@mp@r@ire exch 
end def
} def

%%%%% ### paral ###
%% syntaxe : D A paral --> droite parallele a D passant par A
/paral {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### interdroite ###
/interdroite {
                %% A B C D
   /dr@ite2 4 array def
   dr@ite2 3 3 -1 roll put
   dr@ite2 2 3 -1 roll put
   dr@ite2 1 3 -1 roll put
   dr@ite2 0 3 -1 roll put
   /dr@ite1 4 array def
   dr@ite1 3 3 -1 roll put
   dr@ite1 2 3 -1 roll put
   dr@ite1 1 3 -1 roll put
   dr@ite1 0 3 -1 roll put

%%%    %% trace pour deboguage
%%%    dr@ite1 aload pop droite
%%%    dr@ite2 aload pop droite

%%% Dans tous les cas, on suppose que l'intersection existe
%%% 
%%% * la 1ere droite est verticale. les equations reduites sont
%%%       x = a1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%       {{x = a1, y = b2 + a1 a2}}
%%% 
%%% * la 2eme droite est verticale. les equations reduites sont
%%%       x = a1 x+ b1     et       x = a2
%%% Le point d'intersection est :
%%%       {{x = a2, y = b1 + a1 a2}}
%%% 
%%% * aucune n'est verticale. Les equations reduites sont
%%%       y = a1 x + b1      et       y = a2 x + b2
%%% Le point d'intersection est :
%%%                 { {     b2 - b1      a1 b2 - a2 b1 } }
%%%                 { { x = -------, y = ------------- } }
%%%                 { {     a1 - a2         a1 - a2    } }

%%% remarque : pour le moment, je n'arrive pas a rendre mes variables
%%% locales : elle restent globales. Pour que cela ne soit pas trop
%%% genant, je les note respectivement @1, @@1, @2 et @@2 au lieu de a1,
%%% b1, a2 et b2.

   dr@ite1 aload pop verticale?
      {
         /@1 {dr@ite1 aload pop pop pop pop} def
         /@2 {dr@ite2 aload pop coeffdir} def
         /@@2 {dr@ite2 aload pop ordorig} def
         @1 
         @1 @2 mul @@2 add
      }
      {
      dr@ite2 aload pop verticale?
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop pop pop pop} def
            @2
            @1 @2 mul @@1 add
         }
         {
            /@1 {dr@ite1 aload pop coeffdir} def
            /@@1 {dr@ite1 aload pop ordorig} def
            /@2 {dr@ite2 aload pop coeffdir} def
            /@@2 {dr@ite2 aload pop ordorig} def
            @@2 @@1 sub @1 @2 sub div
            @1 @@2 mul @2 @@1 mul sub
            @1 @2 sub div
         }
      ifelse
      }
   ifelse
} def

%%%%% ### perp ###
%% syntaxe : D A perp --> droite perpendiculaire a D passant par A
/perp {
4 dict begin
   /yA exch def
   /xA exch def
   vecteur orthovecteur
   /u2 exch def
   /u1 exch def
   xA yA
   2 copy
   u1 u2 translatepoint
end
} def

%%%%% ### mediatrice ###
%% synaxe : A B mediatrice --> droite
/mediatrice {
   4 copy 
   milieu
   perp
} def

%%%%% ### bissectrice ###
%% syntaxe : A B C bissectrice --> B E ou E est un point de la bissectrice
/bissectrice {
10 dict begin
   /yC exch def
   /xC exch def
   /yB exch def
   /xB exch def
   /yA exch def
   /xA exch def
   /A {xA yA} def
   /B {xB yB} def
   /C {xC yC} def
   /alpha {A B C tripointangle} def
   B
   A B alpha rotatepoint
   A milieu
end
} def

%%%%% ### angledroit  ###
 /widthangledroit 5 def

%% syntaxe : A B C angledroit --> dessine un angle droit en B
/angledroit {
10 dict begin
   dup xcheck {
      /widthangledroit exch def
   } if
   /C defpoint
   /B defpoint
   /A defpoint
   B C vecteur normalize widthangledroit 20 div mulv /u defpoint
   B A vecteur normalize widthangledroit 20 div mulv /v defpoint
   [B u addv dupp v addv B v addv] ligne
end
} def

%%%%% ### translatedroite ###
%% syntaxe : A B u translatedroite --> C D images resp de A et B par la translation de vecteur u
/translatedroite {         %% A B u
   2 copy          %% A B u u
   6 1 roll       
   6 1 roll        %% A u B u 
   addv      %% A u D
   6 1 roll        
   6 1 roll        %% D A u 
   addv
   4 1 roll
   4 1 roll
} def

%%%%% ### rotatedroite ###
%% syntaxe : A B O r rotatedroite --> C D images resp de A et B par la
%% rotation de centre O et d'angle r (en degre)
/rotatedroite {
   5 copy rotatepoint   %% A B O r D
   6 -1 roll pop        %% A xB O r D
   6 -1 roll pop        %% A O r D
   7 1 roll
   7 1 roll rotatepoint %% D C
   4 1 roll 4 1 roll 
} def

/rotatevecteur {
   rotatedroite
} def

/rotatesegment {
   rotatedroite
} def

%%%%% ### axesymdroite ###
%% syntaxe : d D axesymdroite --> droite d', symetrique de la droite d par rapport
%% a la droite D
/axesymdroite {
2 dict begin
   /D defdroite
   /B defpoint
   D axesympoint
   B D axesympoint
end   
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  polygones                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### poltransformfile ###
%% syntaxe : pol u translatepol --> pol'
/translatepol {
2 dict begin   
   /uy exch def
   /ux exch def
   {ux uy translatepoint} papply
end
} def

%% syntaxe : pol u rotatepol --> pol'
/rotatepol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha rotatepoint} papply
end
} def

%% syntaxe : pol I alpha hompol --> pol'
/hompol {
2 dict begin   
   /alpha exch def
   /I defpoint
   {I alpha hompoint} papply
end
} def

%% syntaxe : pol I sympol --> pol'
/sympol {
1 dict begin   
   /I defpoint
   {I sympoint} papply
end
} def

%% syntaxe : pol D axesympol --> pol'
/axesympol {
1 dict begin   
   /D defdroite
   {D axesympoint} papply
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  les tests                         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### isbool ###
%% syntaxe : any isbool --> booleen
/isbool {
   type (booleantype) cvn eq
} def

%%%%% ### isarray ###
%% syntaxe : any isarray --> booleen
/isarray {
   type (arraytype) cvn eq
} def

%%%%% ### isstring ###
%% syntaxe : any isstring --> booleen
/isstring {
   type (stringtype) cvn eq
} def

%%%%% ### isinteger ###
%% syntaxe : any isinteger --> booleen
/isinteger {
   type (integertype) cvn eq
} def

%%%%% ### isnum ###
%% syntaxe : any isnum --> booleen
/isnum {
   dup isreal 
   exch isinteger or
} def

%%%%% ### isreal ###
%% syntaxe : any isreal --> booleen
/isreal {
   type (realtype) cvn eq
} def

%%%%% ### eq ###
%% syntaxe : A B eqp3d --> booleen = true si les points A et B sont identiques
/eqp3d {
               %% x1 y1 z1 x2 y2 z2
   4 -1 roll   %% x1 y1 x2 y2 z2 z1 
   eq {        %% x1 y1 x2 y2 
      eqp
   } {
      pop pop pop pop false
   } ifelse
} def

%% syntaxe : A B eqp --> booleen = true si les points A et B sont identiques
/eqp {
   3 -1 roll
   eq 
      {
         eq 
            {true} 
            {false}
         ifelse
      }
      {pop pop false}
   ifelse
} def

%% syntaxe : z z' eqc --> true si z = z', false sinon
/eqc {
   eqp
} def

%%%%% ### eqstring ###
/eqstring {
3 dict begin
   /str2 exch def
   /str1 exch def
   str1 length str2 length eq {
      /i 0 def
      true
      str1 length {
         str1 i get str2 i get eq and
         /i i 1 add store
      } repeat
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                conversions de types                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### astr2str ###
%% syntaxe : array str astr2str --> str
%% convertit le contenu de array en chaines de caracteres puis les
%% concatene avec str, en inserant un caractere "space" apres chaque
%% element du tableau array
/astr2str {
5 dict begin
   /str exch def
   /table exch def
   /n table length def
   n 0 eq {
      str
   } {
      table 0 n 1 sub getinterval
      table n 1 sub get (                               ) cvs
      ( ) append
      str append
      astr2str
   } ifelse
end
} def

%%%%% ### numstr2array ###
%% syntaxe : str str2num --> num
/str2num {
5 dict begin
   /str exch def
   /n str length def
   /signnum 1 def
   /frct false def
   /k 0 def
   0 1 n 1 sub {
      /i exch def
      str i get
      dup 46 eq {
         %% il y a un point
         /frct true def
         pop
         i 0 eq {
            0
         } if
      } {
         dup 45 eq {
            /signnum -1 def
            pop
         } {
            frct not {
               i 1 ge signnum 0 ge and i 2 ge or {
                  exch 10 mul 48 sub add
               } {
                  48 sub
               } ifelse
            } {
               48 sub
               /k k 1 add store
               10 k exp div add
            } ifelse
         } ifelse
      } ifelse
   } for
   signnum mul
end
} def

/str2num {cvx exec} def

%% syntaxe : str numstr2array -> array
%% ou str est une chaine de nombres reels separes par des espaces
%% et array est constitue des elements numeriques de string.
%% exemple :
%% (0 -12 .234 54) --> [0 -12 0.234 54]
/numstr2array {
6 dict begin
   /str exch def
   /n str length def
   /separateurs [] def
   [
      0 1 n 1 sub {
         /i exch def
         str i get
         32 eq {
            /separateurs [separateurs aload pop i] def
         } if
      } for
      /j 0 def
      /oldsep 0 def
      0 1 separateurs length 1 sub {
         /i exch def
         str j separateurs i get oldsep sub getinterval str2num
         /j separateurs i get 1 add def
         /oldsep separateurs i get 1 add def
      } for
      str j n oldsep sub getinterval str2num
   ]
end
} def

%% syntaxe : array numstr2array -> array
/arraynumstr2arrayarray {
   {numstr2array} apply
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                macros de projection                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### projtext ###
%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str x0 y0 plantype ultextp3d --> -
%% syntaxe : str x0 y0 plantype bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
 /initpr@jtext {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /type_plan_proj true def
      /lepl@n exch def
      lepl@n plangetbase aload pop
      /@V defpoint3d
      /@U defpoint3d
      lepl@n plangetorigine
      /z0 exch def
      /y0 exch def
      /x0 exch def
      /table [@U @U @V vectprod3d] def
   } {
      dup isarray {
         %% c est un planprojpath
         /type_plan_proj true def
         /table exch def
         /z0 exch def
         /y0 exch def
         /x0 exch def
         0 0
      } {
         %% c est un solidprojpath
         /type_plan_proj false def
         %% y a-t-il un str2
         dup isstring {
            /str2 exch def
         } {
            /str2 {} def
         } ifelse
         %% y a-t-il un alpha
         2 copy pop issolid {
            /alpha 0 def
         } {
            /alpha exch def
         } ifelse
         /i exch def
         /solid exch def
         0 0
      } ifelse
   } ifelse
} def
 /closepr@jtext {
   type_plan_proj {
      x0 y0 z0 table mybool projpath
   } {
      solid i alpha str2 mybool projpath
   } ifelse
   Fill
   Stroke
end
} def

%% syntaxe : str x0 y0 z0 [normal_vect] ultextp3d --> -
%% syntaxe : str x0 y0 z0 [normal_vect] bool ultextp3d --> -
%% syntaxe : str1 solid i str2 ultextp3d --> -
%% syntaxe : str1 solid i str2 bool ultextp3d --> -
%% syntaxe : str1 solid i alpha str2 bool ultextp3d --> -
/ultextp3d {initpr@jtext ultext_ closepr@jtext} def
/cltextp3d {initpr@jtext cltext_ closepr@jtext} def
/bltextp3d {initpr@jtext bltext_ closepr@jtext} def
/dltextp3d {initpr@jtext dltext_ closepr@jtext} def
/ubtextp3d {initpr@jtext ubtext_ closepr@jtext} def
/cbtextp3d {initpr@jtext cbtext_ closepr@jtext} def
/bbtextp3d {initpr@jtext bbtext_ closepr@jtext} def
/dbtextp3d {initpr@jtext dbtext_ closepr@jtext} def
/uctextp3d {initpr@jtext uctext_ closepr@jtext} def
/cctextp3d {initpr@jtext cctext_ closepr@jtext} def
/bctextp3d {initpr@jtext bctext_ closepr@jtext} def
/dctextp3d {initpr@jtext dctext_ closepr@jtext} def
/urtextp3d {initpr@jtext urtext_ closepr@jtext} def
/crtextp3d {initpr@jtext crtext_ closepr@jtext} def
/brtextp3d {initpr@jtext brtext_ closepr@jtext} def
/drtextp3d {initpr@jtext drtext_ closepr@jtext} def

%%%%% ### currentppathtransform ###
%% syntaxe : {f} currentppathtransform --> applique la transformation f
%% au chemin courant
/currentppathtransform {
6 dict begin
   /warp exch def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp moveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp lineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      curveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%% syntaxe : {f} currentpathtransform --> applique la transformation f
%% au chemin courant
/currentpathtransform {
7 dict begin
   /transform exch def
   /warp {ptojpoint transform} def
   %% pour remplacer 'move'
   /warpmove{
      2 index {
        newpath
      } if
      warp smoveto
      pop false
   } def

   %% pour remplacer 'lineto'
   /warpline {
      warp slineto
   } bind def

   %% pour remplacer 'curveto'
   /warpcurve {
      6 2 roll warp
      6 2  roll warp
      6 2 roll warp
      scurveto
   }  bind def

   true
   { warpmove } {  warpline } { warpcurve } { closepath } pathforall
   pop
end
} def

%%%%% ### normalvect_to_orthobase ###
%% syntaxe : [normal_vect] normalvect_to_orthobase
%%    --> imI imJ imK
/normalvect_to_orthobase {
4 dict begin
   dup length 3 eq {
      aload pop normalize3d /normal_vect defpoint3d
      normal_vect -1 0 0 eqp3d {
         /imageI {0 -1 0} def
         /imageK {-1 0 0} def
         /imageJ {0 0 1} def 
      } {
         %% on calcule l image de la base (I,J,K)
         /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
         /imageK {normal_vect} def
         /imageI {imageJ imageK vectprod3d} def
         1 0 0 imageK angle3d 0 eq {
            0 1 0 normal_vect vectprod3d /imageI defpoint3d
            /imageJ {0 1 0} def
            normal_vect /imageK defpoint3d
         } if
      } ifelse
   } {
      dup length 6 eq {
         aload pop
         normalize3d /imageK defpoint3d
         normalize3d /imageI defpoint3d
         imageK imageI vectprod3d /imageJ defpoint3d
      } {
         dup length 7 eq {
            aload pop 
            /alpha exch 2 div def
            normalize3d /imageK defpoint3d
            normalize3d /imageI defpoint3d
            imageK imageI vectprod3d /imageJ defpoint3d
            %% et ensuite, on fait tourner la base autour de imageK
            imageI alpha cos mulv3d
            imageJ alpha sin mulv3d
            addv3d
   
            imageI alpha sin neg mulv3d
            imageJ alpha cos mulv3d
            addv3d
   
            /imageJ defpoint3d
            /imageI defpoint3d
         } {
            %% length = 4
            aload pop
            /alpha exch def
            normalize3d /normal_vect defpoint3d
   
            normal_vect -1 0 0 eqp3d {
               /imageI {0 -1 0} def
               /imageK {-1 0 0} def
               /imageJ {0 0 1} def 
            } {
               %% on calcule l image de la base (I,J,K)
               /imageJ {normal_vect 1 0 0 vectprod3d normalize3d} def
               /imageK {normal_vect} def
               /imageI {imageJ imageK vectprod3d} def
               1 0 0 imageK angle3d 0 eq {
                  0 1 0 normal_vect vectprod3d /imageI defpoint3d
                  /imageJ {0 1 0} def
                  normal_vect /imageK defpoint3d
               } if
            } ifelse
         } ifelse

         %% et ensuite, on fait tourner la base autour de imageK
         imageI alpha cos mulv3d
         imageJ alpha sin mulv3d
         addv3d

         imageI alpha sin neg mulv3d
         imageJ alpha cos mulv3d
         addv3d

         /imageJ defpoint3d
         /imageI defpoint3d
      } ifelse
   } ifelse
   imageI
   imageJ
   imageK
end
} def

%%%%% ### projpath ###
%% syntaxe : x y z [normal] projpath --> planprojpath
%% syntaxe : x y z [normal] bool projpath --> planprojpath
%% syntaxe : solid i projpath --> solidprojpath
%% syntaxe : solid i bool projpath --> solidprojpath
%% syntaxe : solid i str bool projpath --> solidprojpath
%% syntaxe : solid i alpha str bool projpath --> solidprojpath
/projpath {
2 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      3 dict begin
         /lepl@n exch def
         lepl@n plangetbase aload pop
         /@V defpoint3d
         /@U defpoint3d
         lepl@n plangetorigine
         [@U @U @V vectprod3d] mybool planprojpath
      end
   } {
      dup isarray {
         mybool planprojpath
      } {
         mybool solidprojpath
      } ifelse
   } ifelse
end
} def


%% %% syntaxe : x y z [normal] projpath --> planprojpath
%% %% syntaxe : x y z [normal] bool projpath --> planprojpath
%% %% syntaxe : solid i projpath --> solidprojpath
%% %% syntaxe : solid i bool projpath --> solidprojpath
%% %% syntaxe : solid i str bool projpath --> solidprojpath
%% %% syntaxe : solid i alpha str bool projpath --> solidprojpath
%% /projpath {
%% 2 dict begin
%%    dup isbool {
%%       /mybool exch def
%%    } {
%%       /mybool true def
%%    } ifelse
%%    dup isarray {
%%       mybool planprojpath
%%    } {
%%       mybool solidprojpath
%%    } ifelse
%% end
%% } def
%% 
%% syntaxe : solid i str bool solidprojpath --> -
%% ou
%% syntaxe : solid i alpha str bool solidprojpath --> -
%% projette le chemin courant sur la face i du solide, apres
%% eventuellement une rotation d angle alpha autour de la normale
%% bool : pour savoir si on tient compte de la visibilite
/solidprojpath {
5 dict begin
   /visibility exch def
   dup isstring {
      /option exch def
   } if
   2 copy pop
   issolid {
      /alpha 0 def
   } {
      /alpha exch def
   } ifelse
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidprojpath) ==
   } if
   /n solid solidnombrefaces def
   i n 1 sub le {
      visibility not solid i solidfacevisible? or {
         currentdict /option known {
            option cvx exec
         } {
            solid i solidcentreface 
         } ifelse
         [
            solid 0 i solidgetsommetface 
            solid 1 i solidgetsommetface 
            vecteur3d normalize3d
            solid i solidnormaleface alpha 
         ] false planprojpath 
      } {
         newpath 0 0 smoveto
      } ifelse
   } {
      (Error : indice trop grand dans solidprojpath) ==
      quit
   } ifelse
end
} def

%% syntaxe : x y z [normal] bool planprojpath
/planprojpath {
6 dict begin
   /visibility exch def
   %% on calcule l image de la base (I,J,K)
   normalvect_to_orthobase
   /imageK defpoint3d
   /imageJ defpoint3d
   /imageI defpoint3d
   /z exch def
   /y exch def
   /x exch def

   visibility not x y z imageK planvisible? or {
      {ptojpoint 0
      imageI
      imageJ
      imageK
      transformpoint3d
      x y z addv3d
      3dto2d jtoppoint} currentppathtransform
   } {
      newpath
   } ifelse
end
} def

%%%%% ### projscene ###
%% syntaxe : plantype bool bprojscene ... eprojscene
/bprojscene {
10 dict begin
gsave
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /l@pl@n exch def
   /saveStroke {SolidesDict /Stroke get exec} def
   /Stroke {l@pl@n mybool projpath saveStroke} def
   /savefill {SolidesDict /Fill get exec} def
   /Fill {l@pl@n mybool projpath savefill} def
   /masque {} def
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
%%       xmin ymin l@pl@n pointplan smoveto
%%       xmin ymax l@pl@n pointplan slineto
%%       xmax ymax l@pl@n pointplan slineto
%%       xmax ymin l@pl@n pointplan slineto
%%       xmin ymin l@pl@n pointplan smoveto
%%  %   closepath
%% %gsave orange Fill grestore
%%    clip
} def
/eprojscene {
grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          fonctions numeriques                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### courbeparam ###
/setresolution {
   /resolution exch def
} def
/resolution 200 def

/courbe_dic 2 dict def
courbe_dic /X {} put
courbe_dic /Y {} put

%% syntaxe : tmin tmax C@urbeparam_
 /C@urbeparam_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR
   tmin@ courbe_dic /Y get exec
   pstrickactionR
   smoveto
   resolution 1 sub
   {
      t courbe_dic /X get exec
      pstrickactionR
      t courbe_dic /Y get exec
      pstrickactionR
      slineto

      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR
   tmax@ courbe_dic /Y get exec
   pstrickactionR
   slineto
end
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam_
/Courbeparam_ {
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   C@urbeparam_
} def

%% syntaxe : {X} {Y} courbeparam_
/courbeparam_ {
   tmin tmax
   4 -1 roll
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam
/Courbeparam {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /Y exch put
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin courbe_dic /X get exec
      pstrickactionR
      tmin courbe_dic /Y get exec
      pstrickactionR
      smoveto                        %% on commence le chemin
      tmin tmax C@urbeparam_
      starfill

   stockcurrentcpath
   newarrowpath
   currentdict /option known
      {
         /dt tmax tmin sub resolution 1 sub div def
         tmin dt add courbe_dic /X get exec
         tmin dt add courbe_dic /Y get exec
         tmin courbe_dic /X get exec
         tmin courbe_dic /Y get exec
         arrowpath0
         tmax dt sub courbe_dic /X get exec
         tmax dt sub courbe_dic /Y get exec
         tmax courbe_dic /X get exec
         tmax courbe_dic /Y get exec
         currentdict /dt undef
         arrowpath1
         option
         gere_arrowhead
      }
   if

   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} {Y} courbeparam
/courbeparam {
   dup isstring
      {
         tmin tmax
         5 -1 roll
         5 -1 roll
         5 -1 roll
      }
      {
         tmin tmax
         4 -1 roll
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : tmin tmax {X} {Y} Courbeparam*
/Courbeparam* {
1 dict begin
   /startest {true} def
   Courbeparam
end
} def

%% syntaxe : {X} {Y} courbeparam*
/courbeparam* {
1 dict begin
   /startest {true} def
   courbeparam
end
} def

%%%%% ### courbe ###
%% syntaxe : {f} courbe
/courbe {
   dup isstring   %% y a-t-il une option de fin de ligne ?
      {
         xmin xmax 
         {} 
         5 -1 roll
         5 -1 roll
      }
      {
         xmin xmax 
         {} 
         4 -1 roll
      }
   ifelse
   Courbeparam
} def

%% syntaxe : mini maxi {f} Courbe
/Courbe {
   dup isstring {
      {}
      3 -1 roll
      3 -1 roll
   } {
      {}
      2 -1 roll
   } ifelse
   Courbeparam
} def

%% syntaxe : {f} courbe_
/courbe_ {
   xmin xmax 
   {} 
   4 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe_
/Courbe_ {
   {}
   2 -1 roll
   Courbeparam_
} def

%% syntaxe : mini maxi {f} Courbe*
/Courbe* {
1 dict begin
   /startest {true} def
   Courbe
end
} def

%% syntaxe : {f} courbe*
/courbe* {
1 dict begin
   /startest {true} def
   courbe
end
} def

%%%%% ### courbeR2 ###
%% syntaxe : tmin tmax C@urbeR2_
 /C@urbeR2_ {
6 dict begin
   /tmax@ exch def
   /tmin@ exch def
   /t tmin@ def
   /dt tmax@ tmin@ sub resolution 1 sub div def
   tmin@ courbe_dic /X get exec
   pstrickactionR2
   smoveto
   /t t dt add store
   resolution 2 sub
   {
      t courbe_dic /X get exec
      pstrickactionR2
      slineto
      /t t dt add store                      %% on incremente
   }
   repeat
   tmax@ courbe_dic /X get exec
   pstrickactionR2
   slineto
end
} def

%% syntaxe : tmin tmax {X} CourbeR2_
/CourbeR2_ {
   courbe_dic exch /X exch put
   C@urbeR2_
} def

%% syntaxe : {X} courbeR2_
/courbeR2_ {
   tmin tmax
   3 -1 roll
   3 -1 roll
   CourbeR2_
} def

%% syntaxe : tmin tmax {X} CourbeR2
/CourbeR2+ {
2 dict begin
   /slineto {} def
   /smoveto {} def
   CourbeR2
end
} bind def

/CourbeR2 {
gsave
6 dict begin
   dup isstring
      {
         /option exch def
      }
   if
   courbe_dic exch /X exch put
   /tmax exch def
   /tmin exch def

   newpath
      tmin tmax C@urbeR2_
      starfill
   currentlinewidth 0 eq {} { Stroke } ifelse

end
grestore
} def

%% syntaxe : {X} courbeR2
/courbeR2 {
   tmin tmax
   3 -1 roll
   CourbeR2
} def

%% syntaxe : tmin tmax {X} CourbeR2*
/CourbeR2* {
1 dict begin
   /startest {true} def
   CourbeR2
end
} def

%% syntaxe : {X} {Y} courbeR2*
/courbeR2* {
1 dict begin
   /startest {true} def
   courbeR2
end
} def

%%%%% ### courbeR3 ###
%% syntaxe : t1 t2 {f} (option) CourbeR3
/CourbeR3 {
2 dict begin
   dup isstring {
      /option exch def
   } if
   /lafonction exch def
   {lafonction 3dto2d}
   currentdict /option known
      {option}
   if
  CourbeR2
end
} def

%% syntaxe : {f} (option) CourbeR3
/courbeR3 {
   tmin tmax 3 -1 roll CourbeR3
} def

%%%%% ### cercle ###
%% syntaxe : x0 y0 r cercle
/cercle {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam
end
} def

%% syntaxe : x0 y0 r cercle_
/cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   0 360 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle-_
/cercle-_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   x@ r@y@n add y@ smoveto
   360 0 {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : x0 y0 r cercle*
/cercle* {
1 dict begin
   /startest true def
   cercle
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle {
4 dict begin
   dup isstring
      {/option exch def}
   if
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} 
   currentdict /option known
      {option}
   if
   Courbeparam
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle_
/Cercle_ {
3 dict begin
   /r@y@n exch def
   /y@ exch def
   /x@ exch def
   {cos r@y@n mul x@ add} {sin r@y@n mul y@ add} Courbeparam_
end
} def

%% syntaxe : alpha beta x0 y0 r Cercle
/Cercle* {
1 dict begin
   /startest {true} def
   Cercle
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%      fonctions et constantes mathematiques         %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### math ###
%%%%%%%%%%% constantes mathematiques %%%%%%%%%%%%%%

/pi 3.14159 def
/e 2.71828 def

%%%%%%%%%%% fonctions mathematiques %%%%%%%%%%%%%%%

/rd {180 pi div mul} def        %% transforme des rd en degres
/deg {pi mul 180 div} def       %% transforme des degres en rd
/log {ln 10 ln div} def
/Exp {e exch exp} def
/Cos {rd cos} def
/Sin {rd sin} def
/tan {dup sin exch cos div} def
/cotan {dup cos exch sin div} def
/Tan {dup Sin exch Cos div} def
/Cotan {dup Cos exch Sin div} def
/coTan {Cotan} def
/arctan {
dup 0 ge
   {1 atan}
   {neg 1 atan neg}
ifelse
} def
/Arctan {arctan deg} def
/arccos {
   dup
   dup mul neg 1 add sqrt
   exch
   atan
} def
/Arccos {arccos deg} def
/arcsin {
   dup 1 eq {
      90
   } {
      dup
      dup mul neg 1 add sqrt
      atan
      dup 90 lt
         {}
         {360 sub}
      ifelse
   } ifelse
} def
/Arcsin {arcsin deg} def
/cosh {dup Exp exch neg Exp add 2 div} def
/sinh {dup Exp exch neg Exp sub 2 div} def
/tanh {dup sinh exch cosh div} def
/cotanh {dup cosh exch sinh div} def
/argcosh {dup dup mul 1 sub sqrt add ln} def
/argsinh {dup dup mul 1 add sqrt add ln} def
/argtanh {
   setxvar
   x 1 add
   1 x sub
   div
   ln
   2 div
} def
/factorielle {
      dup 0 eq
         {pop 1}
         {dup 1 sub factorielle mul}
      ifelse
} def
/Gauss {
3 dict begin
   /sigma exch def
   /m exch def
   /x exch def
   x m sub dup mul sigma dup mul 2 mul div neg Exp
   2 pi mul sigma dup mul mul sqrt div
end
} def
%% syntaxe : a n modulo
/modulo {
2 dict begin
   /n exch def
   /a exch def
   {
      a 0 lt {
         /a a n add store
      } {
         exit
      } ifelse
   } loop
   a n mod
end
} def

%%%%% ### max ###
/max {
   2 copy
   lt {exch} if
   pop
} def

%%%%% ### min ###
/min {
2 dict begin
   dup isarray {
      duparray /table exch def pop
      table 0 get
      1 1 table length 1 sub {
         /i exch def
         table i get
         min
      } for
   } {
      2 copy
      gt {exch} if
      pop
   } ifelse
end
} def

%%%%% ### setcolor ###
%% syntaxe : tableau setcolor
/setcolor {
   dup length 4 eq
      {aload pop setcmykcolor}
      {aload pop setrgbcolor}
   ifelse
} def

%%%%% ### in ###
%% cherche si un elt donne appartient au tableau donne
%% rque : utilise 3 variables locales
%% syntaxe : elt array in --> index boolean
/in {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         i true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%% cherche si un elt donne appartient au tableau donne
%% syntaxe : elt array in --> boolean
/In {
3 dict begin
   /liste exch def
   /elt exch def
   /i 0 def
   false                        %% la reponse a priori
   liste length {
      liste i get elt eq {
         pop                    %% en enleve la reponse
         true                 %% pour mettre la bonne
         exit
      } if
      /i i 1 add store
   } repeat
end
} def

%%%%% ### starfill ###
%% la procedure pour les objets "star"
%% si c est "star" on fait le fillstyle, sinon non
/starfill {
   startest {
      gsave
         clip
         fillstyle
      grestore
      /startest false def
   } if
} def

%%%%% ### addv ###
%% syntaxe : u v addv --> u+v
/addv {         %% xA yA xB yB
   3 1 roll     %% xA yB yA xB 
   4 1 roll     %% xB xA yB yA 
   add 3 1 roll %% yB+yA xB xA 
   add exch
} def

%%%%% ### continu ### 
/continu {
   [] 0 setdash 
} def

%%%%% ### trigospherique ### 
%% passage spherique --> cartesiennes
%% les formules de passage ont t rcupres ici :
%%    http://fr.wikipedia.org/wiki/Coordonn%C3%A9es_polaires
%% syntaxe : r theta phi rtp2xyz -> x y z
/rtp2xyz {
6 dict begin
   /phi exch def
   /theta exch def
   /r exch def
   /x phi cos theta cos mul r mul def 
   /y phi cos theta sin mul r mul def
   /z phi sin r mul def
   x y z
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique {
9 dict begin
   dup isstring {
      /option exch def
   } if
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] 
      currentdict /option known {
         option
      } if
      ligne3d
   grestore
end
} def

%% trace d'un arc sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 arcspherique
/arcspherique_ {
8 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 12 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /n 12 def
   /pas alpha n div def

   /t pas neg def
   [
      n 1 add {
         /t  t pas add store
         u t cos r mul mulv3d
         w t sin r mul mulv3d
         addv3d
      } repeat
   ] ligne3d_
end
} def

%% trace d'une geodesique sur une sphere de centre O
%% syntaxe : r theta1 phi1 r theta2 phi2 geodesique_sphere
/geodesique_sphere {
13 dict begin
   /phi2 exch def
   /theta2 exch def
   pop
   /phi1 exch def
   /theta1 exch def
   /r exch def
   /n 360 def

   1 theta1 phi1 rtp2xyz /u defpoint3d
   1 theta2 phi2 rtp2xyz /v defpoint3d
   u v vectprod3d u vectprod3d dupp3d norme3d 1 exch div mulv3d /w defpoint3d

   /sinalpha u v vectprod3d norme3d def
   /cosalpha u v scalprod3d def
   /alpha sinalpha cosalpha atan def
   /pas 360 n div def

   gsave
      /t pas neg def
      [
         n 1 add {
            /t  t pas add store
            u t cos r mul mulv3d
            w t sin r mul mulv3d
            addv3d
         } repeat
      ] ligne3d
   grestore
end
} def


%% syntaxe : A B C trianglespherique --> trace le rtiangle ABC
%% (coordonnees spheriques)
/trianglespherique* {
1 dict begin
   /startest {true} def
   trianglespherique
end
} def

/trianglespherique {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   gsave
   newpath
      A rtp2xyz 3dto2d smoveto
      A B arcspherique_
      B C arcspherique_
      C A arcspherique_
   closepath
   starfill
   currentlinewidth 0 eq {} { Stroke } ifelse
   grestore
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         operations sur les tableaux                %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### duparray ###
/duparray {
1 dict begin
   /table exch def
   table
   [ table aload pop ]
end
} def

%%%%% ### append ###
%% syntaxe : string1 string2 append --> concatene les 2 chaines ou fusionne 2 tableaux
/append {
3 dict begin
   dup isarray {
      /tab2 exch def
      /tab1 exch def
      [ tab1 aload pop tab2 aload pop ]
   } {
      /str2 exch def
      /str1 exch def
      /result str1 length str2 length add string def
      str1 result copy pop
      result str1 length str2 putinterval
      result
   } ifelse
end
} def

%%%%% ### rollparray ###
%% syntaxe : array n rollparray -> array
%% opere une rotation de n sur les couplets du tableau array
/rollparray {
4 dict begin
   /k exch def
   /table exch def
   /n table length def
   k 0 eq {
       table
   } {
       k 0 ge {
          [ table aload pop 2 {n 1 roll} repeat ]
           k 1 sub
       } {
          [ table aload pop 2 {n -1 roll} repeat ]
           k 1 add
       } ifelse
       rollparray
   } ifelse
end
} def

%%%%% ### bubblesort ###
%% syntaxe : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 15/08/2006
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublebubblesort {
5 dict begin
   /table exch def
   /n table length 1 sub def
   /indices [ 0 1 n {} for ] def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            table i get table i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               table i 1 add
               table i get
               table i table i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put

               indices i 1 add
               indices i get
               indices i indices i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   indices table
end
} def

%%%%% ### quicksort ###
%% src : http://www.math.ubc.ca/~cass/graphics/text/www/code/sort.inc
%% code de Bill Casselman, modifie par jpv, 18/10/2007

/qsortdict 8 dict def

qsortdict begin

% args: /comp a L R x
% effect: effects a partition into two pieces [L j] [i R]
%     leaves i j on stack

/partition { 8 dict begin
/x exch def
/j exch def
/i exch def
/a exch def
load /comp exch def
{
  {
    a i get x comp exec not {
      exit
    } if
    /i i 1 add def
  } loop
  {
    x a j get comp exec not {
      exit
    } if
    /j j 1 sub def
  } loop

  i j le {
    % swap a[i] a[j]
    a j a i get
    a i a j get
    put put
    indices j indices i get
    indices i indices j get
    put put
    /i i 1 add def
    /j j 1 sub def
  } if
  i j gt {
    exit
  } if
} loop
i j
end } def

% args: /comp a L R
% effect: sorts a[L .. R] according to comp

/subsort {
% /c a L R
[ 3 1 roll ] 3 copy
% /c a [L R] /c a [L R]
aload aload pop
% /c a [L R] /c a L R L R
add 2 idiv
% /c a [L R] /c a L R (L+R)/2
3 index exch get
% /c a [L R] /c a L R x
partition
% /c a [L R] i j
% if j > L subsort(a, L, j)
dup
% /c a [L R] i j j
3 index 0 get gt {
  % /c a [L R] i j
  5 copy
  % /c a [L R] i j /c a [L R] i j
  exch pop
  % /c a [L R] i j /c a [L R] j
  exch 0 get exch
  % ... /c a L j
  subsort
} if
% /c a [L R] i j
pop dup
% /c a [L R] i i
% if i < R subsort(a, i, R)
2 index 1 get lt {
  % /c a [L R] i
  exch 1 get
  % /c a i R
  subsort
}{
  4 { pop } repeat
} ifelse
} def

end

% args: /comp a
% effect: sorts the array a
% comp returns truth of x < y for entries in a

/quicksort { qsortdict begin
dup length 1 gt {
% /comp a
dup
% /comp a a
length 1 sub
% /comp a n-1
0 exch subsort
} {
pop pop
} ifelse
end } def

% ----------------------------------------

%% fin du code de Bill Casselman

%% syntaxe : array1 doublebubblesort --> array2 array3, array3 est
%% trie par ordre croissant et array2 correspond a la position des
%% indices de depart, ie si array1 = [3 2 4 1], alors array2 = [3 1 0 2]
%% code de Bill Casselman, modifie par jpv, 18/10/2007
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/doublequicksort {
qsortdict begin
   /comp exch
   /a exch def
   a dup length /n exch def
   /indices [0 1 n 1 sub {} for ] def
   dup length 1 gt {
      % /comp a
      dup
      % /comp a a
      length 1 sub
      % /comp a n-1
      0 exch subsort
   } {
      pop pop
   } ifelse
   indices a
end
} def

/comp {lt} def

%%%%% ### apply ###
%% syntaxe : [x1 ... xn] (f) apply --> [f(x1) ... f(xn)]
/apply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length {
      liste @i get fonction
      /@i @i 1 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) papply
/papply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse
   /liste exch def
   /@i 0 def
   [
   liste length 2 idiv {
      liste @i get
      liste @i 1 add get
      fonction
      /@i @i 2 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%% syntaxe : [x1 ... xn] (f) capply 
/capply {
3 dict begin
   dup isstring
      {/fonction exch cvx def}
      {/fonction exch def}
   ifelse   
   /liste exch def
   /@i 0 def
   [
   liste length 3 idiv {
      liste @i get 
      liste @i 1 add get 
      liste @i 2 add get 
      fonction
      /@i @i 3 add store
   } repeat
   counttomark 
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### reverse ###
%% syntaxe : array reverse --> inverse l ordre des items dans
%% le tableau
/reverse {
3 dict begin
   /le_tableau exch def
   /n le_tableau length def
   /i n 1 sub def
   [
      n {
         le_tableau i get
         /i i 1 sub store
      } repeat
   ]
end
} def

%% syntaxe : array_points reversep --> inverse l ordre des points dans
%% le tableau
/reversep {
3 dict begin
   /le_tableau exch def
   /n le_tableau length 2 idiv def
   /i n 1 sub def
   [
      n {
         le_tableau i getp
         /i i 1 sub store
      } repeat
   ]
end
} def

%%%%% ### get ###
%% syntaxe : array_points n getp --> le n-ieme point du tableau de
%% points array_points
/getp {
   2 copy
   2 mul get
   3 1 roll
   2 mul 1 add get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             matrices                               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### linear ###
%% syntaxe : M i j any --> depose any dans M en a_ij
/put_ij {
5 dict begin
   /a exch def
   /j exch def
   /i exch def
   /M exch def
   /L M i get_Li def
   L j a put
   M i L put_Li
end
} def

%% syntaxe : M i j get_ij --> le coeff c_ij
/get_ij {
   3 1 roll   %% j M i
   get_Li     %% j L_i
   exch get
} def

%% syntaxe : M i L put_Li --> remplace dans M la ligne Li par L
/put_Li {
   put
} def

%% syntaxe : M i get_Li --> la ligne Li de M
/get_Li {
   get
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (calculs)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### p3dtoplane ###
%% syntaxe : x y z P p3dtoplane --> X Y
/p3dtoplane {
5 dict begin
   /leplan exch def
   /M defpoint3d
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   I M vecteur3d U scalprod3d
   I M vecteur3d V scalprod3d
end
} def

%%%%% ### pplaneto3d ###
%% syntaxe : x y P pplaneto3d --> X Y Z
/pplaneto3d {
6 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   leplan plangetorigine /I defpoint3d
   U x mulv3d
   V y mulv3d addv3d
   I addv3d
end
} def

%%%%% ### orthoprojplane3d ### 
%% Projection orthogonale d'un point 3d sur un plan
%% Mx My Mz (=le point a projeter) 
%% Ax Ay Az (=un point du plan) 
%% Vx Vy Vz (un vecteur normal au plan)
/orthoprojplane3d { 
4 dict begin
   dup isplan {
      /monplan exch def
      monplan plangetorigine
      monplan plangetbase aload pop vectprod3d
   } if
   /V defpoint3d
   /A defpoint3d
   /M defpoint3d
   /VN {V unitaire3d} def
   VN M A vecteur3d VN scalprod3d mulv3d
   M addv3d
end
} def

%%%%% ### sortp3d ### 
/sortp3d {
6 dict begin
   /M1 defpoint3d
   /M0 defpoint3d
   M1
   /z1 exch def
   /y1 exch def
   /x1 exch def
   M0
   /z0 exch def
   /y0 exch def
   /x0 exch def
   x0 x1 lt {
      M0 M1
   } {
      x0 x1 gt {
         M1 M0
      } {
         y0 y1 lt {
            M0 M1
         } {
            y0 y1 gt {
               M1 M0
            } {
               z0 z1 lt {
                  M0 M1
               } {
                  M1 M0
               } ifelse
            } ifelse
         } ifelse
      } ifelse
   } ifelse
end
} def

%%%%% ### dupp3d ### 
%% duplique le vecteur 3d
/dupp3d { %% x y z
        3 copy
} def
/dupv3d {dupp3d} def

%%%%% ### angle3d ###
%% syntaxe : vect1 vect2 angle3d
/angle3d {
4 dict begin
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d norme3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### transformpoint3d ###
%% syntaxe : x y z a11 a21 a31 a12 a22 a32 a13 a23 a33
%%    transformpoint3d -> X Y Z
/transformpoint3d {
12 dict begin
   /a33 exch def
   /a23 exch def
   /a13 exch def
   /a32 exch def
   /a22 exch def
   /a12 exch def
   /a31 exch def
   /a21 exch def
   /a11 exch def
   /z   exch def
   /y   exch def
   /x   exch def
   a11 x mul a12 y mul add a13 z mul add
   a21 x mul a22 y mul add a23 z mul add
   a31 x mul a32 y mul add a33 z mul add
end
} def

%%%%% ### normalize3d ###
%% rend le vecteur 3d unitaire. Ne fait rien si u=0
/unitaire3d { %% x y z
2 dict begin
   /u defpoint3d
   /norme u norme3d def
   norme 0 eq {
      u
   } {
      u 1 norme div mulv3d
   } ifelse
end
} def
/normalize3d {unitaire3d} def

%%%%% ### geom3d ###
%% syntaxe : A k1 B k2 barycentre3d -> G, barycentre du systeme
%% [(A, k1) (B, k2)]
/barycentre3d {
4 dict begin
   /k2 exch def
   /B defpoint3d
   /k1 exch def
   /A defpoint3d
   A k1 mulv3d
   B k2 mulv3d
   addv3d
   1 k1 k2 add div mulv3d
end
} def

%% syntaxe : array isobarycentre3d --> G
/isobarycentre3d {
2 dict begin
   /table exch def
   /n table length 3 idiv def
   table 0 getp3d
   1 1 n 1 sub {
       table exch getp3d
       addv3d
   } for
   1 n div mulv3d
end
} def

%% syntaxe : M A alpha hompoint3d -> le point M' tel que AM' = alpha AM 
/hompoint3d {
3 dict begin
   /alpha exch def
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d alpha mulv3d A addv3d
end
} def

%% syntaxe : M A sympoint3d -> le point M' tel que AM' = -AM
/sympoint3d {
2 dict begin
   /A defpoint3d
   /M defpoint3d
   A M vecteur3d -1 mulv3d A addv3d
end
} def

%% syntaxe : A u translatepoint3d --> B image de A par la translation de vecteur u
/translatepoint3d {
   addv3d
} def

/scaleOpoint3d {
6 dict begin
   /k3 exch def
   /k2 exch def
   /k1 exch def
   /z exch def
   /y exch def
   /x exch def
   k1 x mul
   k2 y mul
   k3 z mul
end
} def

% syntaxe : M alpha_x alpha_y alpha_z rotateOpoint3d --> M'
/rotateOpoint3d {
21 dict begin
   /RotZ exch def
   /RotY exch def
   /RotX exch def
   /Zpoint exch def
   /Ypoint exch def
   /Xpoint exch def
   /c1 {RotX cos} bind def
   /c2 {RotY cos} bind def
   /c3 {RotZ cos} bind def
   /s1 {RotX sin} bind def
   /s2 {RotY sin} bind def
   /s3 {RotZ sin} bind def
   /M11 {c2 c3 mul} bind def
   /M12 {c3 s1 mul s2 mul c1 s3 mul sub} bind def
   /M13 {c1 c3 mul s2 mul s1 s3 mul add} bind def
   /M21 {c2 s3 mul} bind def
   /M22 {s1 s2 mul s3 mul c1 c3 mul add} bind def
   /M23 {s3 s2 mul c1 mul c3 s1 mul sub} bind def
   /M31 {s2 neg} bind def
   /M32 {s1 c2 mul} bind def
   /M33 {c1 c2 mul} bind def
   M11 Xpoint mul M12 Ypoint mul add M13 Zpoint mul add
   M21 Xpoint mul M22 Ypoint mul add M23 Zpoint mul add
   M31 Xpoint mul M32 Ypoint mul add M33 Zpoint mul add
end
} def

%%%%% ### symplan3d ###
%% syntaxe : M eqplan/plantype symplan3d --> M'
%% ou M' symetrique de M par rapport au plan P defini par eqplan/plantype
/symplan3d {
13 dict begin
   dup isplan {
      plan2eq /args exch def
   } {
      /args exch def
   } ifelse
   /z exch def
   /y exch def
   /x exch def
   args aload pop
   /d1 exch def
   /c1 exch def
   /b1 exch def
   /a1 exch def
   /n_U a1 dup mul b1 dup mul add c1 dup mul add sqrt def
   /a a1 n_U div def
   /b b1 n_U div def
   /c c1 n_U div def
   /d d1 n_U div def
   /u a x mul b y mul add c z mul add d add def
   x 2 a mul u mul sub
   y 2 b mul u mul sub
   z 2 c mul u mul sub
end
} def

%%%%% ### vecteur3d ###
%% creation du vecteur AB a partir de A et B
/vecteur3d { %% xA yA zA xB yB zB
6 dict begin
   /zB exch def
   /yB exch def
   /xB exch def
   /zA exch def
   /yA exch def
   /xA exch def
   xB xA sub
   yB yA sub
   zB zA sub
end
}def

%%%%% ### vectprod3d ###
%% produit vectoriel de deux vecteurs 3d
/vectprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub
end
} def

%%%%% ### scalprod3d ###
%% produit scalaire de deux vecteurs 3d
/scalprod3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp mul y yp mul add z zp mul add
end
} def

%%%%% ### papply3d ###
%% syntaxe : [A1 ... An] (f) papply3d --> [f(A1) ... f(An)]
/papply3d {
3 dict begin
   /fonction exch def
   /liste exch def
   /i 0 def
   [
   liste length 3 idiv {
      liste i get
      liste i 1 add get
      liste i 2 add get
      fonction
      /i i 3 add store
   } repeat
   counttomark
   0 eq
      {pop}
      {]}
   ifelse
end
} def

%%%%% ### defpoint3d ###
%% creation du point A a partir de xA yA yB et du nom /A
/defpoint3d { %% xA yA zA /nom
1 dict begin
   /memo exch def
   [ 4 1 roll ] cvx memo exch
end def
}def

%%%%% ### distance3d ###
/distance3d { %% A B
   vecteur3d norme3d
} def

%%%%% ### get3d ###
/getp3d { %% [tableau de points 3d] i --> donne le ieme point du tableau
   2 copy 2 copy
   3 mul get
   5 1 roll
   3 mul 1 add get
   3 1 roll
   3 mul 2 add get
} def

%%%%% ### norme3d ###
%% norme d un vecteur 3d
/norme3d { %% x y z
3 dict begin
   /z exch def
   /y exch def
   /x exch def
   x dup mul y dup mul add z dup mul add sqrt
end
} def

%%%%% ### mulv3d ###
%% (scalaire)*(vecteur 3d) Attention : dans l autre sens !
/mulv3d { %% x y z lambda
4 dict begin
   /lambda exch def
   /z exch def
   /y exch def
   /x exch def
   x lambda mul
   y lambda mul
   z lambda mul
end
} def

%%%%% ### addv3d ###
%% addition de deux vecteurs 3d
/addv3d { %% x1 y1 z1 x2 y2 z2
6 dict begin
   /zp exch def
   /yp exch def
   /xp exch def
   /z exch def
   /y exch def
   /x exch def
   x xp add
   y yp add
   z zp add
end
} def

%%%%% ### milieu3d ###
/milieu3d { %% A B --> I le milieu de [AB]
   addv3d 0.5 mulv3d
} def

%%%%% ### exch ###
/exchp {
   4 -1 roll
   4 -1 roll
} def
/exchc {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def
/exchd {
   4 {8 -1 roll} repeat
} def
/exchp3d {
   6 -1 roll
   6 -1 roll
   6 -1 roll
} def

%%%%% ### ABpoint3d ###
%% syntaxe : A B k ABpoint3d --> M
%% M tel que vect(AM) = k vect (AB)
/ABpoint3d {
3 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   k mulv3d
   A addv3d 
end
} def

%%%%% ### angle3doriente ###
%% syntaxe : vect1 vect2 vect3 angle3d
%% vect3 est la normale au plan (vect1, vect2)
/angle3doriente {
4 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   /cosalpha vect1 vect2 scalprod3d def
   /sinalpha vect1 vect2 vectprod3d vect3 scalprod3d def
   sinalpha cosalpha atan
end
} def

%%%%% ### points3dalignes ###
%% syntaxe : A B C points3dalignes -> bool
/points3dalignes {
3 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d /u defpoint3d
   A C vecteur3d /v defpoint3d
   u v vectprod3d norme3d 1E-7 lt
end
} def

%% syntaxe : M A B point3dsursegment --> true si M in [AB], false sinon
/point3dsursegment {
3 dict begin
   /B defpoint3d
   /A defpoint3d
   /M defpoint3d
   M A B points3dalignes {
      M A vecteur3d
      M B vecteur3d
      scalprod3d 0 lt {
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          geometrie 3d (dessins)                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### point3d ###
/point3d { %% A
   3dto2d point
} def

/points3d { %% tableau de points3d
   tab3dto2d points
} def

%%%%% ### ligne3d ###
%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne
end
} def

%% [tableau de points3d] option --> trace la ligne brisee
/ligne3d_ { 
1 dict begin
   dup isstring
      {/option exch def}
   if
   tab3dto2d
   currentdict /option known
      {option}
   if
   ligne_
end
} def

%%%%% ### tab3dto2d ###
%% transforme un tableau de points 3d en tableau de points 2d
/tab3dto2d {
2 dict begin
   /T exch def
   /n T length def
   [ T aload pop
   n 1 sub -1 n 3 idiv 2 mul
   { 1 dict begin
   /i exch def
   3dto2d i 2 roll
   end } for ]
end
} def

%%%%% ### polygone3d ###
/polygone3d { %% tableau de points3d
   tab3dto2d polygone
} def

/polygone3d* { %% tableau de points3d
   tab3dto2d polygone*
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 gestion du texte                   %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### marks ###
/xmkstep 1 def          % les marques sur Ox
/xmarkstyle {dctext} def
/ymarkstyle {(-1 0) bltext} def
/setxmkstep {
   /xmkstep exch def
} def
/xmark {
   dup xtick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup dup truncate eq {
      cvi dup chaine cvs exch 
   } {
      dup chaine cvs exch 
   } ifelse
   Oy xmarkstyle
} def
/xmarks {
2 dict begin
   /n xmax xmax xmin sub 1000 div sub xmkstep div truncate cvi 
      xmkstep mul def                   % mark max
   /i xmin xmkstep div truncate cvi 
      xmkstep mul def                   % la 1ere
   i xmin lt {/i i xmkstep add store} if
   {
      i 0 ne {i xmark} if
      /i i xmkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/ymkstep 1 def          % les marques sur Oy
/setymkstep {
   /ymkstep exch def
} def
/ymark {
   dup ytick
   /Courier findfont .8 fontsize mul scalefont setfont
   dup chaine cvs exch 
   Ox exch ymarkstyle
} def
/ymarks {
2 dict begin
   /n ymax ymax ymin sub 1000 div sub ymkstep div truncate cvi 
      ymkstep mul def                   % mark max
   /i ymin ymkstep div truncate cvi 
      ymkstep mul def                   % la 1ere
   {
      i 0 ne {i ymark} if
      /i i ymkstep abs add store
      i n gt {exit} if
   } loop 
end
} def

/setmkstep {
   setymkstep
   setxmkstep
} def
/marks {
   xmarks
   ymarks
} def

%%%%% ### setfontsize ###
/setfontsize {
   /fontsize exch def
} def

%%%%% ### setCourrier ###
/Courier findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end

/Courier-ISOLatin1 exch definefont pop

/setCourier {
   /Courier-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

%%%%% ### pathtext ###
%% syntaxe : string x y initp@thtext
 /initp@thtext {
7 dict begin
   /y exch def
   /x exch def
   /str exch def
   str 0 0 show_dim
   /wy exch def
   /wx exch def
   /lly exch def
   /llx exch def
   pop pop pop
   newpath 
      x y  smoveto
} def
 /closep@thtext {
      str true charpath
end
} def

%% syntaxe : string x y cctext_
/cctext_ {
   initp@thtext
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

/brtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg 0 rmoveto
   closep@thtext
} def

/bbtext_ {
   initp@thtext
   0 0 rmoveto
   0 0 rmoveto
   closep@thtext
} def

/bltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg 0 rmoveto
   closep@thtext
} def

/bctext_ {
   initp@thtext
   0 0 rmoveto
   wx llx add -.5 mul 0 rmoveto
   closep@thtext
} def

/ubtext_ {
   initp@thtext
   0 vadjust rmoveto
   0 lly neg rmoveto
   closep@thtext
} def

/urtext_ {
   initp@thtext
   hadjust vadjust rmoveto
   llx neg lly neg rmoveto
   closep@thtext
} def

/ultext_ {
   initp@thtext
   hadjust neg vadjust rmoveto
   wx neg lly neg rmoveto
   closep@thtext
} def

/uctext_ {
   initp@thtext
   0 vadjust rmoveto
   llx wx add -.5 mul lly neg rmoveto
   closep@thtext
} def

/drtext_ {
   initp@thtext
   hadjust vadjust neg rmoveto
   llx neg wy neg rmoveto
   closep@thtext
} def

/dbtext_ {
   initp@thtext
   0 vadjust neg rmoveto
   0 wy neg rmoveto
   closep@thtext
} def

/dltext_ {
   initp@thtext
   hadjust neg vadjust neg rmoveto
   wx neg wy neg rmoveto
   closep@thtext
} def

/dctext_ {
   initp@thtext
   0 vadjust neg rmoveto
   llx wx add -2 div wy neg rmoveto
   closep@thtext
} def

/crtext_ {
   initp@thtext
   hadjust 0 rmoveto
   llx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cbtext_ {
   initp@thtext
   0 0 rmoveto
   0 lly wy add -2 div rmoveto
   closep@thtext
} def

/cltext_ {
   initp@thtext
   hadjust neg 0 rmoveto
   wx neg lly wy add -2 div rmoveto
   closep@thtext
} def

/cctext_ {
   initp@thtext
   0 0 rmoveto
   llx wx add lly wy add -.5 mulv rmoveto
   closep@thtext
} def

%%%%% ### text3d ###
%%%% Version 3d des commandes jps TEXTE
 /pr@p@re3d {
2 dict begin
%   /vect_echelle [1 1] def
%   /angle_de_rot {0} def
%   dup xcheck
%      {/angle_de_rot exch def}
%   if
%   dup isarray
%      {/vect_echelle exch def}
%   if%   CamView vect_echelle {angle_de_rot}
   3dto2d
} def

/bbtext3d {
   pr@p@re3d
   bbtext
end
} def

/bbtexlabel3d {
   pr@p@re3d
   bbtexlabel
end
} def

/bctext3d {
   pr@p@re3d
   bctext
end
} def

/bctexlabel3d {
   pr@p@re3d
   bctexlabel
end
} def

/bltext3d {
   pr@p@re3d
   bltext
end
} def

/bltexlabel3d {
   pr@p@re3d
   bltexlabel
end
} def

/brtext3d {
   pr@p@re3d
   brtext
end
} def

/brtexlabel3d {
   pr@p@re3d
   brtexlabel
end
} def

/cbtext3d {
   pr@p@re3d
   cbtext
end
} def

/cbtexlabel3d {
   pr@p@re3d
   cbtexlabel
end
} def

/cctext3d {
   pr@p@re3d
   cctext
end
} def

/cctexlabel3d {
   pr@p@re3d
   cctexlabel
end
} def

/cltext3d {
   pr@p@re3d
   cltext
end
} def

/cltexlabel3d {
   pr@p@re3d
   cltexlabel
end
} def

/crtext3d {
   pr@p@re3d
   crtext
end
} def

/crtexlabel3d {
   pr@p@re3d
   crtexlabel
end
} def

/dbtext3d {
   pr@p@re3d
   dbtext
end
} def

/dbtexlabel3d {
   pr@p@re3d
   dbtexlabel
end
} def

/dctext3d {
   pr@p@re3d
   dctext
end
} def

/dctexlabel3d {
   pr@p@re3d
   dctexlabel
end
} def

/dltext3d {
   pr@p@re3d
   dltext
end
} def

/dltexlabel3d {
   pr@p@re3d
   dltexlabel
end
} def

/drtext3d {
   pr@p@re3d
   drtext
end
} def

/drtexlabel3d {
   pr@p@re3d
   drtexlabel
end
} def

/ubtext3d {
   pr@p@re3d
   ubtext
end
} def

/ubtexlabel3d {
   pr@p@re3d
   ubtexlabel
end
} def

/uctext3d {
   pr@p@re3d
   uctext
end
} def

/uctexlabel3d {
   pr@p@re3d
   uctexlabel
end
} def

/ultext3d {
   pr@p@re3d
   ultext
end
} def

/ultexlabel3d {
   pr@p@re3d
   ultexlabel
end
} def

/urtext3d {
   pr@p@re3d
   urtext
end
} def

/urtexlabel3d {
   pr@p@re3d
   urtexlabel
end
} def

%%%%% ### fin insertion ###

%% La macro provisoire de developpement (27/01/2009)
%% syntaxe : solid table tablez --> -
/solidcolorz {
10 dict begin
   %% les hauteurs
   /tablez exch def
   %% les couleurs
   /usertable exch def
   /solid exch def
   %% a-t-on des couleurs nommees ?
   usertable 0 get isstring {
      %% oui, et autant que d etages
      usertable length 1 sub tablez length eq {
         /table usertable def
      } {
         %% oui, mais moins que d etages
	 %% ==> on definit les 2 premieres en RGB
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         /lacouleurdepart {
            gsave
               [a0 cvx exec] length 0 eq {
                  a0 cvx exec currentrgbcolor
               } {
                  a0 cvx exec
               } ifelse 
            grestore
         } def
         /lacouleurarrivee {
            gsave
               [a1 cvx exec] length 0 eq {
                  a1 cvx exec currentrgbcolor
               } {
                  a1 cvx exec
               } ifelse 
            grestore
         } def
         /usertable [lacouleurdepart lacouleurarrivee] def
      } ifelse
   } if
   usertable 0 get isnum {
      %% c est un degrade : nb de couleurs a definir
      /n tablez length 1 add def
%      
      usertable length 4 eq {
          /a0 usertable 0 get def
          /a1 usertable 1 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B usertable 2 get def
          /C usertable 3 get def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%      
      usertable length 6 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (setrgbcolor) def
      } if
%
      usertable length 7 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /a1 usertable 3 get def
          /b1 usertable 4 get def
          /c1 usertable 5 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
      } if
%   
      usertable length 8 eq {
          /a0 usertable 0 get def
          /b0 usertable 1 get def
          /c0 usertable 2 get def
          /d0 usertable 3 get def
          /a1 usertable 4 get def
          /b1 usertable 5 get def
          /c1 usertable 6 get def
          /d1 usertable 7 get def
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {b0 i b1 b0 sub mul n 1 sub div add} def
          /C {c0 i c1 c0 sub mul n 1 sub div add} def
          /D {d0 i d1 d0 sub mul n 1 sub div add} def
          /espacedecouleurs (setcmykcolor) def
      } if
%
      usertable length 2 eq {
         /a0 usertable 0 get def
         /a1 usertable 1 get def
         0 1 n 1 sub {
            /i exch def
            /A {a0 i a1 a0 sub mul n 1 sub div add} def
            /B {1} def
            /C {1} def
            /D {} def
            /espacedecouleurs (sethsbcolor) def
         } for
      } if
%
      %% on affecte la table des couleurs
      /table [
         0 1 n 1 sub {
            /i exch def
            [A B C D] espacedecouleurs astr2str
         } for
      ] def
   } if
%
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /z exch def pop pop
      /resultat 0 def
      0 1 tablez length 1 sub {
         /j exch def
         /ztest tablez j get def
         z ztest le {
	    /resultat j store
            exit
         } {
	    /resultat j 1 add store
	 } ifelse
      } for
      solid i table resultat get solidputfcolor
   } for
end
} def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             bibliotheque sur les solides           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solide ###
%% solid = [Sommets Faces Colors_Faces InOut_Table]
/solidgetsommets {
   0 get
} def
/solidgetpointstable {solidgetsommets} def

/solidgetfaces {
   1 get
} def

/solidgetface {
1 dict begin
   /i exch def
   solidgetfaces i get
end
} def

/solidgetfcolors {
   2 get
} def

%% syntaxe : solid i solidgetfcolor --> str
/solidgetfcolor {
1 dict begin
   /i exch def
   solidgetfcolors i get
end
} def

%% syntaxe : solid i str solidputfcolor --> -
/solidputfcolor {
2 dict begin
   /str exch def
   /i exch def
   solidgetfcolors i str put
end
} def

/solidgetinouttable {
   3 get
} def

/solidputsommets {
   0 exch put
} def
/solidputpointstable {solidputsommets} def

/solidputfaces {
   1 exch put
} def

%% syntaxe : solid solidfacesreverse -> -
/solidfacesreverse {
5 dict begin
   /solid exch def
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      /F solid i solidgetface reverse def
      /m F length def
      solid i [F aload pop m 0 roll ] solidputface
   } for
end
} def

/solidputfcolors {
   2 exch put
} def

/solidputinouttable {
   3 exch put
} def

%% syntaxe : any issolid --> booleen, vrai si any est de type solid
/issolid {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 4 eq {
         candidat 0 get isarray
         candidat 1 get isarray and
         candidat 2 get isarray and
         candidat 3 get isarray and {
            /IO candidat 3 get def
            IO length 4 eq 
            IO 0 get isnum and
            IO 1 get isnum and
            IO 2 get isnum and
            IO 3 get isnum and
	 } {
	    false
	 } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/dupsolid {
5 dict begin
   /solid exch def
   /S solid solidgetsommets def
   /F solid solidgetfaces def
   /FC solid solidgetfcolors def
   /IO solid solidgetinouttable def
   solid
   [
      S duparray exch pop
      F duparray exch pop
      FC duparray exch pop
      IO duparray exch pop
   ]
end
} def

%% syntaxe : solid array solidputinfaces --> -
/solidputinfaces {
4 dict begin
   /facesinternes exch def
   /solid exch def
   /n2 facesinternes length def
   /IO solid solidgetinouttable def
   /facesexternes solid solidgetoutfaces def
   /n1 facesexternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

%% syntaxe : solid array solidputoutfaces --> -
/solidputoutfaces {
4 dict begin
   /facesexternes exch def
   /solid exch def
   /n1 facesexternes length def
   /IO solid solidgetinouttable def
   /facesinternes solid solidgetinfaces def
   /n2 facesinternes length def
   solid
      [facesexternes aload pop facesinternes aload pop]
      solidputfaces
   IO 0 0 put
   IO 1 n1 1 sub put
   IO 2 n1 put
   IO 3 n1 n2 add 1 sub put
end
} def

/solidnombreinfaces {
1 dict begin
   /solid exch def
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get IO 2 get sub 1 add
   } {
      0
   } ifelse
end
} def

/solidnombreoutfaces {
1 dict begin
   /solid exch def
   /IO solid solidgetinouttable def
   IO 1 get IO 0 get sub 1 add
end
} def

%% syntaxe : solid solidgetinfaces --> array
/solidgetinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      /F solid solidgetfaces def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      F n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutfaces --> array
/solidgetoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutfaces) ==
      quit
   } if
   /IO solid solidgetinouttable def
   /F solid solidgetfaces def
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   F n1 n getinterval
end
} def

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def

/solidgridOn {
   /solidgrid true def
} def
/solidgridOff {
   /solidgrid false def
} def

%% syntaxe : solid i string solidputfcolor
%% syntaxe : solid str outputcolors
%% syntaxe : solid str1 str2 inoutputcolors
%% syntaxe : solid string n solidputncolors
%% syntaxe : solid array solidputincolors --> -
%% syntaxe : solid array solidputoutcolors --> -
%% syntaxe : solid solidgetincolors --> array
%% syntaxe : solid solidgetoutcolors --> array

%% syntaxe : solid array solidputinfaces --> -
%% syntaxe : solid array solidputoutfaces --> -
%% syntaxe : solid solidgetinfaces --> array
%% syntaxe : solid solidgetoutfaces --> array

%% syntaxe : solid1 solid2 solidfuz -> solid

%% syntaxe : solid i solidgetsommetsface -> array
%% array = tableau de points 3d
/solidgetsommetsface {
1 dict begin
   /i exch def
   /solid exch def
   /F solid i solidgetface def
   [
      0 1 F length 1 sub {
         /k exch def
         solid F k get solidgetsommet
      } for
   ]
end
} def

%% syntaxe : solid index table solidputface -> -
/solidputface {
1 dict begin
   /table exch def
   /i exch def
   solidgetfaces i table put
end
} def

%% syntaxe : solid table solidaddface -> -
%% syntaxe : solid table (couleur) solidaddface -> -
%% on ne se preoccupe pas des faces internes
/solidaddface {
6 dict begin
   dup isstring {
      /lac@uleur exch def
   } {
      /lac@uleur () def
   } ifelse
   /table exch def
   /solid exch def
   /IO solid solidgetinouttable def
   /n2 IO 1 get def
   /FC solid solidgetoutcolors def
   IO 1 n2 1 add put
   solid [ solid solidgetfaces aload pop table ] solidputfaces
   solid IO solidputinouttable
%   solid solidnombrefaces
    solid [
      FC aload pop lac@uleur
    ] solidputoutcolors
end
} def

/solidnombrefaces {
1 dict begin
   /solid exch def
   solid solidnombreinfaces
   solid solidnombreoutfaces
   add 
end
} def

%% syntaxe : solid M solidaddsommetexterne -> -
%% on ajoute le sommet sans se preoccuper de rien
/solidaddsommetexterne {
2 dict begin
   /M defpoint3d
   /solid exch def
   solid
   [ solid solidgetsommets aload pop M ]
   solidputsommets
end
} def

%% syntaxe : solid array solidaddsommets -> -
/solidaddsommets {
2 dict begin
   /table exch def
   /solid exch def
   /n table length 3 idiv def
   0 1 0 {
      /i exch def
      solid table i getp3d solidaddsommet pop
   } for
end
} def

%% syntaxe : solid M solidaddsommet -> k
%% on ajoute le sommet M. Si il est deja sur une arete,
%% on l incorpore a la face concernee 
%% s il est deja present, on ne le rajoute pas.
%% Renvoie l indice du sommet rajoute.
/solidaddsommet {
10 dict begin
   /M defpoint3d
   /solid exch def
   /nbf solid solidnombrefaces def
   /N solid solidnombresommets def
   /sortie -1 def
   %% le sommet est-il deja dans la structure
   0 1 N 1 sub {
      /i exch def
%%       (addsommet) ==
%%       solid i solidgetsommet == == == 
%%       M == == ==
%%       solid i solidgetsommet M eqp3d ==
   
%      solid i solidgetsommet M eqp3d {
      solid i solidgetsommet M distance3d 1e-5 le {
         %% oui => c est fini
         /sortie i store
      } if
   } for
   sortie 0 lt {
      %% non => on le rajoute
      /sortie N def
      solid M solidaddsommetexterne
      %% est il sur une arete deja codee
      0 1 nbf 1 sub {
         %% face d indice i
         /i exch def
         solid i solidgetface /F exch def
         /nbsf F length def
         0 1 nbsf 1 sub {
            /j exch def
            M
            solid j i solidgetsommetface 
            solid j 1 add nbsf mod i solidgetsommetface 
            point3dsursegment {
               %% il est sur l arete concernee
               solid i [
                  0 1 j {
                     /k exch def
                     F k get
                  } for
                  N
                  j 1 add nbsf mod dup 0 eq {
                     pop
                  } {
                     1 nbsf 1 sub {
                        /k exch def
                        F k get
                     } for
                  } ifelse
               ]  solidputface
               exit
            } if
         } for 
      } for
   } if
   sortie
end
} def

%%%%% ### solidrmsommet ###
%% syntaxe : solid i solidrmsommet -> -
/solidrmsommet {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidrmsommet) ==
      quit 
   } if
   solid i solidsommetsadjsommet length 0 gt {
      (Erreur : sommet non isole dans solidrmsommet) ==
      quit 
   } if

   %% on s occupe des sommets
   /n solid solidnombresommets def
   /S [
      0 1 n 1 sub {
         /j exch def
         j i ne {
            solid j solidgetsommet
         } if
      } for
   ] def
   solid S solidputsommets
   %% on s occupe des faces
   /n solid solidnombrefaces def
   /F [
      0 1 n 1 sub {
         %% face d indice j
         /j exch def
         /Fj solid j solidgetface def
         [0 1 Fj length 1 sub {
            %% sommet d indice k de la face Fj
            /k exch def
            Fj k get dup i gt {
               1 sub
            } if
         } for]
      } for
   ] def
   solid F solidputfaces
end
} def

%%%%% ### solidsommetsadjsommet ###
%% syntaxe : solid i solidsommetsadjsommet --> array
%% array est le tableau des indices des sommets adjacents au
%% sommet d indice i
/solidsommetsadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   solid no solidfacesadjsommet /facesadj exch def
   /sommetsadj [] def
   /nbadj facesadj length def
   0 1 nbadj 1 sub {
      /j exch def
      %% examen de la jieme face
      %/j 0 def
      /F solid facesadj j get solidgetface def
      /nbsommetsface F length def
      no F in {
         /index exch def
         /i1 F index 1 sub nbsommetsface modulo get def
         /i2 F index 1 add nbsommetsface mod get def
         %% si i1 n est pas deja note, on le rajoute
         i1 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i1 ] store
         } ifelse
         %% si i2 n est pas deja note, on le rajoute
         i2 sommetsadj in {
            pop
         } {
            /sommetsadj [ sommetsadj aload pop i2 ] store
         } ifelse
      } {
         (Error : bug dans solidsommetsadjsommet) ==
         quit
      } ifelse
   } for
   sommetsadj
end
} def

%%%%% ### solidfacesadjsommet ###
%% syntaxe : solid i solidfacesadjsommet --> array
%% array est le tableau des indices des faces adjacentes au
%% sommet d indice i
/solidfacesadjsommet {
6 dict begin
   /no exch def
   /solid exch def
   /n solid solidnombrefaces def
   /indicesfacesadj [] def
   0 1 n 1 sub {
      /j exch def
      /F solid j solidgetface def
      no F in {
         pop
         /indicesfacesadj [ indicesfacesadj aload pop j ] store
      } if
   } for
   indicesfacesadj
end
} def

%%%%% ### ordonnepoints3d ###
%% syntaxe : array1 M ordonnepoints3d --> array2
%% array1 = tableau de points 3d coplanaires (plan P)
%% M = point3d indiquant la direction de la normale a P
%% array2 = les indices des points de depart, ranges dans le 
%% sens trigo par rapport a la normale
/ordonnepoints3d {
5 dict begin
   /M defpoint3d
   /table exch def
   table isobarycentre3d /G defpoint3d
   %% calcul de la normale
   table 0 getp3d /ptref defpoint3d
   table 1 getp3d /A defpoint3d
   G ptref vecteur3d
   G A vecteur3d
   vectprod3d /vecteurnormal defpoint3d
   vecteurnormal G M vecteur3d scalprod3d 0 lt {
      vecteurnormal -1 mulv3d /vecteurnormal defpoint3d
   } if
   %% la table des angles
   table duparray exch pop
   {1 dict begin
      /M defpoint3d
      G ptref vecteur3d
      G M vecteur3d
      vecteurnormal angle3doriente
   end} papply3d
%   [0 1 table length 3 idiv 1 sub {} for]
%   exch
    doublebubblesort pop
end
} def

%%%%% ### fin insertion ###

%% /tracelignedeniveau? false def
%% /hauteurlignedeniveau 1 def
%% /couleurlignedeniveau {rouge} def
%% /linewidthlignedeniveau 4 def
%% 
%% /solidgrid true def
%% /aretescachees true def
%% /defaultsolidmode 2 def

%% syntaxe : alpha beta r h newpie --> solid
/newpie {
6 dict begin
   [[/resolution /nbetages] [8 1] [10 1] [12 1] [18 3] [36 5]] gestionsolidmode
   /h exch def
   /r exch def
   /beta exch def
   /alpha exch def
   [
      0 0
%      alpha cos r mul alpha sin r mul
      alpha beta {1 dict begin /t exch def t cos r mul t sin r mul end} CourbeR2+
   ] 0 h [nbetages] newprismedroit
end
} def

%%%%% ### newsolid ###
%% syntaxe : newsolid --> depose le solide nul sur la pile
/newsolid {
   [] [] generesolid
} def

%%%%% ### generesolid ###
/generesolid {
2 dict begin
   /F exch def
   /S exch def
   [S F [F length {()} repeat] [0 F length 1 sub -1 -1]]
end
} def

%%%%% ### nullsolid ###
%% syntaxe : solide nullsolid -> booleen, vrai si le solide est nul
/nullsolid {
1 dict begin
   /candidat exch def
   candidat issolid not {
      (Error type argument dans "nullsolid") ==
      quit
   } if
   candidat solidgetsommets length 0 eq {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidnombreoutfaces ###
/solidnombreoutfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreoutfaces) ==
      quit
   } if
   solid nullsolid {
      0
   } {
      /IO solid solidgetinouttable def
      IO 1 get
      IO 0 get sub
      1 add
   } ifelse
end
} def

%%%%% ### solidnombreinfaces ###
/solidnombreinfaces {
4 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidnombreinfaces) ==
      quit
   } if
   solid solidwithinfaces {
      /IO solid solidgetinouttable def
      IO 3 get
      IO 2 get sub
      1 add
   } {
      0
   } ifelse
end
} def

%%%%% ### solidtests ###
%% syntaxe : solid solidwithinfaces --> bool, true si le solide est vide
/solidwithinfaces {
2 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidwithinfaces) ==
      quit
   } if
   /table solid solidgetinouttable def
   table 2 get -1 ne {
      true
   } {
      false
   } ifelse
end
} def

%%%%% ### solidgetsommet ###
%% syntaxe : solid i j solidgetsommetface --> sommet i de la face j
/solidgetsommetface {
6 dict begin
   /j exch def
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /k table_faces j get i get def
   table_sommets k getp3d
end
} def

%% syntaxe : solid i solidgetsommetsface --> array, tableau des
%% sommets de la face i du solide
/solidgetsommetsface {
6 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetsface) ==
      quit
   } if
   /table_faces solid solidgetfaces def
   /table_sommets solid solidgetsommets def
   /table_indices table_faces i get def
   [
      0 1 table_indices length 1 sub {
         /j exch def
         table_sommets table_indices j get getp3d
      } for
   ]
end
} def

%% syntaxe : solid i solidgetsommet --> sommet i du solide
/solidgetsommet {
3 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommet) ==
      quit
   } if
   /table_sommets solid solidgetsommets def
   table_sommets i getp3d
end
} def

%%%%% ### solidcentreface ###
%% syntaxe : solid i solidcentreface --> M
/solidcentreface {
   solidgetsommetsface isobarycentre3d
} def

%%%%% ### solidnombre ###
/solidnombresommets {
   solidgetsommets length 3 idiv
} def

/solidfacenombresommets {
   solidgetface length
} def

/solidnombrefaces {
   solidgetfaces length
} def

%%%%% ### solidshowsommets ###
/solidshowsommets {
8 dict begin
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      sol i solidgetsommet point3d
   } for
end
} def

%%%%% ### solidnumsommets ###
/solidnumsep 15 def
/solidnumsommets {
8 dict begin
%   Font findfont 10 scalefont setfont
   dup issolid not {
      %% on a un argument
      /option exch def
   } if
   /sol exch def
   /n sol solidnombresommets def
   /m sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if
   /result [
      n {false} repeat
   ] def
   0 1 option length 1 sub {
      /k exch def
      option k get /i exch def       %% indice du sommet examine
      0 1 m 1 sub {
         /j exch def %% indice de la face examinee
         i sol j solidgetface in {
            %% le sommet i est dans la face j
            pop
            exit
         } if
      } for
      sol i solidgetsommet /S defpoint3d
      i (   ) cvs
      m 0 ne {
         %% le sommet i est dans la face j
         sol j solidcentreface /G defpoint3d
         G S vecteur3d normalize3d
         solidnumsep dup ptojpoint pop
         mulv3d
         S addv3d
         3dto2d cctext 
      } {
         S 3dto2d uctext
      } ifelse
   } for
end
} def

%%%%% ### gestionsolidmode ###
%% table = [ [vars] [mode0] [mode1] [mode2] [mode3] [mode4] ]
/gestionsolidmode {
5 dict begin
   /table exch def
   dup xcheck {
      /mode exch def
   } {
      dup isarray {
         /tableaffectation exch def
         /mode -1 def
      } {
         /mode defaultsolidmode def
      } ifelse
   } ifelse
   /vars table 0 get def
   /nbvars vars length def
   mode 0 ge {
      /tableaffectation table mode 1 add 5 min get def
   } if
   0 1 nbvars 1 sub {
      /i exch def
      vars i get
      tableaffectation i get
   } for
   nbvars 
end
   {def} repeat
} def

%%%%% ### solidfuz ###
%% syntaxe : solid1 solid2 solidfuz -> solid
/solidfuz {
5 dict begin
   /solid2 exch def
   /solid1 exch def
   /S1 solid1 solidgetsommets def
   /S2 solid2 solidgetsommets def
   /n S1 length 3 idiv def

   %% les sommets
   /S S1 S2 append def

   %% les faces internes et leurs couleurs
   /FI1 solid1 solidgetinfaces def
   /FIC1 solid1 solidgetincolors def
   solid2 solidnombreinfaces 0 eq {
      /FI2 [] def
      /FIC2 [] def
   } {
      /FI2 solid2 solidgetinfaces {{n add} apply} apply def
      /FIC2 solid2 solidgetincolors def
   } ifelse
   /FI [FI1 aload pop FI2 aload pop] def
   /FIC [FIC1 aload pop FIC2 aload pop] def

   %% les faces externes et leurs couleurs
   /FO1 solid1 solidgetoutfaces def
   /FOC1 solid1 solidgetoutcolors def
   /FO2 solid2 solidgetoutfaces {{n add} apply} apply def
   /FOC2 solid2 solidgetoutcolors def
   /FO [FO1 aload pop FO2 aload pop] def
   /FOC [FOC1 aload pop FOC2 aload pop] def

   /F [FO aload pop FI aload pop] def
   /FC [FOC aload pop FIC aload pop] def
   /IO [
      0 FO length 1 sub
      FI length 0 gt {
         dup 1 add dup FI length add 1 sub
      } {
         -1 -1
      } ifelse
   ] def

   S F generesolid
   dup FC solidputfcolors
   dup IO solidputinouttable
end
} def

%%%%% ### solidnormaleface ###
%% syntaxe : solid i solidnormaleface --> u, vecteur normale a la
%% face d indice i du solide
/solidnormaleface {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
%%    solid 0 i solidgetsommetface /G defpoint3d
%%    G
%%    solid 1 i solidgetsommetface
%%    vecteur3d
%%    G
%%    solid 2 i solidgetsommetface
%%    vecteur3d
%
   /n solid i solidfacenombresommets def
   n 3 ge {
      [
         solid 0 i solidgetsommetface
         solid 1 i solidgetsommetface
         solid 2 i solidgetsommetface
      ] isobarycentre3d /G defpoint3d
   } {
      solid i solidcentreface /G defpoint3d
   } ifelse
  %% debug %%   G 3dto2d point
   G
   solid 0 i solidgetsommetface
   /A defpoint3d
  %   gsave bleu A point3d grestore
   A
   vecteur3d normalize3d
   G
   solid 1 i solidgetsommetface
   /A defpoint3d
  %   gsave orange A point3d grestore
   A
   vecteur3d normalize3d
   vectprod3d
   /resultat defpoint3d
   resultat normalize3d
end
} def

%%%%% ### solidtransform ###
%% syntaxe : solid1 {f} solidtransform --> solid2, solid2 est le
%% transforme de solid1 par la transformation f : R^3 -> R^3
/solidtransform {
3 dict begin
   /@f exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidtransform) ==
      quit
   } if
   /les_sommets
      solid solidgetsommets {@f} papply3d
   def
   solid les_sommets solidputsommets
   solid
end
} def

%%%%% ### solidputcolor ###
%% syntaxe : solid i string solidputfcolor
/solidputfcolor {
3 dict begin
   /str exch def
   /i exch def
   /solid exch def
   /FC solid solidgetfcolors def
   i FC length lt {
      FC i str put
   } if
end
} def

%% syntaxe : solid solidgetincolors --> array
/solidgetincolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetincolors) ==
      quit
   } if
   solid solidwithinfaces {
      /fcol solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      /n2 IO 3 get def
      /n n2 n1 sub 1 add def
      fcol n1 n getinterval
   } {
      []
   } ifelse
end
} def

%% syntaxe : solid solidgetoutcolors --> array
/solidgetoutcolors {
3 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetoutcolors) ==
      quit
   } if
   /fcol solid solidgetfcolors def
   /IO solid solidgetinouttable def 
   /n1 IO 0 get def
   /n2 IO 1 get def
   /n n2 n1 sub 1 add def
   fcol n1 n getinterval 
end
} def
 
%% syntaxe : solid array solidputincolors --> -
/solidputincolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputincolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreinfaces ne {
      (Error : mauvaise longueur de tableau dans solidputincolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 2 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC n1 newcolorstable putinterval
   } if
end
} def

%% syntaxe : solid str outputcolors
/outputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreoutfaces def
   solid [ n {color} repeat ] solidputoutcolors
end
} def

%% syntaxe : solid str inputcolors
/inputcolors {
5 dict begin
   /color exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans inoutputcolors) ==
      quit
   } if
   /n solid solidnombreinfaces def
   solid [ n {color} repeat ] solidputincolors
end
} def

%% syntaxe : solid str1 str2 inoutputcolors
/inoutputcolors {
5 dict begin
   /colout exch def
   /colin exch def
   /solid exch def
   solid colin inputcolors
   solid colout outputcolors
end
} def

%% syntaxe : solid array solidputoutcolors --> -
/solidputoutcolors {
4 dict begin
   /newcolorstable exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidputoutcolors) ==
      quit
   } if
   /n newcolorstable length def
   n solid solidnombreoutfaces ne {
      (Error : mauvaise longueur de tableau dans solidputoutcolors) ==
      quit
   } if
   n 0 ne {
      /FC solid solidgetfcolors def
      /IO solid solidgetinouttable def
      /n1 IO 0 get def
      FC length n n1 add lt {
         solid newcolorstable solidputfcolors
      } {
         FC n1 newcolorstable putinterval
      } ifelse
   } if
end
} def

/solidputcolors {
3 dict begin
   2 copy pop
   isstring {
      inoutputcolors
   } {
      outputcolors
   } ifelse
end
} def

%%%%% ### solidputhuecolors ###
%% syntaxe : solid table solidputhuecolors --> -
/solidputhuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 1 get
   s@lidputhuec@l@rs
end
} def

/solidputinhuecolors {
2 dict begin
   /table exch def
   /solid exch def
   solid solidgetinouttable /IO exch def
   solid solidwithinfaces {
      solid table
      IO 2 get
      IO 3 get
      s@lidputhuec@l@rs
   } if
end
} def

/solidputinouthuecolors {
1 dict begin
   2 copy pop
   solidgetinouttable /IO exch def
   IO 0 get
   IO 3 get IO 1 get max
   s@lidputhuec@l@rs
end
} def

%% syntaxe : solid table n1 n2 s@lidputhuec@l@rs --> -
%% affecte les couleurs des faces d indice n1 a n2 du solid solid, par
%% un degrade defini par la table.
 /s@lidputhuec@l@rs {
9 dict begin
   /n2 exch def
   /n1 exch def
   /table exch def
   /solid exch def
   /n n2 n1 sub def

   table length 2 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       a1 isstring {
          /lacouleurdepart {
             gsave
                [a0 cvx exec] length 0 eq {
                   a0 cvx exec currentrgbcolor
                } {
                   a0 cvx exec
                } ifelse 
             grestore
          } def
          /lacouleurarrivee {
             gsave
                [a1 cvx exec] length 0 eq {
                   a1 cvx exec currentrgbcolor
                } {
                   a1 cvx exec
                } ifelse 
             grestore
          } def
          /table [lacouleurdepart lacouleurarrivee] def
       } {
          /A {a0 i a1 a0 sub mul n 1 sub div add} def
          /B {1} def
          /C {1} def
          /D {} def
          /espacedecouleurs (sethsbcolor) def
       } ifelse
   } if

   table length 4 eq {
       /a0 table 0 get def
       /a1 table 1 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B table 2 get def
       /C table 3 get def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 6 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (setrgbcolor) def
   } if

   table length 7 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /a1 table 3 get def
       /b1 table 4 get def
       /c1 table 5 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {} def
       /espacedecouleurs (sethsbcolor) def
   } if

   table length 8 eq {
       /a0 table 0 get def
       /b0 table 1 get def
       /c0 table 2 get def
       /d0 table 3 get def
       /a1 table 4 get def
       /b1 table 5 get def
       /c1 table 6 get def
       /d1 table 7 get def
       /A {a0 i a1 a0 sub mul n 1 sub div add} def
       /B {b0 i b1 b0 sub mul n 1 sub div add} def
       /C {c0 i c1 c0 sub mul n 1 sub div add} def
       /D {d0 i d1 d0 sub mul n 1 sub div add} def
       /espacedecouleurs (setcmykcolor) def
   } if

   n1 1 n2 {
      /i exch def
      solid i
      [A B C D] espacedecouleurs astr2str
      solidputfcolor
   } for
   
end
} def

%%%%% ### solidrmface ###
%% syntaxe : solid i solidrmface -> -
/solidrmface {
5 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidrmface) ==
      quit
   } if
   %% on enleve la face
   /F solid solidgetfaces def
   F length 1 sub i lt {
      (Error : indice trop grand dans solidrmface) ==
      quit
   } if
   [
      0 1 F length 1 sub {
         /j exch def
         i j ne {
            F j get
         } if
      } for
   ]
   /NF exch def
   solid NF solidputfaces
   %% on enleve la couleur correspondante
   /FC solid solidgetfcolors def
   [
      0 1 FC length 1 sub {
         /j exch def
         i j ne {
            FC j get
         } if
      } for
   ]
   /NFC exch def
   solid NFC solidputfcolors
   %% on ajuste la table inout
   /IO solid solidgetinouttable def
   solid i solidisoutface {
      IO 1 IO 1 get 1 sub put 
      solid solidwithinfaces {
         IO 2 IO 2 get 1 sub put
         IO 3 IO 3 get 1 sub put
      } if
   } if
   solid i solidisinface {
      IO 1 IO 1 get 1 sub put
      IO 2 IO 2 get 1 sub put
      IO 3 IO 3 get 1 sub put
   } if
   solid IO solidputinouttable
end
} def

%% syntaxe : solid table solidrmfaces --> -
/solidrmfaces {
2 dict begin
   /table exch bubblesort reverse def
   /solid exch def
   table {solid exch solidrmface} apply
end
} def

%%%%% ### videsolid ###
%% syntaxe : solid videsolid -> -
/videsolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans videsolid) ==
      quit
   } if
   solid solidwithinfaces not {
      /IO solid solidgetinouttable def
      /FE solid solidgetfaces def
      /n FE length def
      IO 2 n put
      IO 3 2 n mul 1 sub put
      solid IO solidputinouttable
      %% on inverse chaque face
      /FI FE {reverse} apply def
      solid FE FI append solidputfaces
      %% et on rajoute autant de couleurs vides que de faces
      /FEC solid solidgetfcolors def
%      /FIC [FI length {()} repeat] def
%      solid FEC FIC append solidputfcolors
      solid FEC duparray append solidputfcolors
   } if 
end
} def

%%%%% ### solidnumfaces ###
%% syntaxe : solid array solidnumfaces
%% syntaxe : solid array bool solidnumfaces
%% array, le tableau des indices des faces a numeroter, est optionnel
%% si bool=true, on ne numerote que les faces visibles
/solidnumfaces {
5 dict begin
   dup isbool {
      /bool exch def
   } {
      /bool true def
   } ifelse
%   setTimes
   dup issolid not {
      %% on a un argument
      /option exch def 
   } if
   /sol exch def
   /n sol solidnombrefaces def
   currentdict /option known not {
      /option [0 1 n 1 sub {} for] def
   } if

   0 1 option length 1 sub {
      /i exch def
      /j option i get def
      j (     ) cvs sol j bool cctextp3d
   } for
end
} def

%%%%% ### creusesolid ###
%% syntaxe : solid creusesolid -> -
/creusesolid {
5 dict begin
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans creusesolid) ==
      quit
   } if
   %% on enleve le fond et le chapeau
   solid 1 solidrmface
   solid 0 solidrmface
   %% on inverse chaque face
   solid videsolid
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                 dessin des solides                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### solidisinface ###
%% syntaxe : solid i solidisinface --> bool
%% true si i est l indice d une face interne, false sinon
/solidisinface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 2 get def
   /n2 IO 3 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### solidisoutface ###
%% syntaxe : solid i solidisoutface --> bool
%% true si i est l indice d une face externe, false sinon
/solidisoutface {
4 dict begin
   /i exch def
   solidgetinouttable /IO exch def
   /n1 IO 0 get def
   /n2 IO 1 get def
   n1 i le 
   i n2 le and
end
} def

%%%%% ### planvisible ###
%% syntaxe : A k planvisible? --> true si le plan est visible
/planvisible? {
4 dict begin
   /normale_plan defpoint3d
   /origine defpoint3d
   /ligne_de_vue {
      origine
      GetCamPos
      vecteur3d
   } def
   ligne_de_vue normale_plan scalprod3d 0 gt
end
} def

%%%%% ### solidlight ###
/setlightintensity {
   /lightintensity exch def
} def

/setlightsrc {
   /lightsrc defpoint3d
} def

/setlight {
1 dict begin
gsave
   exec
   [ currentrgbcolor ] /lightcolor exch 
grestore
end
def
} def

%%%%% ### drawsolid ###
/solidlightOn {
   /s@lidlight true def
} def
/solidlightOff {
   /s@lidlight false def
} def
solidlightOff

%% syntaxe : solid i solidfacevisible? --> true si la face est visible
/solidfacevisible? {
4 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans solidgetsommetface) ==
      quit
   } if
   solid i solidgetface length 2 le {
      true
   } {
      /ligne_de_vue {
         solid i solidcentreface
         GetCamPos
         vecteur3d
      } def
   
      /normale_face {
         solid i solidnormaleface
      } def
      ligne_de_vue normale_face scalprod3d 0 gt
   } ifelse
end
} def

%% syntaxe : solid i affectecouleursolid_facei --> si la couleur de
%% la face i est definie, affecte fillstyle a cette couleur
/affectecouleursolid_facei {
3 dict begin
   /i exch def
   /solid exch def
   solid solidgetfcolors /FC exch def
   FC length 1 sub i ge {
      FC i get length 1 ge {
         /fillstyle FC i get ( Fill) append cvx
         solidgrid not {
            FC i get cvx exec
         } if
         true
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
{def} if
} def

%% syntaxe : solid i dessinefacecachee
/dessinefacecachee {
11 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacecachee) ==
      quit
   } if

   /F solid solidgetfaces def
   /S solid solidgetsommets def

   %% face cachee => on prend chacune des aretes de la face et on
   %% la dessine
   4 dict begin
      /n F i get length def %% nb de sommets de la face
      0 1 n 1 sub {
         /k exch def
         /k1 F i k get_ij def              %% indice sommet1
         /k2 F i k 1 add n mod get_ij def  %% indice sommet2
         gsave
            currentlinewidth .5 mul setlinewidth
            pointilles
            [S k1 getp3d
            S k2 getp3d sortp3d] ligne3d
         grestore
      } for

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      /face_a_dessiner [  %% face visible : F [i]
         0 1 n 1 sub {
            /j exch def
            solid j i solidgetsommetface
         } for
      ] def 
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
	    solidintersectiontype 0 eq {
	       pointilles
	    } {
	       continu
	    } ifelse
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  table length 6 eq {
                     /lignedeniveau table store
                     exit
                  } {
                     /lignedeniveau [ 
                        lignedeniveau aload pop 
                        table 0 getp3d
                     ] store
                  } ifelse
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               [lignedeniveau aload pop sortp3d] ligne3d
            } if
         grestore
      } for         
   } if
   
   end
end
} def

%% syntaxe : solid i dessinefacevisible
/dessinefacevisible {
8 dict begin
   /i exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans dessinefacevisible) ==
      quit
   } if
   /F solid solidgetfaces def
   /S solid solidgetsommets def

   /n F i get length def %% nb de sommets de la face

   startest {
      s@lidlight {
         /coeff
            lightintensity
            solid i solidnormaleface normalize3d
            solid i solidcentreface lightsrc vecteur3d normalize3d
            scalprod3d mul
            0 max 1 min
         def
         /lightcolor where {
            pop
            /lacouleur lightcolor def
         } {
            /lacouleur [
               gsave
                  solid solidgetfcolors i get cvx exec currentrgbcolor
               grestore
            ] def
         } ifelse
         /fillstyle {
             lacouleur {coeff mul} apply setcolor Fill
         } def
         solidgrid not {
            lacouleur {coeff mul} apply setcolor
         } if
      } {
         n 2 eq {
            1 dict begin
               solidgridOff
               solid i affectecouleursolid_facei
            end
         } {
            solid i affectecouleursolid_facei
         } ifelse
      } ifelse
   } if

   /face_a_dessiner [  %% face visible : F [i]
      0 1 n 1 sub {
         /j exch def
         solid j i solidgetsommetface
      } for
   ] def 
   face_a_dessiner polygone3d

   %% trace de la ligne de niveau
   solidintersectiontype 0 ge {
      0 1 solidintersectionplan length 1 sub {
         /k exch def
         /lignedeniveau [] def
         gsave
            k solidintersectionlinewidth length lt {
               solidintersectionlinewidth k get setlinewidth
            } {
               solidintersectionlinewidth 0 get setlinewidth
            } ifelse
            k solidintersectioncolor length lt {
               solidintersectioncolor k get cvx exec
            } {
               solidintersectioncolor 0 get cvx exec
            } ifelse
            0 1 n 1 sub {
               /j exch def
               face_a_dessiner j getp3d
               face_a_dessiner j 1 add n mod getp3d
               solidintersectionplan k get
               dup isarray {
                  segment_inter_plan
               } {
                  segment_inter_planz
               } ifelse {
               1 dict begin
                  /table exch def
                  /lignedeniveau [ 
                     lignedeniveau aload pop 
                     table 0 getp3d
                     table length 4 ge {
                        table 1 getp3d
                     } if
                  ] store
               end
               } if
            } for
            
            %% dessin de la ligne
            lignedeniveau length 4 ge {
               solid i solidisinface solidintersectiontype 0 eq and {
                  pointilles 
               } if
               lignedeniveau ligne3d
            } if
         grestore
      } for         
   } if
      
end
} def

/drawsolid* {
1 dict begin
   /startest {true} def
   drawsolid
end
} def

/peintrealgorithme false def

/drawsolid** {
2 dict begin
   /aretescachees false def
   /peintrealgorithme true def
   drawsolid*
end
} def

%% syntaxe : solid array drawsolid
%% array est en option, il indique les faces triees
/drawsolid {
8 dict begin
   dup issolid not {
      /ordre exch def
   } if
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans drawsolid) ==
      quit
   } if
   solid nullsolid not {
      solid solidgetfaces
      /F exch def
      solid solidgetsommets
      /S exch def
      /n S length 3 idiv def

      currentdict /ordre known not {
         peintrealgorithme {
            %% tri des indices des faces par distance decroissante
            [
               0 1 F length 1 sub {
                  /i exch def
                  solid i solidcentreface
                  GetCamPos
                  distance3d
               } for
            ] doublequicksort pop reverse
         } {
            [
               0 1 F length 1 sub {
               } for
            ]
         } ifelse
         /ordre exch def
      } if

      0 1 F length 1 sub {
         /k exch def
         /i ordre k get def
         gsave
            solid i solidfacevisible? {
               solid i dessinefacevisible
            } if
         grestore
      } for
      aretescachees {
         0 1 F length 1 sub {
            /k exch def
            /i ordre k get def
            gsave
               solid i solidfacevisible? not {
                  solid i dessinefacecachee
               } if 
            grestore
         } for
      } if

%%       %% si on veut repasser les traits des faces visibles
%%       0 1 F length 1 sub {
%%          /k exch def
%%          /i ordre k get def
%%          gsave
%%          1 dict begin
%%             /startest false def
%%             solid i solidfacevisible? {
%%             solid i dessinefacevisible
%%             } if
%%          end
%%          grestore
%%       } for
   } if
end
} def

%%%%% ### segment_inter_planz ###
%% syntaxe : A B k segment_inter_planz --> array true ou false
/segment_inter_planz {
4 dict begin
   /k exch def
   /B defpoint3d
   /A defpoint3d
   A /zA exch def pop pop
   B /zB exch def pop pop
   zA k sub zB k sub mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            zA k eq {A} if
            zB k eq {B} if
         ] true
      } {
         %% intersection entre A et B
         [
            A B vecteur3d
            k zA sub zB zA sub div mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                  plans affines                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### planaffine ###
%% plan : origine, base, range, ngrid
%% [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1. 1.] ]

/explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.] ] def

%% syntaxe : any isplan --> bool
/isplan {
1 dict begin
   /candidat exch def
   candidat isarray {
      candidat length 6 eq {
         candidat 3 get isarray {
            candidat 4 get isarray {
               candidat 5 get isarray              
            } {
               false
            } ifelse
         } {
            false
         } ifelse
      } {
         false
      } ifelse
   } {
      false
   } ifelse
end
} def

/newplanaffine {
   [0 0 0 [1 0 0 0 1 0] [-3 3 -2 2] [1 1]] 
} def

/dupplan {
4 dict begin
   /leplan exch def
   /result newplanaffine def
   result leplan plangetorigine planputorigine
   result leplan plangetbase planputbase
   result leplan plangetrange planputrange
   result leplan plangetngrid planputngrid
   result
end
} def

%% syntaxe : plantype getorigine --> x y z
/plangetorigine {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetorigine) ==
      Error
   } if
   plan 0 get 
   plan 1 get 
   plan 2 get 
end
} def

%% syntaxe : plantype getbase --> [u v]
%% ou u, v et w vecteurs de R^3
/plangetbase {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetbase) ==
      Error
   } if
   plan 3 get 
end
} def

%% syntaxe : plantype getrange --> array
%% ou array = [xmin xmax ymin ymax]
/plangetrange {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetrange) ==
      Error
   } if
   plan 4 get 
end
} def

%% syntaxe : plantype getngrid --> array
%% ou array = [n1 n2]
/plangetngrid {
1 dict begin
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plangetngrid) ==
      Error
   } if
   plan 5 get 
end
} def

%% ===================

%% syntaxe : plantype x y z putorigine --> -
/planputorigine {
4 dict begin
   /z exch def
   /y exch def
   /x exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputorigine) ==
      Error
   } if
   plan 0 x put 
   plan 1 y put 
   plan 2 z put 
end
} def

%% syntaxe : plantype [u v w] putbase --> -
%% ou u, v et w vecteurs de R^3
/planputbase {
2 dict begin
   /base exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputbase) ==
      Error
   } if
   plan 3 base put 
end
} def

%% syntaxe : plantype array putrange --> -
%% ou array = [xmin xmax ymin ymax]
/planputrange {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputrange) ==
      Error
   } if
   plan 4 table put 
end
} def

%% syntaxe : plantype array putngrid --> -
%% ou array = [n1 n2]
/planputngrid {
2 dict begin
   /table exch def
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans planputngrid) ==
      quit
   } if
   plan 5 table put 
end
} def

%% -3 3 -2 2 1. 1. newgrille
%% drawsolid

%orange

%% plan : origine, base, range, ngrid

%% syntaxe : plantype drawplanaffine --> -
/drawplanaffine {
5 dict begin
   /plan exch def
   plan plangetbase 
   aload pop
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   newpath
      plan plangetrange plan plangetngrid aload pop  quadrillagexOy_
      plan plangetorigine [imI imK] false planprojpath
   Stroke
end
} def


%% %% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% %% plan defini par l equation ax+by+cz+d=0, 
%% %% rotation de alpha autour de la normale (alpha est optionnel)
%% %% origine (x0, y0, z0). l origine est optionnelle
%% /defeqplanaffine {
%% 5 dict begin
%%    dup isarray {
%%       /alpha 0 def
%%    } {
%%       dup isstring {
%%          /alpha 0 def
%%       } {
%%          /alpha exch def
%%       } ifelse
%%    } ifelse
%%    dup isstring {
%%       cvx /origine exch def
%%    } if
%%    /table exch def
%%    table length 4 ne {
%%       (Erreur : mauvais type d argument dans defeqplanaffine) ==
%%       Error
%%    } if
%%    table 0 get /a exch def
%%    table 1 get /b exch def
%%    table 2 get /c exch def
%%    table 3 get /d exch def
%%    /resultat newplanaffine def
%%    [a b c alpha] normalvect_to_orthobase
%%    /imK defpoint3d
%%    /imJ defpoint3d
%%    /imI defpoint3d
%%    resultat [imI imJ imK] planputbase
%%    currentdict /origine known {
%%       origine /z exch def /y exch def /x exch def
%%       a x mul b y mul add c z mul add d add 0 ne {
%%          (Erreur : mauvaise origine dans defeqplanaffine) ==
%%          Error
%%       } if
%%       resultat origine planputorigine
%%    } {
%%       c 0 ne {
%%          resultat 0 0 d neg c div planputorigine
%%       } {
%%          a 0 ne {
%%             resultat d neg a div 0 0 planputorigine
%%          } {
%%             resultat 0 d neg b div 0 planputorigine
%%          } ifelse
%%       } ifelse
%%    } ifelse
%%    resultat
%% end
%% } def

%% /explan [0 0 0 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 1] ] def
%% explan drawplanaffine
%% noir
%% /explan [0 0 2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1 .5] ] def
%% explan drawplanaffine

%% orange
%% [0 0 1 -2] defeqplanaffine
%% drawplanaffine
%% noir
%% [0 0 1 0] defeqplanaffine
%% drawplanaffine
%% bleu
%% [1 1 1 0] (1 -1 0) defeqplanaffine
%% drawplanaffine
%% 

/dessinebase {
4 dict begin
gsave
   /V3 defpoint3d
   /V2 defpoint3d
   /V1 defpoint3d
   /M0 defpoint3d
   rouge
   V3 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   bleu
   V2 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
   orange
   V1 newvecteur 
   {M0 translatepoint3d} solidtransform
   drawsolid**
grestore
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def


%% syntaxe : plantype newplan --> solid
/newplan {
5 dict begin
   /lepl@n exch def
   lepl@n plangetbase /@base exch def
   @base 0 getp3d /@U defpoint3d
   @base 1 getp3d /@V defpoint3d
   lepl@n plangetorigine /@M defpoint3d
   lepl@n plangetrange /@range exch def
   lepl@n plangetngrid /@ngrid exch def
   /@F {
   2 dict begin
      /@y exch def
      /@x exch def
      @U @x mulv3d
      @V @y mulv3d
      addv3d
      @M addv3d
   end
   } def
   @range aload pop @ngrid {@F} newsurfaceparametree
end
} def

%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /eqplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a eqplan 0 get def
   /@b eqplan 1 get def
   /@c eqplan 2 get def
   /@d eqplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add
end
} def

/plan2eq {
6 dict begin
   /leplan exch def
   leplan plangetbase aload pop vectprod3d
   /c exch def
   /b exch def
   /a exch def
   leplan plangetorigine
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg]
end
} def

%% syntaxe : [a b c d] (x0 y0 z0) alpha defeqplanaffine --> plantype
%% plan defini par l equation ax+by+cz+d=0, 
%% rotation de alpha autour de la normale (alpha est optionnel)
%% origine (x0, y0, z0). l origine est optionnelle
/eq2plan {
5 dict begin
   dup isarray {
      /alpha 0 def
   } {
      dup isstring {
         /alpha 0 def
      } {
         /alpha exch def
      } ifelse
   } ifelse
   dup isstring {
      cvx /origine exch def
   } if
   /table exch def
   table length 4 ne {
      (Erreur : mauvais type d argument dans eq2plan) ==
      quit
   } if
   table 0 get /a exch def
   table 1 get /b exch def
   table 2 get /c exch def
   table 3 get /d exch def
   /resultat newplanaffine def
   [a b c alpha] normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   resultat [imI imJ] planputbase
   currentdict /origine known {
      origine /z exch def /y exch def /x exch def
      a x mul b y mul add c z mul add d add 0 ne {
         (Erreur : mauvaise origine dans eq2plan) ==
         quit
      } if
      resultat origine planputorigine
   } {
      c 0 ne {
         resultat 0 0 d neg c div planputorigine
      } {
         a 0 ne {
            resultat d neg a div 0 0 planputorigine
         } {
            b 0 ne {
               resultat 0 d neg b div 0 planputorigine
            } {
               (Error dans eq2plan : (a,b,c) = (0,0,0)) ==
            } ifelse
         } ifelse
      } ifelse
   } ifelse
   resultat
end
} def

/points2eqplan {
10 dict begin
   /C defpoint3d
   /B defpoint3d
   /A defpoint3d
   A B vecteur3d
   A C vecteur3d
   vectprod3d
   normalize3d
   /c exch def
   /b exch def
   /a exch def
   A
   /zA exch def
   /yA exch def
   /xA exch def
   [a b c a xA mul b yA mul add c zA mul add neg]
end
} def

%% /monplan 
%% %[0 0 -2 [1 0 0 0 1 0 0 0 1] [-3 3 -2 2] [1. 1.]]
%% [0 0 1 1] 30 eq2plan
%% def
%% 
%% [0 0 1 -2] eq2plan newplan
%% dup (blanc) outputcolors
%% monplan newplan
%% dup (blanc) outputcolors
%% solidfuz
%% drawsolid**
%% monplan plangetorigine
%% monplan plangetbase aload pop dessinebase

%% syntaxe : x0 y0 z0 [normalvect] norm2plan
/norm2plan {
9 dict begin
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d
   imK
   /c exch def
   /b exch def
   /a exch def
   /z0 exch def
   /y0 exch def
   /x0 exch def
   [a b c a x0 mul b y0 mul add c z0 mul add neg] eq2plan
   dup x0 y0 z0 planputorigine
   dup [imI imJ] planputbase
end
} def

%% syntaxe : plantype planxmarks
/planxmarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      xmin truncate cvi 0 smoveto
      xmax truncate cvi 0 slineto
      leplan mybool projpath
   Stroke
   xmin truncate cvi xmkstep xmax truncate cvi {
      dup 0 ne {
         /x exch def
         x
         x x truncate eq {
            cvi
         } if
         dup chaine cvs exch 0 leplan mybool dctextp3d
         newpath
            x 0 smoveto
            0 2.5 rmoveto
            0 -5 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planymarks
/planymarks {
5 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   /leplan exch def
   leplan plangetrange aload pop
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def
   newpath
      0 ymin truncate cvi smoveto
      0 ymax truncate cvi slineto
      leplan mybool projpath
   Stroke
   ymin truncate cvi ymkstep ymax truncate cvi {
      dup 0 ne {
         /y exch def
         y
         y y truncate eq {
             cvi
         } if
         dup chaine cvs exch 0 exch leplan mybool cltextp3d
         newpath
            0 y smoveto
            2.5 0 rmoveto
            -5 0 rlineto
            leplan mybool projpath
         Stroke
      } {
         pop (0) 0 0 leplan mybool dltextp3d 
      } ifelse
   } for
end
} def

%% syntaxe : plantype planmarks
/planmarks {
1 dict begin
    dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup mybool planxmarks mybool planymarks
end
} def

%% bleu
%% [-3 3 -2 2] quadrillagexOy_
%% Stroke
%% noir

%% syntaxe : [xmin xmax ymin ymax] dx dy quadrillagexOy_
/quadrillagexOy_ {
4 dict begin
   dup isarray {
      /dx 1 def
      /dy 1 def
   } {
      /dy exch def
      dup isarray {
         /dx dy def
      } {
         /dx exch def
      } ifelse
   } ifelse
   /table exch def
   table 0 get /xmin exch def
   table 1 get /xmax exch def
   table 2 get /ymin exch def
   table 3 get /ymax exch def
   ymin dy ymax {
      /y exch def
      xmin y smoveto
      xmax y slineto
   } for
   xmin dx xmax {
      /x exch def
      x ymin smoveto
      x ymax slineto
   } for
end
} def

%% syntaxe : plan [ngrid] planquadrillage
/planquadrillage {
4 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isplan {
      /ngrid [1 1] def
   } {
      /ngrid exch def
   } ifelse
   /leplan exch def
   /dx ngrid 0 get def
   /dy ngrid 1 get def
   /table leplan plangetrange def
   table 0 get cvi truncate /xmin exch def
   table 1 get cvi truncate /xmax exch def
   table 2 get cvi truncate /ymin exch def
   table 3 get cvi truncate /ymax exch def
   newpath
      ymin dy ymax {
         /y exch def
         xmin y smoveto
         xmax y slineto
      } for
      xmin dx xmax {
         /x exch def
         x ymin smoveto
         x ymax slineto
      } for
      leplan mybool projpath
   Stroke
end
} def

%% syntaxe : plantype str1 str2 planshowbase -> - 
%% syntaxe : plantype str2 planshowbase -> - 
%% syntaxe : plantype planshowbase -> - 
/planshowbase {
3 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup isstring {
      /couleur2 exch def
      dup isstring {
         /couleur1 exch def
      } {
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
   } ifelse
   mybool bprojscene
      couleur1 cvx exec
      newpath
         0 0 smoveto
         1 0 slineto
      Stroke
      0 0 1 0 oldarrow
      couleur2 cvx exec
      newpath
         0 0 smoveto
         0 1 slineto
      Stroke
      0 0 0 1 oldarrow
   eprojscene
end
} def

%% syntaxe : plantype str1 str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str2 str3 planshowbase3d -> - 
%% syntaxe : plantype str3 planshowbase3d -> - 
%% syntaxe : plantype planshowbase3d -> - 
%% syntaxe : plantype str1 str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str2 str3 array planshowbase3d -> - 
%% syntaxe : plantype str3 array planshowbase3d -> - 
%% syntaxe : plantype array planshowbase3d -> - 
/planshowbase3d {
7 dict begin
   dup isbool {
      /mybool exch def
   } {
      /mybool true def
   } ifelse
   dup dup isarray exch isplan not and {
      /table exch def
   } {
      /table {} def
   } ifelse
   dup isstring {
      /couleur3 exch def
      dup isstring {
         /couleur2 exch def
         dup isstring {
            /couleur1 exch def
         } {
            /couleur1 (rouge) def
         } ifelse
      } {
         /couleur2 (vert) def
         /couleur1 (rouge) def
      } ifelse
   } {
      /couleur1 (rouge) def
      /couleur2 (vert) def
      /couleur3 (bleu) def
   } ifelse
   /plan exch def
   plan couleur1 couleur2 mybool planshowbase
   plan plangetorigine /I defpoint3d
   plan plangetbase
   dup 0 getp3d /u defpoint3d
   1 getp3d /v defpoint3d
   u v vectprod3d table newvecteur
   {I addv3d} solidtransform
   dup couleur3 solidputcolors
   solidgridOff
   drawsolid**
end
} def

%% syntaxe : plantype x y z plantranslate --> -
/plantranslate {
4 dict begin
   /M defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans plantranslate) ==
      quit
   } if
   plan plan plangetorigine M addv3d planputorigine
end
} def

% syntaxe : alpha_x alpha_y alpha_z rotateOpplan --> -
/rotateOplan {
4 dict begin
   /Rxyz defpoint3d
   /plan exch def
   plan isplan not {
      (Erreur : mauvais type d argument dans rotateOplan) ==
      quit
   } if
   plan plan plangetorigine Rxyz rotateOpoint3d planputorigine

   plan plangetbase 0 getp3d /U defpoint3d
   plan plangetbase 1 getp3d /V defpoint3d
   plan [
      U Rxyz rotateOpoint3d
      V Rxyz rotateOpoint3d
   ] planputbase
end
} def

%% syntaxe : plantype phi rotateplan --> -
/rotateplan {
5 dict begin
   /phi exch def
   /leplan exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U phi cos mulv3d
   V phi sin mulv3d addv3d /U0 defpoint3d
   U phi sin neg mulv3d
   V phi cos mulv3d addv3d /V0 defpoint3d
   leplan [U0 V0] planputbase
end
} def

%% syntaxe : solid i solidface2plan --> plantype
%% syntaxe : solid i I solidface2plan --> plantype
/solidface2plan {
5 dict begin
   2 copy pop issolid {
      /i exch def
      /solid exch def
      solid i solidcentreface /I defpoint3d
   } {
      /I defpoint3d
      /i exch def
      /solid exch def
   } ifelse
   /result newplanaffine def
   solid i solidcentreface /G defpoint3d
   solid i solidnormaleface /K defpoint3d
   solid 0 i solidgetsommetface
   solid 1 i solidgetsommetface
   milieu3d /A defpoint3d
   G A vecteur3d normalize3d /U defpoint3d
   K U vectprod3d /V defpoint3d
   result [U V] planputbase
   result I planputorigine
   result
end
} def

%%%%% ### fin insertion ###
%% syntaxe : x y plantype pointplan --> X Y Z
/pointplan {
5 dict begin
   /leplan exch def
   /y exch def
   /x exch def
   leplan plangetbase 0 getp3d /U defpoint3d
   leplan plangetbase 1 getp3d /V defpoint3d
   U x mulv3d V y mulv3d addv3d
end
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%     operations sur des solides particuliers        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/piedist {
4 dict begin
   /mypie exch def
   mypie 0 solidgetface length /n exch def
   mypie n 2 idiv solidgetsommet /A defpoint3d
   mypie n 2 idiv 1 add solidgetsommet /B defpoint3d
   A B milieu3d GetCamPos distance3d
end
} def

/sortpieset {
5 dict begin
   dup issolid {
      ]
   } if
   /table exch def
   [
      0 1 table length 1 sub {
         /i exch def
         table i get piedist
      } for
   ]
   doublequicksort pop reverse
   /result exch def
   [
      0 1 result length 1 sub {
         /i exch def
         table result i get get 
      } for
   ]
end
} def

/drawpieset {
1 dict begin
   /startest true def
   sortpieset dup {drawsolid**} apply {0 dessinefacevisible} apply
end
} def

%%%%% ### solidchanfreine ###
%% syntaxe : solid coeff solidchanfreine --> solid
/solidchanfreine {
10 dict begin
   /coeff exch def
   /solid exch def
   /result newsolid def
   solid issolid not {
      (Erreur : mauvais type d argument dans solidchanfreine) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def

   %% ajout des faces reduites
   0 1 nf 1 sub {
      /i exch def
      /Fsommets solid i solidgetsommetsface def
      /Findex solid i solidgetface def
      /ns Fsommets length 3 idiv def
      /couleurfaceorigine solid i solidgetfcolor def
      Fsommets isobarycentre3d /G defpoint3d
      %% on ajoute les nouveaux sommets
      /Sindex [] def
      0 1 ns 1 sub {
         /j exch def
         /Sindex [ Sindex aload pop
            Fsommets j getp3d /M defpoint3d
            result M G coeff hompoint3d solidaddsommet
         ] store
      } for
      %% Sindex contient les indices des nouveaux sommets
      result Sindex couleurfaceorigine solidaddface
   } for

   %% ajout des faces rectangulaires entre faces d'origines adjacentes
   %% pour chaque face de depart
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      /Fres result i solidgetface def
      %% pour chaque arete de la face
      0 1 F length 1 sub {
         /j exch def
         /trouve false def
         /indice1 F j get def
         /indice2 F j 1 add F length mod get def
         /a1 j def
         /a2 j 1  add F length mod def
         %% on regarde toutes les autres faces
         i 1 add 1 nf 1 sub {
            /k exch def
            /Ftest solid k solidgetface def
            indice1 Ftest in {pop true} {false} ifelse
            indice2 Ftest in {pop true} {false} ifelse
            and {
               /indiceFadj k def
               indice1 Ftest in pop /k1 exch def
               indice2 Ftest in pop /k2 exch def
               /trouve true def
            exit
            } if
         } for
         trouve {
            /Fadj solid indiceFadj solidgetface def
            result [
               Fres a1 get
               result indiceFadj solidgetface k1 get
               result indiceFadj solidgetface k2 get
               Fres a2 get
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   %% pour chaque face
   0 1 nf 2 sub {
      /i exch def
      /F solid i solidgetface def
      /couleurfaceorigine solid i solidgetfcolor def
      %% et pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /k F j get def
         solid k solidfacesadjsommet /adj exch def
         %% adj est le tableau des indices des faces adjacentes
         %% au sommet d'indice k
         %% rque : toutes les faces d'indice strict inferieur a i
         %% sont deja traitees
         %% Pour chaque face adjacente, on repere l'indice du sommet concerne dans
         %% la face
         adj min i lt not {
            /indadj [] def
            0 1 adj length 1 sub {
               /m exch def
               k solid adj m get solidgetface in {
                  /ok exch def
                  /indadj [indadj aload pop ok] store
               } if
            } for
         
            /aajouter [
               0 1 adj length 1 sub {
                  /m exch def
                  result adj m get solidgetface indadj m get get
               } for
            ] def

            %% la table des sommets
            [0 1 aajouter length 1 sub {
               /m exch def
               result aajouter m get solidgetsommet
            } for]
            solid k solidgetsommet %% le point indiquant la direction de la normale
            ordonnepoints3d
            /indicestries exch def

            result [
               0 1 indicestries length 1 sub {
                  /m exch def
                  aajouter indicestries m get get
               } for
            ] couleurfaceorigine solidaddface
         } if
      } for
   } for

   result
end
} def

%%%%% ### solidplansection ###
%% syntaxe : M eqplan --> real
%% image de M par la fonction definie par l equation eqplan
/pointeqplan {
8 dict begin
   /@qplan exch def
   /@z exch def
   /@y exch def
   /@x exch def
   /@a @qplan 0 get def
   /@b @qplan 1 get def
   /@c @qplan 2 get def
   /@d @qplan 3 get def
   @a @x mul @b @y mul add @c @z mul add @d add 
end
} def

%% syntaxe : A B eqplan segment_inter_plan --> array true ou false
%% array contient 1 point M si [AB] inter plan = {M}
%% array contient les 2 points A et B si [AB] inter plan = [AB]
/segment_inter_plan {
4 dict begin
   dup isplan {plan2eq} if
   /plan exch def
   plan aload pop
   /d exch def
   /c exch def
   /b exch def
   /a exch def
   /B defpoint3d
   /A defpoint3d
   A 
   /zA exch def
   /yA exch def
   /xA exch def
   B 
   /zB exch def
   /yB exch def
   /xB exch def
   /imA a xA mul b yA mul add c zA mul add d add def
   /imB a xB mul b yB mul add c zB mul add d add def
   imA imB mul dup 0 gt {
      %% pas d intersection
      pop
      false
   } {
      0 eq {
         %% intersection en A ou en B
         [ 
            imA 0 eq {A} if 
            imB 0 eq {B} if 
         ] true
      } {
         %% intersection entre A et B
         /k 
            imA neg
            xB xA sub a mul
            yB yA sub b mul add
            zB zA sub c mul add
            dup 0 eq {
               (Error dans segment_inter_plan) ==
               quit
            } if
            div
         def
         [
            A B vecteur3d
            k mulv3d
            A addv3d
         ] true
      } ifelse
   } ifelse
end
} def

%% syntaxe : solid i solidface2eqplan --> [a b c d]
%% equation cartesienne de la face d'indice i du solide solid
/solidface2eqplan {
8 dict begin
   /i exch def
   /solid exch def
   solid i solidnormaleface
   /c exch def
   /b exch def
   /a exch def
   solid 0 i solidgetsommetface
   /z exch def
   /y exch def
   /x exch def
   [a b c a x mul b y mul add c z mul add neg]
end
} def

%% syntaxe : array1 arrayrmdouble --> array2
%% remplace 2 elts identiques consecutifs par 1 elt
/arrayrmdouble {
5 dict begin
   /table exch def
   /result [table 0 get] def
   /j 0 def
   1 1 table length 1 sub {
      /i exch def
      table i get
      result j get
      eq not {
         /result [result aload pop table i get] store
         /j j 1 add store
      } if
   } for
   result
end
} def

%% syntaxe : solid eqplan/plantype solidplansection --> solid2
/solidplansection {
10 dict begin
   dup isbool {
      /tr@nsmit exch def
   } {
      /tr@nsmit false def
   } ifelse
   dup isplan {
      plan2eqplan
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   dupsolid /result exch def
   /solid exch def
   /aenlever [] def
   /indnouveauxsommets [] def
   /nouvellesaretes [] def

   %% pour chaque face d'indice i
   0 1 solid solidnombrefaces 1 sub {
      /i exch def
      /lacouleur solid i solidgetfcolor def
      /F solid i solidgetface def %% table des indices des sommets
      /n F length def %% nb d'aretes
      /k1 -1 def
      /k2 -1 def
      /k3 -1 def
      /k4 -1 def
      /k3a -3 def
      /k4a -3 def
      %% pour chaque arete [AB]
      0 1 n 1 sub {
         /j exch def
         %% arete testee : [j, j+1 mod n] (indices relatifs a la face i)
         solid j i solidgetsommetface /A defpoint3d
         solid j 1 add n mod i solidgetsommetface /B defpoint3d
         %% y a-t-il intersection
         A B eqplan segment_inter_plan {
            %% il y a intersection
            dup length 6 eq {
               %% l'intersection, c'est [AB]
               /k1 -1 def
               /k2 -1 def
               /k3 -1 def
               /k4 -1 def
               /k3a -1 def
               /k4a -1 def
               dup 0 getp3d /A defpoint3d
               1 getp3d /B defpoint3d
               result A solidaddsommet /a1 exch def
               result B solidaddsommet /a2 exch def
               /indnouveauxsommets [
                  indnouveauxsommets aload pop a1 a2
               ] store
               /nouvellesaretes [
                  [a1 a2]
                  nouvellesaretes aload pop
               ] store
               exit %% c est deja scinde
            } if
            %% il y a intersection <> [AB]
            k1 0 lt {
            %% 1ere intersection de la face
               /k1 j def %% sommet precedent intersection 1
               result exch aload pop solidaddsommet
               /k1a exch def %% sommet intersection 1
            } {
               k2 0 lt {
               %% 2eme intersection de la face
                  /k2 j def %% sommet precedent intersection 2
                  result exch aload pop solidaddsommet
                  /k2a exch def %% sommet intersection 2
               } {
                  k3 0 lt {
                  %% 3eme intersection de la face
                     /k3 j def %% sommet precedent intersection 3
                     result exch aload pop solidaddsommet
                     /k3a exch def %% sommet intersection 3
                  } {
                  %% 4eme intersection de la face
                     /k4 j def %% sommet precedent intersection 4
                     result exch aload pop solidaddsommet
                     /k4a exch def %% sommet intersection 4
                  } ifelse
               } ifelse
            } ifelse
         } if
      } for
      
      %% y a-t-il eu une coupe ?
      %% si oui, il faut scinder la face d'indice i en cours 
      k1 0 ge {
%% (coupe) ==
%% (n) == n ==
%% k1 == k2 == k3 == k4 ==
%% (a) ==
%% k1a == k2a == k3a == k4a ==
         k1a k2a eq k3 0 lt and {
            %% 1 pt d'intersection
         } {
            %% il y a coupe, on cherche a eliminer les
            %% doublons dans {k1a, k2a, k3a, k4a}
            k1a k2a eq k3 0 ge and {
               %% 2 pts d'intersection
               /k2a k3a def
               /k2 k3 def
            } if
            k1a k3a eq k4 0 ge and {
               %% 2 pts d'intersection
               /k2a k4a def
               /k2 k4 def
            } if
            /nouvellesaretes [
               [k1a k2a]
               nouvellesaretes aload pop
            ] store
            [
               k1a F k1 1 add n mod get ne {
                  k1a
               } if
               k1 1 add n mod 1 k2 {F exch get} for
               k2a F k2 get ne {
                  k2a
               } if
            ]
            result exch lacouleur solidaddface
            /indnouveauxsommets [indnouveauxsommets aload pop k1a k2a] store
            [
               k2a F k2 1 add n mod get ne {
                  k2a
               } if
               k2 1 add n ne {
                  k2 1 add n mod 1 n 1 sub {F exch get} for
               } if
               0 1 k1 {F exch get} for
               k1a F k1 get ne {
                  k1a
               } if
            ]
            result exch lacouleur solidaddface
            /aenlever [aenlever aload pop i] store
         } ifelse
      } if
   } for
   result aenlever solidrmfaces

   nouvellesaretes separe_composantes
   /composantes exch def

   %% pour chacune des composantes
   0 1 composantes length 1 sub {
      %% on oriente et on ajoute la face
      /icomp exch def
      %indnouveauxsommets bubblesort arrayrmdouble
      /indnouveauxsommets composantes icomp get def
      %% maintenant, on ajoute la face de plan de coupe
      /nouveauxsommets [
         0 1 indnouveauxsommets length 1 sub {
            /i exch def
            result indnouveauxsommets i get solidgetsommet
         } for
      ] def
   
      0 0 0 eqplan pointeqplan 0 eq {
         /ptref {0 1 1} def
      } {
         /ptref {0 0 0} def
      } ifelse
   
      %% restera a traiter le cas limite ou la nouvelle face existe deja
      %% tester si max(indicestries) < nb sommets avant section
      nouveauxsommets ptref ordonnepoints3d
      /indicestries exch def
      /nvelleface [
         0 1 indicestries length 1 sub {
            /m exch def
            indnouveauxsommets indicestries m get get
         } for
      ] def
      /F result solidgetfaces def
      /FC result solidgetfcolors def
      /IO result solidgetinouttable def
      /n1 IO 1 get def
      IO 1 n1 1 add put
      result IO solidputinouttable
      result [nvelleface F aload pop] solidputfaces
      result [lacouleur FC aload pop] solidputfcolors
   } for
   result
   tr@nsmit {
      composantes length 
   } if
end    
} def

%% syntaxe : elt array compteoccurences
%% ou array est un tableau du type [ [a1 a2] [b1 b2] [c1 c2] ... ]
/compteoccurences {
5 dict begin
   /table exch def
   /elt exch def
   /n 0 def
   0 1 table length 1 sub {
      /i exch def
      elt table i get in {
         pop
         /n n 1 add store
      } if
   } for
   n
end
} def

/separe_composantes {
10 dict begin
   /result [] def %% les composantes deja faites
   /table exch def %% ce qui reste a faire

%   (recu) == table {==} apply
   {
      /ext1 table 0 get 1 get def
      /ext0 table 0 get 0 get def
      /composante [] def
   
      { %% maintenant on suit les extremites et on epluche une composante
         /change false def
         /aenlever [] def
         0 1 table length 1 sub {
            /i exch def
            ext1 table i get In
            ext0 table i get In or {
               /aenlever [aenlever aload pop i] store
               /change true store
               %% l'arete i contient l'extremite ext0 ou ext1
               ext0 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext0 exch store
                  ext0 composante In not {
                     /composante [composante aload pop ext0] store
                  } if
                  %% on verifie que ext0 est legitime
                  ext0 table compteoccurences 2 gt {
                     /ext0 -1 store
                  } if
               } if
               ext1 table i get in {
                  %% index = 0 ou 1
                  neg 1 add table i get exch get
                  /ext1 exch store
                  ext1 composante In not {
                     /composante [composante aload pop ext1] store
                  } if
                  %% on verifie que ext1 est legitime
                  ext1 table compteoccurences 2 gt {
                     /ext1 -1 store
                  } if
               } if
            } if
         } for
         %% il faut reconstruire table
         /table [
            0 1 table length 1 sub {
               /i exch def
               i aenlever in {
                  pop
               } {
                  table i get
               } ifelse
            } for
         ] store
         change not {exit} if
      } loop
      %% on vient de finir une composante
      /result [result aload pop composante] store
      %% (nouvelle comp) == composante {==} apply
      table length 0 eq {exit} if
   } loop
   result
%   (renvoie) == result {==} apply
end
} def

/solideqplansepare {solidplansepare} def
    
%% syntaxe : solid eqplan/plantype solidplansepare --> solid1 solid2
/solidplansepare {
10 dict begin
   dup isplan {
      plan2eq
      /eqplan exch def
   } {
      /eqplan exch def
   } ifelse
   eqplan true solidplansection
   /nbcomposantes exch def
   /solid exch def
   /n solid solidnombrefaces def

   /F [] def
   /FC [] def
   %% on retire les faces de coupe
   0 1 nbcomposantes 1 sub {
      /i exch def
      /F [F aload pop solid i solidgetface] store
      /FC [FC aload pop solid i solidgetfcolor] store
   } for
   solid [0 1 nbcomposantes 1 sub {} for] solidrmfaces
   /n n nbcomposantes sub store

   %% on separe les autres faces en 2 parties
   /lesneg [] def %% indices des faces "positives"
   /lespos [] def %% indices des faces negatives"
   0 1 n 1 sub {
      /i exch def
      solid i solidcentreface /G defpoint3d
      G eqplan pointeqplan dup 0 gt {
         pop
         /lespos [lespos aload pop i] store
      } {
         0 lt {
            /lesneg [lesneg aload pop i] store
         } {
%           /lesneg [lesneg aload pop i] store
%           /lespos [lespos aload pop i] store
         } ifelse
      } ifelse
   } for
   solid
   dupsolid dup lesneg solidrmfaces
   /result1 exch def
   dupsolid dup lespos solidrmfaces
   /result2 exch def
   pop

   0 1 nbcomposantes 1 sub {
      /i exch def
      /facecoupe F i get def
      /couleurfacecoupe FC i get def
      /lesfaces1 result1 solidgetfaces def
      /lescouleurs1 result1 solidgetfcolors def
      /IO1 result1 solidgetinouttable def
      /lesfaces2 result2 solidgetfaces def
      /lescouleurs2 result2 solidgetfcolors def
      /IO2 result2 solidgetinouttable def
      %% on rajoute maintenant la face du plan de coupe
%      result1 facecoupe couleurfacecoupe solidaddface
      result1 [facecoupe lesfaces1 aload pop] solidputfaces
      result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
      result1 IO1 dup dup 1 get 1 add 1 exch put solidputinouttable
      %% et on verifie l'orientation
%      result1 dup solidnombrefaces 1 sub solidnormaleface 
%      result1 dup solidnombrefaces 1 sub solidcentreface addv3d
      result1 0 solidnormaleface 
      result1 0 solidcentreface addv3d
      eqplan pointeqplan 0 gt {
         %% l'orientation est mauvaise
         result1 0 solidrmface 
         result2 [facecoupe lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result1 [facecoupe reverse lesfaces1 aload pop] solidputfaces
         result1 [couleurfacecoupe lescouleurs1 aload pop] solidputfcolors
         result1 dup solidgetinouttable dup dup 1 get 1 add 1 exch put solidputinouttable
      } {
         %% l'orientation est ok
         result2 IO2 dup dup 1 get 1 add 1 exch put solidputinouttable
         result2 [facecoupe reverse lesfaces2 aload pop] solidputfaces
         result2 [couleurfacecoupe lescouleurs2 aload pop] solidputfcolors
      } ifelse
   } for
   
   %% maintenant on enleve les sommets isoles
   /sommetspos [] def
   /sommetsneg [] def
   %% pour chaque face du cote negatif
   0 1 lesneg length 1 sub {
      lesneg exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetsneg in not {
            %% et s'il est isole, on peut l'enlever
            result1 sommet solidsommetsadjsommet length 0 eq {
               /sommetsneg [sommetsneg aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetsneg bubblesort reverse {result1 exch solidrmsommet} apply

   %% pour chaque face du cote positif
   0 1 lespos length 1 sub {
      lespos exch get /i exch def
      /F solid i solidgetface def
      %% pour chaque sommet de cette face
      0 1 F length 1 sub {
         /j exch def
         /sommet F j get def
         %% si le sommet n'est pas encore note
         sommet sommetspos in not {
            %% et s'il est isole, on peut l'enlever
            result2 sommet solidsommetsadjsommet length 0 eq {
               /sommetspos [sommetspos aload pop sommet] store
            } if
         } {
            pop
         } ifelse
      } for
   } for
   sommetspos bubblesort reverse {result2 exch solidrmsommet} apply

   result1 result2
end
} def

%%%%% ### solidaffine ###
%% syntaxe : solid coeff i solidaffine -> -
%% syntaxe : solid coeff array solidaffine -> -
%% syntaxe : solid coeff solidaffine -> -
%% syntaxe : solid coeff str solidaffine -> -
%% syntaxe : solid coeff bool solidaffine -> -
/solidaffine {
10 dict begin
   dup isbool {
      /rmfacecentrale exch def
   } {
      /rmfacecentrale true def
   } ifelse
   dup isstring {
      /couleurface exch def
   } if
   2 copy pop issolid {
      %% 2 arguments --> on affine tout
      2 copy pop solidnombrefaces /n exch def
      /table [n 1 sub -1 0 {} for] def 
   } {
      %% 1 tableau --> il donne les faces a enlever
      dup isarray {
         /table exch bubblesort reverse def
      } {
      %% 1 seule face a enlever
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /coeff exch def
   /solid exch def
   0 1 table length 1 sub {
      /i exch def
      solid coeff table i get 
      currentdict /couleurface known {
         couleurface 
      } if
      rmfacecentrale s@lidaffineface
   } for
end
} def

%% syntaxe : solid coeff i s@lidaffineface
 /s@lidaffineface {
10 dict begin
   /rmfacecentrale exch def
   dup isstring {
      /couleurface exch def
   } if
   /indice_a_chamfreiner exch def
   /i indice_a_chamfreiner def
   /coeff exch def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans affine) ==
      quit
   } if
   /n solid solidnombresommets def
   /F solid i solidgetsommetsface def
   /Findex solid i solidgetface def
   /ni F length 3 idiv def
   /couleurfaceorigine solid i solidgetfcolor def
   F isobarycentre3d /G defpoint3d
   %% on ajoute les nouveaux sommets
   /Sindex [] def
   0 1 ni 1 sub {
      /j exch def
      /Sindex [ Sindex aload pop
         solid G F j getp3d vecteur3d coeff mulv3d G addv3d solidaddsommet
      ] store
   } for
   %% Sindex contient les indices des nouveaux sommets
   %% on prepare les faces a ajouter
   /facestoadd [] def
   /facestoadd [facestoadd aload pop
   0 1 ni 1 sub {
      /j exch def
      [Findex j get
      Findex j 1 add ni mod get
      Sindex j 1 add ni mod get
      Sindex j get]
   } for
   ] store
   0 1 ni 1 sub {
      /i exch def
      solid facestoadd i get solidaddface
   } for
   %% on enleve la face d origine
   solid indice_a_chamfreiner solidrmface
   %% on ajuste les couleurs des nouvelles faces
   /N solid solidnombrefaces def
   0 1 ni 1 sub {
      /i exch def
      solid N 1 sub i sub couleurfaceorigine solidputfcolor
   } for
   %% puis on ajoute eventuellement la face centrale
   rmfacecentrale not {
      solid
      [0 1 ni 1 sub {
         /j exch def
         Sindex j get
      } for]
      solidaddface
      %% en ajustant la couleur de cette derniere
      solid N
      currentdict /couleurface known {
            couleurface 
      } {
         couleurfaceorigine
      } ifelse
      solidputfcolor
   } if
end
} def

%%%%% ### solidtronque ###
%% syntaxe : solid indicesommet k solidtronque --> solid
%% syntaxe : solid array k solidtronque --> solid
%% syntaxe : solid k solidtronque --> solid
%% k entier > 0, array = tableau des indices des sommets
/solidtronque {
10 dict begin
   /coeff exch def
   dup issolid {
      dup solidnombresommets /N exch def
      /table [0 1 N 1 sub {} for] def
   } {
      dup isarray {
         /table exch def
      } {
         [ exch ] /table exch def
      } ifelse
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   0 1 table length 1 sub {
      table exch get /no exch def
      result no solidgetsommet /sommetvise defpoint3d
      %% on recup les sommets adjacents au sommet vise
      /sommetsadj solid no solidsommetsadjsommet def
      %% on calcule les nouveaux sommets
      /nouveauxsommets [
         0 1 sommetsadj length 1 sub {
            /i exch def
            solid sommetsadj i get solidgetsommet
         } for
      ] {sommetvise exchp3d coeff ABpoint3d} papply3d def 
      %% on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G result no solidgetsommet vecteur3d /vecteurnormal defpoint3d
      %% on construit le tableau des angles ordonnes par rapport
      %% a la normale
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      %% on rajoute les sommets au solide, et on note les nouveaux indices
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% on ajoute la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      result no solidfacesadjsommet /lesfaces exch def
      %% on examine la face d indice i, et on elimine le
      %% sommet vise
      0 1 lesfaces length 1 sub {
         /i exch def
         /j lesfaces i get def
         /F result j solidgetface def 
         result [
            0 1 F length 1 sub {
               /k exch def 
               F k get dup no eq {pop} if
            } for
         ] j exch solidputface 
      } for
   } for
   table bubblesort reverse {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### dualpolyedre ###
%% syntaxe : solid dualpolyedreregulier --> solid
%% syntaxe : solid r dualpolyedreregulier --> solid
%% si le nombre r est present, projette les nouveaux sommets sur la sphere de centre O , de rayon r
/dualpolyedreregulier {
20 dict begin
   dup isnum {
      /r exch def
      /projection true def
   } {
      /projection false def
   } ifelse
   /solid exch def
   solid dupsolid /result exch def pop
   /n solid solidnombrefaces def
   /N solid solidnombresommets def
   /facesaenlever [] def
   %% pour chacun des sommets
   0 1 N 1 sub {
      %% sommet d indice i
      /i exch def
      %% indicesfacesadj = liste des indices des faces ou on trouve le sommet i
      /indicesfacesadj solid i solidfacesadjsommet def
      %% on recupere les centres des faces concernees
      /nouveauxsommets [
         0 1 indicesfacesadj length 1 sub {
            /k exch def 
            solid indicesfacesadj k get solidgetsommetsface isobarycentre3d
         } for
      ] def
      %% et on pose G = barycentre de ces points
      nouveauxsommets isobarycentre3d /G defpoint3d
      %% il faut ordonner ces sommets
      nouveauxsommets 0 getp3d /ptref defpoint3d
      G solid i solidgetsommet vecteur3d /vecteurnormal defpoint3d
      nouveauxsommets duparray exch pop
      {1 dict begin
         /M defpoint3d
         G ptref vecteur3d
         G M vecteur3d
         vecteurnormal angle3doriente
      end} papply3d
      doublebubblesort pop
      %% nos sommets sont tries
      /indicesommetstries exch def
      projection {
         %% on projette les sommets sur la sphere
         /nouveauxsommets [ nouveauxsommets {normalize3d r mulv3d} papply3d aload pop ] store
      } if
      %% puis on les rajoute au solide
      /nouveauxindices [
         0 1 nouveauxsommets length 3 idiv 1 sub {
            /k exch def
            result nouveauxsommets k getp3d solidaddsommet
         } for
      ] def
      %% ainsi que la face concernee
      result [
         0 1 indicesommetstries length 1 sub {
            /k exch def
         nouveauxindices indicesommetstries k get get
         } for 
      ] solidaddface
      /facesaenlever [ facesaenlever aload pop indicesfacesadj aload pop ] store
   } for
   result [0 1 n 1 sub {} for] solidrmfaces
   [N 1 sub -1 0 {} for] {result exch solidrmsommet} apply
   result
end
} def

%%%%% ### newgeode ###
%% syntaxe : solid r newgeode --> solid
%% syntaxe : N r newgeode --> solid
%% N in {3,4,5} -> polyhedre de depart, r = niveau de recursion
/newgeode {
2 dict begin
   /r exch def
   dup issolid not {
      /N exch def
      N 3 eq {
         1 newtetraedre
      } {
         N 4 eq {
            1 newoctaedre
         } {
            1 newicosaedre
         } ifelse
      } ifelse
   } if

   r {
      15 dict begin   
         /solid exch def
         solid dupsolid /result exch def pop
         /n solid solidnombrefaces def
         n 1 sub -1 0 {
            /i exch def
            %% la face d indice i
            solid i solidgetface /F exch def
            /i0 F 0 get def
            /i1 F 1 get def
            /i2 F 2 get def
            solid i0 solidgetsommet /A0 defpoint3d
            solid i1 solidgetsommet /A1 defpoint3d
            solid i2 solidgetsommet /A2 defpoint3d
            A0 A1 milieu3d normalize3d /A01 defpoint3d
            A1 A2 milieu3d normalize3d /A12 defpoint3d
            A2 A0 milieu3d normalize3d /A20 defpoint3d
            result A01 solidaddsommet /i01 exch def
            result A12 solidaddsommet /i12 exch def
            result A20 solidaddsommet /i20 exch def
            result i solidrmface
            result [i0 i01 i20] solidaddface
            result [i01 i1 i12] solidaddface
            result [i01 i12 i20] solidaddface
            result [i20 i12 i2] solidaddface
         } for
         result
      end
   } repeat
end
} def

%% syntaxe : N r newdualgeode --> solid
/newdualgeode {
   newgeode 1
   dualpolyedreregulier
} def

%%%%% ### fin insertion ###


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             quelques solides precalcules           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%% ### newface ### 
%% syntaxe : array newmonoface -> solid
%% ou array = tableau de points 2d
/newmonoface {
4 dict begin
   /table exch def
   /n table length 2 idiv def
   /S table {0} papply def

   /F [
       [0 1 n 1 sub {} for]
   ] def
   S F generesolid
end
} def

%% syntaxe : array newbiface -> solid
%% ou array = tableau de points 2d
/newbiface {
   newmonoface
   dup videsolid
} def

%%%%% ### newpolreg ### 
%% syntaxe : r n newpolreg --> solid
/newpolreg {
5 dict begin
   /n exch def
   /r exch def
   /S [
       0 360 n div 360 360 n div sub {
           /theta exch def
           theta cos r mul
           theta sin r mul
           0
       } for
   ] def
   /F [
       [0 1 n 1 sub {} for]
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newgrille ### 
%% syntaxe : xmin xmax ymin ymax [dx dy] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax [nx ny] newgrille -> solid
%% syntaxe : xmin xmax ymin ymax {mode} newgrille -> solid
%% syntaxe : xmin xmax ymin ymax newgrille -> solid
/newgrille {
10 dict begin
   [[/nx /ny] [1 1] [1. 1.] [1. 1.] [1. 1.] [.5 .5]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /biface false def
   [nx ny] {0} newsurfaceparametree
end
} def

%% %% syntaxe : xmin xmax ymin ymax [dx dy] {f} newsurface -> solid
%% %% f : R^2 -> R
/newsurface {
   true newsurfaceparametree
} def

/biface true def

/newsurfaceparametree {
10 dict begin
   dup isbool {
      pop /surfz true def
   } {
      /surfz false def
   } ifelse
   /f_surface exch def
   [[/nx /ny] [2 2] [4 4] [1. 1.] [1. 1.] [.25 .25]] gestionsolidmode
   %% ny nb d etages en y
   %% nx nb d etages en x
   /ymax exch def
   /ymin exch def
   /xmax exch def
   /xmin exch def

   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x

   /S [
       0 1 nx {
           /i exch def
           0 1 ny {
               /j exch def
               /u xmin i dx mul add def
               /v ymin j dy mul add def
               u v
               surfz {2 copy} if
               f_surface
               pstrickactionR3
           } for
       } for
   ] def

   /F [
       0 1 nx 1 sub {
          /i exch def
          0 1 ny 1 sub {
             /j exch def
             [
                j 1 add        i ny 1 add mul add
                j              i ny 1 add mul add
                j ny 1 add add i ny 1 add mul add
                j ny 2 add add i ny 1 add mul add
             ]
          } for
       } for
%%       0 1 0 {%nx 1 sub {
%%          /i exch def
%%          0 1 0 {%ny 2 sub {
%%             /j exch def
%%             [
%%             j 1 add        %% i ny mul add
%%             j              %% i ny mul add
%%             ny 1 add j add       %% i ny mul add
%%             ny 2 add j add     %% i ny mul add
%%             ]
%%          } for
%%       } for
   ] def
   S F generesolid
   biface pl@n-en-cours not and {dup videsolid} if
end
} def

%%%%% ### newgrillecirculaire ### 
%% syntaxe : r option newgrillecirculaire -> solid
/newgrillecirculaire {
6 dict begin
   [[/K /N] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode

   %% N = nb de meridiens (diviseur de 360 = 2^4 * 3^2 * 5)
   %% K = nb d horizontales (diviseur de 160 = 2^5 * 5)

   /r exch def
   /F [
       %% 1er etage
       1 1 N {
           /i exch def
           [0 i i N mod 1 add]
       } for
       %% etages suivants
       0 1 K 2 sub {
           /j exch def
           1 1 N {
               /i exch def
               [i      j N mul add
               i N add j N mul add
               i N mod N add 1 add j N mul add
               i N mod 1 add j N mul add]
           } for
      } for
   ] def

   %% tableau des sommets
   /S [
       0 0 0
       1 1 K {
           /j exch def
           1 1 N {
             /i exch def
             /theta i 360 mul N div def
             theta cos r j mul K div mul
             theta sin r j mul K div mul
             0 %2 copy f %exch atan 90 div
          } for
       } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r [dx dy] {f} newsurface* -> solid
/newsurface* {
7 dict begin
   /f_surface exch def
   [[/nx /ny] [6 6] [6 8] [10 8] [16 12] [16 36]] gestionsolidmode

   nx isinteger not {
       %% alors nx est un dx
       /nx xmax xmin sub nx div cvi store
   } if
   ny isinteger not {
       %% alors ny est un dy
       /ny ymax ymin sub ny div cvi store
   } if
   /dy ymax ymin sub ny div def %% le pas sur y
   /dx xmax xmin sub nx div def %% le pas sur x

   %% ny = nb de meridiens
   %% nx = nb d horizontales

   /r exch def
   /F [
       %% 1er etage
       1 1 ny {
           /i exch def
           [0 i i ny mod 1 add]
       } for
       %% etages suivants
       0 1 nx 2 sub {
           /j exch def
           1 1 ny {
               /i exch def
               [i      j ny mul add
               i ny add j ny mul add
               i ny mod ny add 1 add j ny mul add
               i ny mod 1 add j ny mul add]
           } for
      } for
   ] def

   %% tableau des sommets
   /S [
       0 0 0 0 f_surface
       1 1 nx {
           /j exch def
           1 1 ny {
             /i exch def
             /theta i 360 mul ny div def
             theta cos r j mul nx div mul
             theta sin r j mul nx div mul
             2 copy f_surface
          } for
       } for
   ] def

   S F generesolid
end
} def

%%%%% ### newruban ### 
%% syntaxe : array h u [n] newruban -> solid d axe (O, u), de maillage vertical n
%% syntaxe : array h u newruban -> solid d axe (O, u),
%% syntaxe : array h newruban -> solid d axe (O, k),
%% ou array tableau de points 2d
/newruban {
7 dict begin
   %% N = nb d etages
   [[/N] [1] [1] [1] [3] [4]] gestionsolidmode
   2 copy pop isarray {
      /u {0 0 1} def
   } {
      /u defpoint3d
   } ifelse
   u 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newruban) ==
      quit
   } if
   pop pop
   /h exch def
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   h u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
     } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newicosaedre ### 
/newicosaedre {
3 dict begin
   /a exch def
   /S [
      0.8944271  0              0.4472137
      0.2763932  0.8506507      0.4472137
      -0.7236067 0.5257311      0.4472137
      -0.7236067 -0.5257311     0.4472137
      0.2763932  -0.8506507     0.4472137
      0          0              1
      0          0              -1
      -0.8944271 0              -0.4472137
      -0.2763932 -0.8506507     -0.4472137
      0.7236067  -0.5257311     -0.4472137
      0.7236067  0.5257311      -0.4472137
      -0.2763932 0.8506507      -0.4472137
   ] {a mulv3d} papply3d def

   /F [
      [0 1 5]   %% 1  2 6  ]
      [1 2 5]   %% 2  3 6  ]
      [2 3 5]   %% 3  4 6  ]
      [3 4 5]   %% 4  5 6  ]
      [4 0 5]   %% 5  1 6  ]
      [9 0 4]   %% 10 1 5  ]
      [0 9 10]  %% 1  10 11]
      [10 1 0]  %% 11 2 1  ]
      [1 10 11] %% 2  11 12]
      [11 2 1]  %% 12 3 2  ]
      [2 11 7]  %% 3  12 8 ]
      [2 7 3]   %% 3  8 4  ]
      [3 7 8]   %% 4  8 9  ]
      [3 8 4]   %% 4  9 5  ]
      [4 8 9]   %% 5  9 10 ]
      [6 7 11]  %% 7  8 12 ]
      [6 8 7]   %% 7  9 8  ]
      [6 9 8]   %% 7  10 9 ]
      [6 10 9]  %% 7  11 10]
      [6 11 10] %% 7  12 11]
   ] def

   S F generesolid
end
} def

%%%%% ### newdodecaedre ### 
/newdodecaedre {
3 dict begin
   /a exch def
   /S [
      0          0.607062   0.7946545
      -0.5773503 0.1875925  0.7946545
      -0.3568221 -0.4911235 0.7946545
      0.3568221  -0.4911235 0.7946545
      0.5773503  0.1875925  0.7946545
      0          0.982247   0.1875925
      -0.9341724 0.303531   0.1875925
      -0.5773503 -0.7946645 0.1875925
      0.5773503  -0.7946645 0.1875925
      0.9341724  0.303531   0.1875925
      0          -0.982247  -0.1875925
      0.9341724  -0.303531  -0.1875925
      0.5773503  0.7946545  -0.1875925
      -0.5773503 0.7946545  -0.1875925
      -0.9341724 -0.303531  -0.1875925
      -0.5773503 -0.1875925 -0.7946545
      -0.3568221 0.4911235  -0.7946545
      0.3568221  0.4911235  -0.7946545
      0.5773503  -0.1875925 -0.7946545
      0          -0.607062  -0.7946545
   ] {a mulv3d} papply3d def

   /F [
      [0 1 2 3 4]
      [4 3 8 11 9]
      [4 9 12 5 0]
      [0 5 13 6 1]
      [1 6 14 7 2]
      [2 7 10 8 3]
      [10 19 18 11 8]
      [11 18 17 12 9]
      [12 17 16 13 5]
      [13 16 15 14 6]
      [14 15 19 10 7]
      [15 16 17 18 19]
   ] def
   S F generesolid
end
} def

%%%%% ### newoctaedre ### 
/newoctaedre {
3 dict begin
   /a exch def
   %%Sommets
   /S [
      0  0  1
      1  0  0
      0  1  0
      -1 0  0
      0  -1 0
      0  0  -1
   ] {a mulv3d} papply3d def

   /F [
      [0 4 1]
      [1 2 0]
      [0 2 3]
      [3 4 0]
      [1 5 2]
      [2 5 3]
      [3 5 4]
      [4 5 1]
   ] def

   S F generesolid
end
} def

%%%%% ### newtetraedre ### 
/newtetraedre {
3 dict begin
   /r exch def
   %%Tetraedre
   /S [
      0          0          1
      -0.4714045 -0.8164965 -1 3 div
      0.942809   0          -1 3 div
      -0.4714045 0.8164965  -1 3 div
   ] {r mulv3d} papply3d def

   /F [
      [0 1 2]
      [0 2 3]
      [0 3 1]
      [1 3 2]
   ] def

   S F generesolid
end
} def

%%%%% ### newcube ### 
/newcube {
3 dict begin
   [[/n] [1] [1] [1] [3] [4]] gestionsolidmode
   /a exch 2 div def

   n 1 le {
      /F [
     [0 1 2 3]
     [0 4 5 1]
     [1 5 6 2]
     [2 6 7 3]
     [0 3 7 4]
     [4 7 6 5]
      ] def

      %% tableau des sommets
      /S [
      1  1  1 %% 0
     -1  1  1 %% 1
     -1 -1  1 %% 2
      1 -1  1 %% 3
      1  1 -1 %% 4
     -1  1 -1 %% 5
     -1 -1 -1 %% 6
      1 -1 -1 %% 7
      ] {a mulv3d} papply3d def
      S F generesolid
   } {
      /dl 2 n div def
      /N n dup mul n add 4 mul def
      /n1 n 1 sub dup mul def %% nb sommets centre d une face

      %% tableau des sommets
      /S1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n {
           /i exch def
           -1 i dl mul add
           -1 j dl mul add
        1
        } for
     } for
      ] def

      /S2 S1 {-90 0 0 rotateOpoint3d} papply3d def
      /S3 S2 {-90 0 0 rotateOpoint3d} papply3d def
      /S4 S3 {-90 0 0 rotateOpoint3d} papply3d def

      /S5 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
        1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      /S6 [
     1 1 n 1 sub {
        /j exch def
        1 1 n 1 sub {
           /i exch def
           -1
           -1 i dl mul add
           -1 j dl mul add
        } for
     } for
      ] def

      %% tableau des faces
      /F1 [
     0 1 n 1 sub {
        /j exch def
        0 1 n 1 sub {
           /i exch def
           [
          i n 1 add j mul add
          dup 1 add
          dup n 1 add add
          dup 1 sub
           ]
        } for
     } for
      ] def

      %% syntaxe : i sommettourgauche --> l indice du i-eme sommet du tour
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourgauche {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourgauche) ==
        exit
     } if
     n n 1 add i mul add
      end
      } def

      %% syntaxe : i sommetcentregauche --> l indice du i-eme sommet du centre
      %% de la face gauche (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentregauche {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentregauche) ==
        exit
     } if
     N i add
      end
      } def

      /F5 [
     %%%%% la face gauche %%%%%
     %% le coin superieur gauche
     [
        1 sommettourgauche
        0 sommettourgauche
        n 4 mul 1 sub sommettourgauche
        n1 n 1 sub sub sommetcentregauche
     ]

     %% la bande superieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i 1 add sommettourgauche
           i sommettourgauche
           n1 n sub i add sommetcentregauche
           n1 n sub i 1 add add sommetcentregauche
        ]
     } for

     %% le coin superieur droit
     [
        n sommettourgauche
        n 1 sub sommettourgauche
        n1 1 sub sommetcentregauche
        n 1 add sommettourgauche
     ]

     %% la descente gauche
     %% j from 1 to n-2
     1 1 n 2 sub {
        /j exch def
        [
           n1 n 1 sub j mul sub sommetcentregauche
           n 4 mul j sub sommettourgauche
           n 4 mul j 1 add sub sommettourgauche
           n1 n 1 sub j 1 add mul sub sommetcentregauche
        ]
     } for

     %% les bandes centrales (j from 1 to n-2 et i from 1 to n-2)
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n1 i n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j 1 sub mul add sub sommetcentregauche
          n1 i 1 add n 1 sub j mul add sub sommetcentregauche
          n1 i n 1 sub j mul add sub sommetcentregauche
           ]
        } for
     } for

     %% la descente droite
     1 1 n 2 sub {
        /j exch def
        [
           n j add sommettourgauche
           n1 1 sub j 1 sub n 1 sub mul sub sommetcentregauche
           n1 1 sub j n 1 sub mul sub sommetcentregauche
           n j 1 add add sommettourgauche
        ]
     } for

     %% le coin inferieur gauche
     [
        0 sommetcentregauche
        n 3 mul 1 add sommettourgauche
        n 3 mul sommettourgauche
        n 3 mul 1 sub sommettourgauche
     ]

     %% la bande inferieure (i from 1 to n-2)
     1 1 n 2 sub {
        /i exch def
        [
           i sommetcentregauche
           i 1 sub sommetcentregauche
           n 3 mul i sub sommettourgauche
           n 3 mul i sub 1 sub sommettourgauche
        ]
     } for

     %% le coin inferieur droit
     [
        n 2 mul 1 sub sommettourgauche
        n 2 sub sommetcentregauche
        n 2 mul 1 add sommettourgauche
        n 2 mul sommettourgauche
     ]
      ] def

      %% syntaxe : i sommettourdroit --> l indice du i-eme sommet du tour
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise la variable globale n = nb d etages
      /sommettourdroit {
      1 dict begin
     /i exch def
     i 4 n mul ge {
        i
        (Error: indice trop grand dans sommettourdroit) ==
        exit
     } if
     n 1 add i mul
      end
      } def

      %% syntaxe : i sommetcentredroit --> l indice du i-eme sommet du centre
      %% de la face droit (en commencant par l indice 0). ATTENTION :
      %% utilise les variables globales n = nb d etages, et N = nb sommets
      %% des 4 1eres faces
      /sommetcentredroit {
      1 dict begin
     /i exch def
     i n 1 sub dup mul ge {
        i
        (Error: indice trop grand dans sommetcentredroit) ==
        exit
     } if
     N n1 add i add
      end
      } def

      /F6 [
     %% coin superieur droit
     [
        0 sommettourdroit
        1 sommettourdroit
        n1 n 1 sub sub sommetcentredroit
        4 n mul 1 sub sommettourdroit
     ]
     %% coin superieur gauche
     [
        n 1 sub sommettourdroit
        n sommettourdroit
        n 1 add sommettourdroit
        n1 1 sub sommetcentredroit
     ]
     %% coin inferieur gauche
     [
        n 2 sub sommetcentredroit
        2 n mul 1 sub sommettourdroit
        2 n mul sommettourdroit
        2 n mul 1 add sommettourdroit
     ]
     %% coin inferieur droit
     [
        3 n mul 1 add sommettourdroit
        0 sommetcentredroit
        3 n mul 1 sub sommettourdroit
        3 n mul sommettourdroit
     ]
     %% bande superieure
     1 1 n 2 sub {
        /i exch def
        [
           i sommettourdroit
           i 1 add sommettourdroit
           n 1 sub n 2 sub mul i add sommetcentredroit
           n 1 sub n 2 sub mul i 1 sub add sommetcentredroit
        ]
     } for
     %% bande inferieure
     1 1 n 2 sub {
        /i exch def
        [
           i 1 sub sommetcentredroit
           i sommetcentredroit
           3 n mul 1 sub i sub sommettourdroit
           3 n mul i sub sommettourdroit
        ]
     } for
     %% descente gauche
     1 1 n 2 sub {
        /i exch def
        [
           n1 1 sub i 1 sub n 1 sub mul sub sommetcentredroit
           n i add sommettourdroit
           n i 1 add add sommettourdroit
           n1 1 sub i n 1 sub mul sub sommetcentredroit
        ]
     } for
     %% descente droite
     1 1 n 2 sub {
        /i exch def
        [
           4 n mul i sub sommettourdroit
           n 1 sub n 1 sub i sub mul sommetcentredroit
           n 1 sub n 2 sub i sub mul sommetcentredroit
           4 n mul i sub 1 sub sommettourdroit
        ]
     } for
     %% bandes interieures
     1 1 n 2 sub {
        /j exch def
        1 1 n 2 sub {
           /i exch def
           [
          n 1 sub j mul i 1 sub add sommetcentredroit
          n 1 sub j mul i add sommetcentredroit
          n 1 sub j 1 sub mul i add sommetcentredroit
          n 1 sub j 1 sub mul i 1 sub add sommetcentredroit
           ]
        } for
     } for

      ] def

      /F2 F1 {{n dup mul n add add} apply} apply def
      /F3 F2 {{n dup mul n add add} apply} apply def
      /F4 F3 {{n dup mul n add add} apply} apply def


      S1 S2 append S3 append S4 append S5 append S6 append {a mulv3d} papply3d
      F1 F2 append F3 append F4 append {{N mod} apply} apply F5 append F6 append
      generesolid
   } ifelse
end
} def

%%%%% ### newparallelepiped ### 
% 14 octobre 2006
/newparallelepiped {
2 dict begin
   /c exch 2 div def
   /b exch 2 div def
   /a exch 2 div def
   /F [
      [0 1 2 3]
      [0 4 5 1]
      [1 5 6 2]
      [2 6 7 3]
      [0 3 7 4]
      [4 7 6 5]
    ] def

    %% tableau des sommets
    /S [
       a     b     c %% 0
       a neg b     c %% 1
       a neg b neg c %% 2
       a     b neg c %% 3
       a     b     c neg %% 4
       a neg b     c neg %% 5
       a neg b neg c neg %% 6
       a     b neg c neg %% 7
    ] def
    S F generesolid
end
} def

%%%%% ### newcylindre ### 
%% syntaxe : z0 r0 z1 newcylindre -> solide
%% syntaxe : z0 r0 z1 {mode} newcylindre -> solide
%% syntaxe : z0 r0 z1 [n1 n2] newcylindre -> solide
%% syntaxe : a b {f} {u} h [n1 n2] newcylindre
/newcylindre {
2 dict begin
   [[/n2 /n1] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode
   2 copy pop xcheck {
      %% cylindre cas general
      /h exch def
      /U exch def
      U normalize3d /u defpoint3d
      /lafonction exch def
      /b exch def
      /a exch def
      /pas b a sub n1 div def
      /vpas h n2 div def
      /S [
         0 1 n2 {
            /j exch def
            0 1 n1 {
               /i exch def
               a i pas mul add lafonction
               u j vpas mul mulv3d addv3d
            } for
         } for
      ] def
      /F [
         0 1 n2 1 sub {
            /j exch def
            0 1 n1 1 sub {
               /i exch def
               [
                  i n1 1 add j mul add 
                  dup 1 add
                  dup n1 1 add add
                  dup 1 sub
               ]
            } for
         } for
      ] def
      
      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      2 copy pop [n2 n1] newtronccone
   } ifelse
end
} def

%% syntaxe : z0 r0 z1 newcylindrecreux -> solide
/newcylindrecreux {
   newcylindre
   dup creusesolid
} def

%%%%% ### newtronccone ### 
%% syntaxe : z0 r0 z1 r1 newtronccone -> solid
/newtronccone {
11 dict begin
   [[/n /N] [1 6] [1 8] [1 10] [3 12] [5 18]] gestionsolidmode

   /r1 exch def
   /z1 exch def
   /r0 exch def
   /z0 exch def
   /dz z1 z0 sub n div def
   /dr r1 r0 sub n div def

   /FE [
      [0 1 N 1 sub {} for]
      [n 1 add N mul 1 sub -1 n N mul {} for]

      0 1 n 1 sub {
      /k exch def
         k N mul 1 add 1 k 1 add N mul 1 sub {
             /i exch def
             [i i 1 sub N i add 1 sub N i add]
         } for
         [k N mul k 1 add N mul 1 sub k 2 add N mul 1 sub k 1 add N mul]
      } for

   ] def

   %% tableau des sommets
   /S [
      n -1 0 {
         /k exch def
         0 1 N 1 sub {
             /i exch def
             360 N idiv i mul cos r0 dr k mul add mul
             360 N idiv i mul sin r0 dr k mul add mul
             z0 dz k mul add
         } for
      } for
   ] def
   S FE generesolid
end
} def

%% syntaxe : z0 r0 z1 r1 newtroncconecreux -> solid
/newtroncconecreux {
   newtronccone
   dup creusesolid
} def

%%%%% ### newcone ### 
%% syntaxe : z0 r0 z1 newcone -> solid
%% syntaxe : z0 r0 z1 {mode} newcone -> solid
%% syntaxe : z0 r0 z1 [n1 n2] newcone -> solid
%% syntaxe : a b {f} {sommet} [n1 n2] newcone -> solid
/newcone {
11 dict begin
   [ [/n /N] [1 6] [1 8] [1 10] [3 12] [5 18] ] gestionsolidmode
   dup xcheck {
      %% cas general
      /sommet exch def
      /lafonction exch def
      /b exch def
      /a exch def

      /pas b a sub N div def
      /S [
         sommet
         0 1 n 1 sub {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               dupp3d sommet vecteur3d j n div mulv3d addv3d
            } for
         } for
         1 1 n {
            /j exch def
            0 1 N {
               /i exch def
               a i pas mul add lafonction
               sommet vecteur3d j n div mulv3d sommet addv3d
            } for
         } for
      ] def

      /F [
         %% les etages inferieurs
         0 1 n 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
         %% dernier etage inferieur
         1 1 N {
            /i exch def
            [
               i N 1 add n 1 sub mul add
               dup 1 add
               0
            ]
         } for
         %% premier etage superieur
         1 1 N {
            /i exch def
            [
               i N 1 add n mul add
               dup 1 add
               0
               exch
            ]
         } for
         %% les etages superieurs
         n 1 n 2 mul 2 sub {
            /j exch def
            1 1 N {
               /i exch def
               [
                  i j N 1 add mul add
                  dup 1 add
                  dup N add 1 add
                  dup 1 sub
               ]
            } for
         } for
      ] def

      S F generesolid
%      dup videsolid
   } {
      %% cylindre de revolution
      /z1 exch def
      /r0 exch def
      /z0 exch def
      /dz z1 z0 sub n div def
      /dr r0 n div def
   
      /F [
         %% la base
         [N 1 sub -1 0 {} for]
         %% le dernier etage
         n 1 sub N mul 1 add 1 n N mul 1 sub {
              /i exch def
              [i 1 sub i n N mul]
         } for
         [n N mul 1 sub n 1 sub N mul n N mul]
         %% les autres etages
         0 1 n 2 sub {
            /j exch def
            0 N j mul add 1 N N j mul add 2 sub {
               /i exch def
               [i i 1 add dup N add dup 1 sub]
            } for
            [N N j mul add 1 sub N j mul dup N add dup N add 1 sub]
         } for
      ] def
   
      %% tableau des sommets
      /S [
         %% etage no j (in [1; n])
         0 1 n 1 sub {
            /j exch def
            0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r0 dr j mul sub mul
                360 N idiv i mul sin r0 dr j mul sub mul
                z0 dz j mul add
            } for
         } for
         0 0 z1
      ] def
      S F generesolid
   } ifelse
end
} def

%% %% syntaxe : z0 r0 z1 newconecreux -> solid
 /newconecreux {
    newcone
    dup 0 solidrmface
    dup videsolid
 } def

%%%%% ### newtore ### 
%% syntaxe : r R newtore -> solid
/newtore {
10 dict begin
   [[/n1 /n2] [4 5] [6 10] [8 12] [9 18] [18 36]] gestionsolidmode
   /n2 n2 3 max store
   /n1 n1 2 max store
   /R exch def
   /r exch def
   /S [
         0 1 n1 1 sub {
            /i exch def
            360 n1 div i mul cos r mul R add
            360 n1 div i mul sin r mul
         } for
      ]
   def
   S [n2] newanneau
end
} def

%%%%% ### newprisme ### 
%% syntaxe : array z0 z1 newprisme -> solid d axe (O, u),
/newprismedroit {
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   0 0 1 [N] newprisme
} def

%% syntaxe : array z0 z1 u newprisme -> solid d axe (O, u),
%% ou array tableau de points 2d
/newprisme {
7 dict begin
   [[/N] [1] [1] [1] [3] [6]] gestionsolidmode
   dup 0 eq {
      (Error : 3eme composante nulle dans le vecteur pour newprisme) ==
      quit
   } if
   /u defpoint3d
   /z1 exch def
   /z0 exch def
   %% N = nb d etages
   /table exch def
   %% n = indice du dernier point
   /n table length 2 idiv 1 sub def
   %% vecteur de translation
   u
   z1 z0 sub u norme3d div
   mulv3d /v defpoint3d

   %% tableau des sommets
   /S [
      0 1 N {
         /j exch def
         0 1 n {
             /i exch def
             table i getp
             z0
             v N j sub N div mulv addv3d
         } for
      } for
   ] def

   /F [ 
      %% face superieure
      [0 1 n {} for]
      %% base
      [N 1 add n 1 add mul 1 sub -1 N n 1 add mul {} for]
      %% faces etage
      1 1 N {
         /j exch def
         1 1 n {
             /i exch def
             [i                   j 1 sub n 1 add mul add
              i 1 sub             j 1 sub n 1 add mul add
              n 1 add i add 1 sub j 1 sub n 1 add mul add
              n 1 add i add       j 1 sub n 1 add mul add]
         } for
         [0            j 1 sub n 1 add mul add
         n             j 1 sub n 1 add mul add
         2 n mul 1 add j 1 sub n 1 add mul add
         n 1 add       j 1 sub n 1 add mul add]
     } for
   ] def

   S F generesolid
end
} def

%%%%% ### newsphere ### 
%% syntaxe : r option newsphere -> solid
/newsphere {
2 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode
   -90 90 [K N] newcalottesphere
end
} def

%% syntaxe : r phi theta option newcalottesphere -> solid
/newcalottesphere {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
end
} def

%% syntaxe : r phi theta option newcalottespherecreuse -> solid
/newcalottespherecreuse {
6 dict begin
   [[/K /N] [6 6] [8 8] [10 12] [16 12] [16 36]] gestionsolidmode

   %% test de beta (ex-theta)
   dup 90 eq {
      /beta exch def
      /idebut 1 def
   } {
      /beta exch 80 min -80 max def
      /idebut 0 def
   } ifelse
   %% test de alpha (ex-phi)
   dup -90 eq {
      /alpha exch def
   } {
      /alpha exch beta min -80 max def
   } ifelse
   /r exch def
   beta 90 eq {
       alpha -90 eq {
           /ifin K def
          /db alpha beta sub K 1 add div def
       } {
           /ifin K def
          /db alpha beta sub K div def
       } ifelse
   } {
       alpha -90 eq {
           /ifin K 1 sub def
          /db alpha beta sub K div def
       } {
           /ifin K 1 sub def
          /db alpha beta sub K 1 sub div def
       } ifelse
   } ifelse

   %% nombre de sommets -2
   /nb N K mul def

   %% tableau des sommets
   /S [
       idebut 1 ifin {
           /j exch def
           /phi beta j db mul add def
           phi cos r mul /r_tmp exch def
           0 1 N 1 sub {
                /i exch def
                360 N idiv i mul cos r_tmp mul
                360 N idiv i mul sin r_tmp mul
                phi sin r mul
            } for
       } for
      0 0 r neg
      0 0 r
   ] def

   /F [
     %% calotte inferieure
     alpha -90 eq {
         1 1 N 1 sub {
         /i exch def
            [
                nb
                nb i sub
                nb i 1 add sub
            ]
         } for
         [nb nb N sub nb 1 sub]
     } {
%        [nb 1 sub -1 nb N sub {} for ]
     } ifelse

     %% calotte superieure
     beta 90 eq {
         0 1 N 1 sub {
            /i exch def
             [i i 1 add N mod N K mul 1 add]
         } for
      } {
%         [0 1 N 1 sub {} for]
      } ifelse

     1 1 K 1 sub {
          /j exch def
       [
           j N mul
           j N mul 1 add
           j 1 sub N mul 1 add
           j 1 sub N mul
       ]
       N 2 sub {dup {1 add} apply} repeat
       [
           j 1 add N mul 1 sub
           j N mul
           j 1 sub N mul
           j N mul 1 sub
       ]
    } for
   ] def

   S F generesolid
   dup videsolid
end
} def

%%%%% ### newanneau ### 
%% syntaxe : array n newanneau --> solid
%% syntaxe : array {mode} newanneau --> solid
%% ou array est un tableau de points de R^2 et n un nombre entier positif
/newanneau {
10 dict begin
   dup isnum {
      /n exch def
      [n]
   } if
   [[/n2] [6] [12] [24] [32] [36]] gestionsolidmode
   /n2 n2 3 max store
   %% on plonge la section dans R^3 par projection sur yOz
   /S1 exch {0 3 1 roll} papply def
   %% nombre de sommets
   /n1 S1 length 3 idiv def

   /S S1
      n2 {
         duparray
         {0 0 360 n2 div rotateOpoint3d} papply3d
      } repeat
      n2 {append} repeat
   def

   /F [
      0 1 n2 1 sub {
         /j exch def
         n1 j mul 1 j 1 add n1 mul 2 sub {
            /i exch def
            [i 1 add i dup n1 add i n1 1 add add]
         } for
         [n1 j mul j 1 add n1 mul 1 sub j 2 add n1 mul 1 sub j 1 add n1 mul]
      } for
   ] def

   S F generesolid
end
} def

%%%%% ### newvecteur ### 
%% syntaxe : x y z newvecteur
%% syntaxe : x y z array newvecteur
/newvecteur {
4 dict begin
   dup isarray {
      /table exch def
      /h@uteur table 1 get def
      /r@y@n table 0 get def
   } {
      /h@uteur .3 def
      /r@y@n .1 def
   } ifelse
   /A defpoint3d
   %%Sommets
   /S [0 0 0 A] def
   /F [
      [0 1]
   ] def
   S F generesolid
   [ A ]
   normalvect_to_orthobase
   /imK defpoint3d
   /imJ defpoint3d
   /imI defpoint3d

   A norme3d /z exch h@uteur sub def 
   0 r@y@n h@uteur [1 8] newcone
   dup (noir) outputcolors
   {0 0 z translatepoint3d} solidtransform
   {imI imJ imK transformpoint3d} solidtransform
   solidfuz
end
} def

%%%%% ### readsolidfile ###
%% syntaxe : str readsolidfile -> solid
/readsolidfile {
1 dict begin
   /str exch def
   [str (-sommets.dat) append run] 
   [str (-faces.dat) append run]
   generesolid
   dup [str (-couleurs.dat) append run] solidputfcolors
   dup [str (-io.dat) append run] solidputinouttable
end
} def

%%%%% ### writesolidfile ###
%% syntaxe : solid str writesolidfile -> -
/writesolidfile {
10 dict begin
   /str exch def
   /solid exch def
   solid issolid not {
      (Error : mauvais type d argument dans writesolidfile) ==
      quit
   } if
   str (-sommets.dat) append (w) file /lefichiersommets exch def
   str (-faces.dat) append (w) file /lefichierfaces exch def
   str (-couleurs.dat) append (w) file /lefichiercouleurs exch def
   str (-io.dat) append (w) file /lefichierio exch def

   /S solid solidgetsommets def
   0 1 S length 3 idiv 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichiersommets x chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets y chaine cvs writestring
      lefichiersommets 32 write %% espace
      lefichiersommets z chaine cvs writestring
      lefichiersommets 10 write %% CR
   } for
   lefichiersommets closefile

   /F solid solidgetfaces def
   0 1 F length 1 sub {
      /i exch def
      /Fi solid i solidgetface def
      lefichierfaces 91 write %% [
      0 1 Fi length 1 sub {
         /j exch def
         lefichierfaces Fi j get chaine cvs writestring
         lefichierfaces 32 write %% espace
      } for
      lefichierfaces 93 write %% ]
      lefichierfaces 10 write %% CR
   } for
   lefichierfaces closefile

   /C solid solidgetfcolors def
   0 1 C length 1 sub {
      /i exch def
      lefichiercouleurs 40 write %% (
      lefichiercouleurs C i get writestring
      lefichiercouleurs 41 write %% )
      lefichiercouleurs 10 write %% CR
   } for
   lefichiercouleurs closefile

   /IO solid solidgetinouttable def
   0 1 3 {
      /i exch def
      lefichierio IO i get chaine cvs writestring
      lefichierio 32 write %% space
   } for
   lefichierio closefile
end
} def

%%%%% ### writeobjfile ###
%% syntaxe : solid str writeobjfile -> -
/writeobjfile {
10 dict begin
   /str exch (.obj) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeobjfile) ==
      quit
   } if
   /n solid solidnombresommets def
   str (w) file /lefichier exch def
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier (v ) writestring
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   /n solid solidnombrefaces def
   0 1 n 1 sub {
      /i exch def
      lefichier (f ) writestring
      /F solid i solidgetface {1 add} apply def
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### writeofffile ###
%% syntaxe : solid str writeobjfile -> -
/writeofffile {
12 dict begin
   /str exch (.off) append def
   /solid exch def
   solid issolid not {
      (Erreur : mauvais type d argument dans writeofffile) ==
      quit
   } if
   /n solid solidnombresommets def
   /nf solid solidnombrefaces def
   str (w) file /lefichier exch def
   lefichier (OFF) writestring
   lefichier 10 write %% CR
   lefichier n chaine cvs writestring
   lefichier 32 write %% espace
   lefichier nf chaine cvs writestring
   lefichier 32 write %% espace
   lefichier 0 chaine cvs writestring
   lefichier 10 write %% CR
   0 1 n 1 sub {
      /i exch def
      solid i solidgetsommet
      /z exch def
      /y exch def
      /x exch def
      lefichier x chaine cvs writestring
      lefichier 32 write %% espace
      lefichier y chaine cvs writestring
      lefichier 32 write %% espace
      lefichier z chaine cvs writestring
      lefichier 10 write %% CR
   } for
   0 1 nf 1 sub {
      /i exch def
      /F solid i solidgetface def
      lefichier F length chaine cvs writestring
      lefichier 32 write %% espace
      F {
         lefichier exch
         chaine cvs writestring
         lefichier  32  write %% espace
      } apply
      lefichier  10  write %% CR
   } for
   lefichier closefile
end
} def

%%%%% ### newobjfile ###
/newobjfile {
3 dict begin
   /objfilename exch (.obj) append def
   /v {} def
   /ok true def
   /f {
       ok {
        %% 1ere fois
           ] %% ferme les sommets
        [ [ %% ouvre les faces
        /ok false store
       } {
        %% les autres fois
           ] %% ferme la face
        [ %% ouvre la nouvelle
       } ifelse
   } def
   [ 0 0 0 %% sommet fantome pour respecter l'indexation (a partir de l'indice 1)
   objfilename run
   ]]
   /F exch def
   /S exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newofffile ###
/newofffile {
3 dict begin
   /str 35 string def
   /offfilename exch (.off) append def
   offfilename (r) file
   /offfile exch def
   offfile str readline pop pop
   offfile str readline pop
   numstr2array
   dup 0 get /ns exch def
   1 get /nf exch def
   [ns {
      offfile str readline pop numstr2array aload pop
%      3 1 roll
   } repeat]
   /S exch def
   [nf {
      [
      offfile str readline pop numstr2array
      /table exch def
      1 1 table length 1 sub {
         /i exch def
         table i get
      } for
      ]
   } repeat]
   /F exch def

   S F generesolid
%   dup videsolid
end
} def

%%%%% ### newtube ###
 /tub@dernierk1 [1 0 0] def
 /tub@dernierk2 [0 1 0] def
 /tub@dernierk3 [0 0 1] def

/inittube {
2 dict begin
   normalize3d /vect3 defpoint3d
   normalize3d /vect2 defpoint3d
   normalize3d /vect1 defpoint3d
   vect1 norme3d 0 eq {
      vect2 vect3 vectprod3d /vect1 defpoint3d
   } if
   vect2 norme3d 0 eq {
      vect3 vect1 vectprod3d /vect2 defpoint3d
   } if
   vect3 norme3d 0 eq {
      vect1 vect2 vectprod3d /vect3 defpoint3d
   } if
   /tub@dernierk1 [vect1] store
   /tub@dernierk2 [vect2] store
   /tub@dernierk3 [vect3] store
end
} def
 
%% syntaxe : tmin tmax (f) array r newtube -> solid
%% array = [K N]
/newtube {
10 dict begin
   /table exch def
   /K table 0 get def %% nb d etages
   /N table 1 get def %% nb de points sur le perimetre
   /@r exch def       %% le rayon du tube
   /str exch def
   /lafonction str cvx def
   /laderivee str (') append cvx def
%%   /laderivee2nd str ('') append cvx def
   /tmax exch def
   /tmin exch def
   /pas tmax tmin sub K 1 sub div def

   %% definition des sommets
   [
   /@k 0 def
   K {
      /a0 tmin @k pas mul add def
   
      %% definition du repere de Frenet (k1, k2, k3) au point f(a)
      a0 lafonction /M defpoint3d

      str (') append cvlit where {
         pop 
         a0 laderivee normalize3d /k1 defpoint3d
%         pop /avecderiv true def
      } {
         M a0 pas 100 div add lafonction vecteur3d normalize3d /k1 defpoint3d
%         /avecderiv false
      } ifelse

      k1 baseplannormal /K3 defpoint3d /K2 defpoint3d
%      a0 laderivee2nd normalize3d /k2 defpoint3d

      %% projete orthogonal du dernier rayon sur le plan actuel
      %% (normal a la vitesse)
      K2 tub@dernierk2 aload pop K2 scalprod3d mulv3d 
      K3 tub@dernierk2 aload pop K3 scalprod3d mulv3d addv3d /k2 defpoint3d
%      M k1 K2 K3 dessinebase
      k1 norme3d 0 eq {
         tub@dernierk1 aload pop /k1 defpoint3d
      } {
         /tub@dernierk1 [k1] store
      } ifelse
      k2 norme3d 0 eq {
         tub@dernierk2 aload pop /k2 defpoint3d
      } {
         /tub@dernierk2 [k2] store
      } ifelse
      k1 k2 vectprod3d normalize3d /k3 defpoint3d
      k3 norme3d 0 eq {
          tub@dernierk3 aload pop /k3 defpoint3d
      } {
         /tub@dernierk3 [k3] store
      } ifelse
      k3 k1 vectprod3d normalize3d /k2 defpoint3d
%%      M k1 k2 k3 dessinebase
      /tub@dernierk2 [k2] store
      /@n 360 N div def %% le pas angulaire
      0 @n 360 @n sub {
         /@i exch def
         M
         k2 @i cos @r mul mulv3d addv3d
         k3 @i sin @r mul mulv3d addv3d
      } for
      /@k @k 1 add store
   } repeat
   ]

   dup length 3 idiv /nb exch def
   %% definition des faces
   [
      %% face de depart
      [N 1 sub -1 0 {} for]
      %% face d arrivee
      [nb 1 sub N 1 sub {dup 1 sub} repeat] reverse
   
      %% les etages
      /j 0 def
      K 1 sub {
         0 1 N 1 sub {
            /i exch def
            [
               i                   N j mul add
               i 1 add N mod       N j mul add
               i 1 add N mod N add N j mul add
               i N add             N j mul add
            ]
         } for
         /j j 1 add store
      } repeat
   ]
   generesolid
end
} def

%%%%% ### newcourbe ###
%% syntaxe : a b {f} array newcourbe --> solid
/newcourbe {
10 dict begin
   dup xcheck not {
      0 get /n exch def
   } {
      /n 80 def
   } ifelse
   /l@f@nct exch def
   /b exch def
   /a exch def
   /pas b a sub n 1 sub div def
   /S [
   0 1 n 1 sub {
      /@i exch def
      a @i pas mul add
      l@f@nct
      pstrickactionR3
   } for
   ] def
   /@F [
      0 1 n 2 sub {
         /@i exch def
         [@i @i 1 add]
      } for
   ] def
   S @F generesolid
end
} def

%%%%% ### baseplannormal ###
%% syntaxe : x y z baseplannormal -> x1 y1 z1 x2 y2 z2
/baseplannormal {
5 dict begin
   /K defpoint3d
   1 0 0 K vectprod3d normalize3d /U defpoint3d
   U norme3d 0 eq {
      0 1 0 K vectprod3d normalize3d /U defpoint3d
   } if
   K U vectprod3d normalize3d /V defpoint3d
   U V
end
} def

%%%%% ### fin insertion ###

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%                                                    %%%%
%%%%      fin insertion librairie jps                   %%%%
%%%%                                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%          gestion de chaine de caracteres           %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/Times-Roman findfont 
dup length dict begin
   {
   1 index /FID ne 
      {def}
      {pop pop} 
   ifelse
   } forall
   /Encoding ISOLatin1Encoding def
   currentdict
end
/Times-Roman-ISOLatin1 exch definefont pop

/setTimesRoman {
   /Times-Roman-ISOLatin1 findfont 
   fontsize scalefont 
   setfont
} def

/setTimes {
   setTimesRoman
} def

%% syntaxe : string x y cctext
/cctext {
5 dict begin
   /y exch def
   /x exch def
   /str exch def
   str stringwidth
   /wy exch def
   /wx exch def
   gsave
      x y smoveto
      wx -2 div wy -2 div rmoveto
      str show
   grestore
end
} def

/dbtext {gsave newpath dbtext_ Fill grestore} def
/dctext {gsave newpath dctext_ Fill grestore} def
/dltext {gsave newpath dltext_ Fill grestore} def
/drtext {gsave newpath drtext_ Fill grestore} def

/bbtext {gsave newpath bbtext_ Fill grestore} def
/bctext {gsave newpath bctext_ Fill grestore} def
/bltext {gsave newpath bltext_ Fill grestore} def
/brtext {gsave newpath brtext_ Fill grestore} def

/cbtext {gsave newpath cbtext_ Fill grestore} def
/cctext {gsave newpath cctext_ Fill grestore} def
/cltext {gsave newpath cltext_ Fill grestore} def
/crtext {gsave newpath crtext_ Fill grestore} def

/ubtext {gsave newpath ubtext_ Fill grestore} def
/uctext {gsave newpath uctext_ Fill grestore} def
/ultext {gsave newpath ultext_ Fill grestore} def
/urtext {gsave newpath urtext_ Fill grestore} def


%% syntaxe : str x y show_dim --> str x y llx lly wx wy 
%% attention, doit laisser la pile intacte
/show_dim {
   3 copy pop pop
   newpath
      0 0 moveto
      true charpath flattenpath pathbbox 
   closepath
   newpath
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour PSTricks               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% les 3 procedures utilisees pour transformer les depots de AlgToPs en nombres
/pstrickactionR3 { 
3 dict begin 
  /len@3 exch def 
  /len@2 exch def 
  /len@1 exch def 
  len@1 exec 
  len@2 exec 
  len@3 exec 
end 
} def 

/pstrickactionR2 {
   exec exch exec exch
} def

/pstrickactionR {
   exec
} def

/gere_pst-deffunction {
   counttomark
   dup 1 eq {
      pop
      pstrickactionR
      ] aload pop
   } {
      2 eq {
         pstrickactionR2
         ] aload pop
      } {
         pstrickactionR3
         ] aload pop
      } ifelse
   } ifelse
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%             procedures pour \psSolid               %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/all (all) def

/draw {drawsolid} def
/draw* {drawsolid*} def
/draw** {drawsolid**} def
/writeobj {solidfilename writeobjfile} def
/writesolid {solidfilename writesolidfile} def
/writeoff {solidfilename writeofffile} def
/none {pop} def
/vecteur_en_c@urs false def

/gere_pstricks_color_inout {
   gsave
      dup  [fillincolor] (setrgbcolor) astr2str
         [fillcolor] (setrgbcolor) astr2str inoutputcolors
   grestore
} def

/gere_pstricks_color_out {
   gsave
      dup  [fillcolor] (setrgbcolor) astr2str outputcolors
   grestore
} def

/gere_pstfont {
   fontsize mul setfontsize
   %setTimes
   PSfont dup /Symbol ne isolatin and {
      /ISO-Font ReEncode /ISO-Font
   } if
   findfont fontsize scalefont setfont
} def

/gere_pstricks_opt {
%   /CourbeR2 {CourbeR2+} def
   1 gere_pstfont
   linecolor
   linestyle
   solidlinewidth setlinewidth
   solidtrunc length 0 ne {
      solidtrunc 0 get isstring {
         dup trunccoeff solidtronque
      } {
         dup solidtrunc trunccoeff solidtronque
      } ifelse
   } if
   solidgeode {
      1 newgeode
   } if
   soliddualreg {
      dualpolyedreregulier
   } if
   chanfrein {
      dup chanfreincoeff solidchanfreine
   } if
   RotX 0 ne RotY 0 ne or RotZ 0 ne or {
      {RotX RotY RotZ rotateOpoint3d} solidtransform
   } if
   CX 0 ne CY 0 ne or CZ 0 ne or {
      {CX CY CZ translatepoint3d} solidtransform
   } if
   plansection length 0 gt {
      0 1 plansection length 1 sub {
         /i exch def
         plansection i get solidplansection
         dup 0 solidrmface
      } for
   } if
   /rmfaces rmfaces bubblesort reverse store
   0 1 rmfaces length 1 sub {
      /i exch def
      dup rmfaces i get solidrmface
   } for
   tx@Dict /pst-transformoption known {
      dup {pst-transformoption} solidtransform 
   } if
   solidaffinage length 0 ne {
      %% si on affine, il faut colorier avant
      activationgestioncouleurs {
         gere_pstricks_color_out
      } if
      solidaffinage 0 get isstring {
         dup affinagecoeff
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } {
         dup affinagecoeff solidaffinage
         /solidfcolor where {
            pop
            solidfcolor
         } if
         affinagerm solidaffine
      } ifelse
      %% et il faut evider et coloriier l'interieur si necessaire
      solidhollow {
         dup videsolid
         activationgestioncouleurs {
            gsave
               dup  [fillincolor] (setrgbcolor) astr2str inputcolors
            grestore
         } if
      } if
      /activationgestioncouleurs false def
   } if
   tx@Dict /plansepare known {
      plansepare solidplansepare
      tx@Dict /plansepare undef
      tx@Dict /solidname known {
         solidname (1) append cvlit exch def
         dup solidname (0) append cvlit exch def
         %%
         solidname (1) append cvx exec
         solidhollow {
            dup videsolid
         } if
         activationgestioncouleurs {
            dup solidwithinfaces {
               gere_pstricks_color_inout 
            } {
               gere_pstricks_color_out
            } ifelse
         } if
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
         pop
         tx@Dict /solidname undef
      } {
         /solid1 exch def
         /solid2 exch def
      } ifelse
   } if
   solidhollow {
      dup videsolid
   } if
   activationgestioncouleurs {
      zcolor length 0 ne {
         dup zcolor tablez solidcolorz 
      } {
         dup solidwithinfaces {
            gere_pstricks_color_inout 
         } {
            gere_pstricks_color_out
         } ifelse
         solidinouthue length 0 gt { 
            dup solidinouthue solidputinouthuecolors 
         } {
            solidhue length 0 gt {
               dup solidhue solidputhuecolors
            } if
            solidinhue length 0 gt {
               dup solidinhue solidputinhuecolors
            } if
         } ifelse
      } ifelse
   } {
      /activationgestioncouleurs true def
   } ifelse

   0 1 fcol length 2 idiv 1 sub {
      /i exch def 
      dup fcol 2 i mul get fcol 2 i mul 1 add get solidputfcolor
   } for
   vecteur_en_c@urs not {
      /lightsrc where {pop solidlightOn} if
   } {
      /vecteur_en_c@urs false def
   } ifelse
   dup action cvx exec
   noir
   solidnumf length 0 ne {
      solidnumf 0 get isstring {
         dup projectionsifacevisible solidnumfaces
      } {
         dup solidnumf projectionsifacevisible solidnumfaces
      } ifelse
   } if
   solidshow length 0 ne {
      solidshow 0 get isstring {
         dup solidshowsommets
      } {
         dup solidshow solidshowsommets
      } ifelse
   } if
   solidnum length 0 ne {
      solidnum 0 get isstring {
         .8 gere_pstfont
         dup solidnumsommets
      } {
         dup solidnum solidnumsommets
      } ifelse
   } {
      %% pop
   } ifelse
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def

/pst-octahedron {
   a newoctaedre
   gere_pstricks_opt
} def

/pst-dodecahedron {
   a newdodecaedre
   gere_pstricks_opt
} def

/pst-icosahedron {
   a newicosaedre
   gere_pstricks_opt
} def

/pst-cube {
   a
   ngrid length 1 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcube 
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-parallelepiped {
   a b c
   newparallelepiped
   gere_pstricks_opt
} def

/pst-tetrahedron {
   r newtetraedre
   gere_pstricks_opt
} def

/pst-tore {
   r0 r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtore
   gere_pstricks_opt
} def

/pst-sphere {
   % rayon
   % mode
  %   r {Mode} newsphere
   r
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newsphere
   gere_pstricks_opt
} def
%
/pst-cylindre {
   /save-cylinderhollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {axe} h ngrid newcylindre
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      newcylindre
      solidhollow {
         dup creusesolid
      } if
   } ifelse
   gere_pstricks_opt
   /solidhollow save-cylinderhollow store
} def
%
/pst-cylindrecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcylindre
   dup creusesolid
   gere_pstricks_opt
} def

/pst-cone {
   /save-conehollow solidhollow def
   tx@Dict /function known {
      range aload pop function cvx {origin} ngrid newcone
      tx@Dict /function undef
      /solidhollow true def
   } {
      % rayon
      % mode
      0 r h
      ngrid length 2 eq {
         ngrid
      } {
         {Mode}
      } ifelse
      solidhollow {
         newconecreux
      } {
         newcone
      } ifelse
   } ifelse
   gere_pstricks_opt
   /solidhollow save-conehollow store
} def

/pst-tronccone {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newtroncconecreux
   } {
      newtronccone
   } ifelse
   gere_pstricks_opt
} def

/pst-troncconecreux {
   % rayon
   % mode
   0 r0 h r1
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newtroncconecreux
   gere_pstricks_opt
} def

/pst-conecreux {
   % rayon
   % mode
   0 r h
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newconecreux
   gere_pstricks_opt
} def

/pst-anneau {
   [ section ]
   ngrid length 1 ge {
      [ngrid 0 get]
   } {
      [24]
   } ifelse
   newanneau
   gere_pstricks_opt
} def


/pst-prisme {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base decal rollparray
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   solidhollow {
      dup creusesolid
   } if
   gere_pstricks_opt
} def

/pst-prismecreux {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   0 h axe
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newprisme
   dup creusesolid
   gere_pstricks_opt
} def

/pst-grille {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   newgrille
   gere_pstricks_opt
} def

%% syntaxe : array N h u newruban -> solid d axe (O, u),
/pst-ruban {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   h axe 
   ngrid length 1 ge {
      [ngrid 0 get]
   } if
   newruban
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottesphere {
   % rayon
   % mode
   % r phi theta option newcalottesphere
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   solidhollow {
      newcalottespherecreuse
   } {
      newcalottesphere
   } ifelse
   gere_pstricks_opt
} def

%% syntaxe : r phi option newcalottesphere -> solid
/pst-calottespherecreuse {
   % rayon
   % mode
   % r phi theta option newcalottespherecreuse
   r
   phi theta
   ngrid length 2 eq {
      ngrid
   } {
      {Mode}
   } ifelse
   newcalottespherecreuse
   gere_pstricks_opt
} def

/pointtest{2 2 2} def

/pst-face {
   % tableau des points de la base
   % h hauteur du prisme
   % axe : vecteur direction de l axe
   base
   solidbiface {
      newbiface
   } {
      newmonoface 
   } ifelse
   gere_pstricks_opt
} def

/pst-Surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   {f} newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-Surface* {
   r
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   {f} newsurface*
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-surface {
   base
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } ifelse
   } ifelse
   { function cvx exec } newsurface
   solidbiface {
      dup videsolid
   } if
   gere_pstricks_opt
} def

/pst-polygoneregulier {
   r ngrid 0 get
   newpolreg
   solidbiface {
   } {
      dup 1 solidrmface
   } ifelse
   gere_pstricks_opt
} def

/pst-fusion {
1 dict begin
   /activationgestioncouleurs false def
   /n base length def
   base aload pop n 1 sub {solidfuz} repeat
   gere_pstricks_opt
end
} def

/pst-new {
   sommets faces
   generesolid
%%    solidhollow {
%%       dup videsolid
%%    } if
   gere_pstricks_opt
} def

/pst-courbe {
   solidlinewidth setlinewidth
   r 0 eq {
      range aload pop function cvx [resolution] newcourbe
      gere_pstricks_opt
   } {
      range aload pop function r
      ngrid length 2 lt {
         [300 4]
      } {
         ngrid
      } ifelse
      newtube
      gere_pstricks_opt %% r function [36 12] newtube
   } ifelse
} def
%
/pst-surfaceparametree {
   base aload pop
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurfaceparametree
   dup videsolid
   gere_pstricks_opt
   tx@Dict /function undef
} def
%
/pst-surface* {
   r
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } {
      ngrid length 1 eq {
         [ngrid 0 get dup]
      } if
   } ifelse
   { function cvx exec } newsurface*
   dup videsolid
   gere_pstricks_opt
} def

/pst-vecteur {
gsave
   /activationgestioncouleurs false def
   /vecteur_en_c@urs true def
   solidlinewidth setlinewidth
   2 setlinejoin
   1 setlinecap
   linecolor
   linestyle
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
   args definition cvx exec newvecteur
   dup
   gsave
      [linecolor currentrgbcolor] ( ) astr2str (setrgbcolor) append 
      outputcolors
   grestore
   gere_pstricks_opt
grestore
} def

%/pst-vect- {} def
%/pst-vect-2points {vecteur3d} def
/pst-line {
   gsave
      linestyle 
      linecolor
      [args] ligne3d
   grestore
} def

/pst-objfile {
   solidfilename newobjfile
   gere_pstricks_opt
} def

/pst-offfile {
   solidfilename newofffile
   gere_pstricks_opt
} def

/pst-datfile {
   solidfilename readsolidfile
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-plantype {
%   args definition
   args (pst-plan-) definition append cvx exec
   dup phi rotateplan
   base length 4 eq {
      dup base planputrange
   } if
   origin eqpl@n pointeqplan 0 eq {
      dup origin planputorigine
   } if
   ngrid length 0 ne {
      dup ngrid planputngrid
   } if
   tx@Dict /solidname known {
      solidname cvlit exch bind def
      tx@Dict /solidname undef
   } {
      pop
   } ifelse
} def
/pst-plan- {pst-plan-plantype} def

%x0 y0 z0 [normalvect] norm2plan
/pst-plan-plantype {
   dup plan2eq /eqpl@n exch def
   /plan-@k true def
} def

/pst-plan {
%   args definition
   args (pst-plan-) definition append cvx exec
   /pl@n-en-cours true def
   definition length 0 ne {
%   plan-@k not {
      dup
      base 0 get base 1 get lt
      base 2 get base 3 get lt and {
         base
      } {
         [-3 3 -2 2] %pop base %aload pop boum
      } ifelse
      planputrange
      origin eqpl@n pointeqplan 0 eq {
         dup origin planputorigine
      } if
      CX isreal
      CX 0 eq and
      CY isreal and
      CY 0 eq and
      CZ isreal and
      CZ 0 eq and not {
         dup CX CY CZ planputorigine
      } if
      /CX 0. def
      /CY 0. def
      /CZ 0. def
      ngrid length 0 ne {
         dup ngrid planputngrid
      } if
   } if
%   dup RotX RotY RotZ rotateOplan
   dup phi rotateplan
   /l@pl@n exch def
   tx@Dict /solidname known {
      l@pl@n solidname cvlit exch bind def
      /solidname solidname (_s) append store
   } if
   l@pl@n newplan
   gere_pstricks_opt
   /pl@n-en-cours false def
%   action ==
%   noir
   l@pl@n RotX RotY RotZ rotateOplan
%   l@pl@n CX CY CZ plantranslate
%   fontsize setfontsize
%   setTimes
   1 gere_pstfont
   solidplanmarks {l@pl@n projectionsifacevisible planmarks} if
   solidplangrid {linecolor l@pl@n projectionsifacevisible planquadrillage} if
   solidshowbase {l@pl@n projectionsifacevisible planshowbase} if
   solidshowbase3d {l@pl@n projectionsifacevisible planshowbase3d} if
} def


/pst-plan-normalpoint {
   /plan-@k false def
   norm2plan
   dup plan2eq /eqpl@n exch def
} def

/pst-plan-equation {
   /plan-@k false def
   dup isarray {
      dup /eqpl@n exch def
   } {
      2 copy pop /eqpl@n exch def
   } ifelse
   eq2plan 
} def

/pst-plan-solidface {
   /plan-@k false def
   solidface2plan
   CX isreal
   CX 0 eq and
   CY isreal and
   CY 0 eq and
   CZ isreal and
   CZ 0 eq and not {
      dup CX CY CZ planputorigine
   } if
   
%   dup plangetrange aload pop boum
%   dup origin planputorigine
   dup plan2eq /eqpl@n exch def
} def

/pst-geode {
   ngrid aload pop newgeode
   gere_pstricks_opt
} def

/pst-load {
   solidloadname 
%   /activationgestioncouleurs false def
   gere_pstricks_opt
} def

/pst-point {
gsave
   linecolor
   1 gere_pstfont
   action (none) eqstring not {
      args definition cvx exec point3d
   } if
   texte args definition cvx exec pos (text3d) append cvx exec
   tx@Dict /solidname known {
      args definition cvx exec
      solidname cvlit defpoint3d
      tx@Dict /solidname undef
   } if
grestore
} def

%% syntaxe : alpha beta r h newpie --> solid
/pst-pie {
   phi theta r h 
   ngrid length 2 ge {
      [ngrid 0 get ngrid 1 get]
   } if
   newpie
   gere_pstricks_opt
} def

/pst-trigospherique {
3 dict begin
gsave
   solidlinewidth setlinewidth
   linecolor
   linestyle
   args definition cvx exec
grestore
end
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%         procedures pour \psProjection              %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/gere_pstricks_proj_opt {
      /planprojpst where {
         pop
         planprojpst projectionsifacevisible projpath
%        /planprojpst where pop /planprojpst undef
      } {
         /solidprojname where {
            /solidprojname get noface phi  
            xorigine 0 eq
            yorigine 0 eq and
            zorigine 0 eq and 
            xorigine isinteger not and
            yorigine isinteger not and
            yorigine isinteger not and {
            } {
               [xorigine yorigine zorigine] (                 ) astr2str 
            } ifelse
            projectionsifacevisible solidprojpath
         } {
            xorigine yorigine zorigine [ normale ] projectionsifacevisible planprojpath
         } ifelse
      } ifelse
} def

/proj-pst-chemin {
   solidlinewidth setlinewidth
   1 dict begin
   newpath
      /cercle {cercle_} def
      path
      linecolor
      gere_pstricks_proj_opt
   end
} def

/proj-pst-courbeR2 {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop { function cvx exec } CourbeR2_
      gere_pstricks_proj_opt
} def

/proj-pst-courbe {
   l@pl@n plangetrange aload pop 
   setyrange setxrange
   newpath
      xmin ymin l@pl@n pointplan smoveto
      xmin ymax l@pl@n pointplan slineto
      xmax ymax l@pl@n pointplan slineto
      xmax ymin l@pl@n pointplan slineto
      xmin ymin l@pl@n pointplan slineto
      planprojpst projpath
   clip
   solidlinewidth setlinewidth
   newpath
      linecolor
      range aload pop {} { function cvx exec } Courbeparam_
      gere_pstricks_proj_opt
} def

/proj-pst-point {
   [proj-args] length 0 eq {
      xorigine yorigine /proj-args defpoint
   } if
   /projname where {
      pop
      [proj-args proj-definition cvx exec]
      dup 0 getp projname cvlit defpoint
      dup length 2 gt {
         1 getp projname (0) append cvlit defpoint
      } if
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      solidlinewidth setlinewidth
      linecolor
      [proj-args proj-definition cvx exec] 0 getp point_
      gere_pstricks_proj_opt
      Stroke
   } if
%   1 1 0 0 1 1 Diamond
   texte length 0 gt {
      proj-fontsize setfontsize
      %setTimes 
      solidlinewidth setlinewidth
      newpath
      linecolor
      texte [proj-args proj-definition cvx exec 0 0 phi neg rotatepoint] 0 getp 
      pos (text_) append cvx exec
%%    /planprojpst where {
%%       planprojpst dupplan dup phi rotateplan /planprojpst exch def
%%       pop
%%       xorigine yorigine
%%       0 0 phi neg rotatepoint
%%    } {
%%       0 0
%%    } ifelse
      %gere_pstricks_proj_opt
      planprojpst dupplan dup phi rotateplan projectionsifacevisible projpath
      Fill
   } if
} def

/proj-pst-vecteur {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      xorigine yorigine 2 copy proj-args proj-definition cvx exec addv drawvecteur
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defpoint
      /projname where pop /projname undef
   } if
} def

/proj-pst-droite {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan smoveto
%% 	 planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec droite
      eprojscene
   } if
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defdroite
      /projname where pop /projname undef
   } if
} def

/proj-pst-polygone {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
      newpath
         xmin ymin l@pl@n pointplan smoveto
         xmin ymax l@pl@n pointplan slineto
         xmax ymax l@pl@n pointplan slineto
         xmax ymin l@pl@n pointplan slineto
         xmin ymin l@pl@n pointplan slineto
	 planprojpst projpath
      clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec polygone_
      planprojpst projectionsifacevisible projpath
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-cercle {
   /projname where {
      pop
      proj-args proj-definition cvx exec projname cvlit defcercle
      /projname where pop /projname undef
   } if
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%% 	 planprojpst projpath
%%       clip
      solidlinewidth setlinewidth
      linestyle
      linecolor
      newpath
      range aload pop proj-args
      proj-definition cvx exec Cercle_
      planprojpst projectionsifacevisible projpath
   } if
} def

/proj-pst-line {
   proj-action (none) eqstring not {
      l@pl@n plangetrange aload pop 
      setyrange setxrange
%%       newpath
%%          xmin ymin l@pl@n pointplan smoveto
%%          xmin ymax l@pl@n pointplan slineto
%%          xmax ymax l@pl@n pointplan slineto
%%          xmax ymin l@pl@n pointplan slineto
%%          xmin ymin l@pl@n pointplan slineto
%%          planprojpst projpath
%%       clip
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec ligne
      eprojscene
   } if
   /projname where {
      pop
      proj-definition length 0 eq {
         [proj-args]
      } {
         proj-args 
      } ifelse
      proj-definition cvx exec projname cvlit exch def
      /projname where pop /projname undef
   } if
} def

/proj-pst-rightangle {
   proj-action (none) eqstring not {
      planprojpst bprojscene
      solidlinewidth setlinewidth
      linestyle
      linecolor
      proj-args proj-definition cvx exec angledroit
      eprojscene
   } if
} def

/proj-pst-texte {
2 dict begin
   proj-fontsize setfontsize
   %setTimes
   1 gere_pstfont
   solidlinewidth setlinewidth
   newpath
   linecolor
   texte 
   /planprojpst where {
      planprojpst dupplan dup phi rotateplan /planprojpst exch def
      pop
      xorigine yorigine
      0 0 phi neg rotatepoint
   } {
      0 0
   } ifelse
   pos (text_) append cvx exec
   gere_pstricks_proj_opt
Fill
end
} def

% END solides.pro

%%EndProcSet
%%BeginProcSet: pst-3dplot.pro 0 0
%% $Id: pst-3dplot.pro 298 2010-03-13 08:46:53Z herbert $
%%
%% This is file `pst-3dplot.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-3dplot.tex'
%%
%% Herbert Voss <voss _at_ PSTricks.de>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-3dplot' is a PSTricks package to draw 3d curves and graphical objects
%%
%%
%% version 0.31 / 2010-02-20  Herbert Voss <hvoss _at_ tug.org>
%% with contributions of Darrell Lamm <darrell.lamm _at_ gtri.gatech.edu<
%%            
%
/tx@3DPlotDict 200 dict def
tx@3DPlotDict begin
%
/printDot { gsave 2 copy 2 0 360 arc fill stroke grestore } def
%
/saveCoor { 
  dzUnit mul /z ED
  dyUnit mul /y ED
  dxUnit mul /x ED
} def
%
/3Dto2D { % true or false on stack
  { RotatePoint } if
  1 { %  dummy loop, will run only 1 time, allows exit 
    coorType 0 le {                                               % the default |
      /x2D x leftHanded not { neg } if Alpha cos mul y Alpha sin mul add def %  /\  co system
      /y2D x leftHanded { neg } if Alpha sin mul y Alpha cos mul add neg Beta sin mul z Beta cos mul add def
      exit } if
    coorType 1 le { 
      /x2D y x Alpha 90 sub sin mul sub def  %  |/_  co system, no shortened x axis
      /y2D z x Alpha 90 sub cos mul sub def 
      exit } if
    coorType 2 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x 0.5 mul sub def
      /y2D z x 0.5 mul sub def 
      exit } if
    coorType 3 le { % coorType |/_ with a 1/sqrt(2) shortend x-axis and 135 degrees 
      /x2D y x -0.5 mul sub def
      /y2D z x -0.5 mul sub def 
      exit } if
    coorType 4 le { % Normalbild in Trimetrie Skalierung so, dass coorType2
       /x2D x -0.5 mul y 1 mul add def
       /y2D x -0.5 mul y -0.25 mul add z 1 mul add def
       exit } if
  } repeat
} def
/ConvertTo2D { true 3Dto2D } def
/ConvertTo2DWithoutRotating { false 3Dto2D } def
%
/Conv3D2D { /z ED /y ED /x ED ConvertTo2D x2D y2D } def
%
/ConvertToCartesian {
  /latitude exch def
  /longitude exch def
  /Radius exch def
  1 { %  dummy loop, will run only 1 time, allows exit
    SphericalCoorType 0 le {                                               % the default |
     /z { Radius latitude sin mul } def
     /x { Radius longitude cos mul latitude cos mul } def
     /y { Radius longitude sin mul latitude cos mul } def
      exit } if
    SphericalCoorType 2 le {
     /z { Radius longitude cos mul } def
     /x { Radius longitude sin mul latitude cos mul} def
     /y { Radius longitude sin mul latitude sin mul } def
      exit } if
  } repeat
} def
%
/ConvCylToCartesian { % r phi h -> x y z
  3 1 roll			% h r phi
  /Phi ED
  /Radius ED			% h->z on stack
  Radius Phi cos mul exch 	% x z
  Radius Phi sin mul exch	% x y z
} def
%
/SphericalTo2D {
  x y z ConvertToCartesian ConvertTo2D
} def
%
/CylinderTo2D { %  r phi h
  x y z ConvCylToCartesian ConvertTo2D
} def
%
/convertStackTo2D {
  counttomark
  /n ED /n3 n 3 div cvi def
  n3 {
    n -3 roll
    SphericalCoor { ConvertToCartesian } { saveCoor } ifelse
    ConvertTo2D
    x2D xUnit y2D yUnit
    /n n 1 sub def
  } repeat
} def
%
% the angle in the parameter equation for an ellipse is not proportional to the real angle!
% phi=atan(b*tan(angle)/a)+floor(angle/180+0.5)*180
%
/getPhi { % on stack: vecA vecB angle 
  3 dict begin
  /angle exch def /vecB exch def /vecA exch def
  angle cvi 90 mod 0 eq { angle } { vecA angle tan mul vecB atan 
  angle 180 div .5 add floor 180 mul add } ifelse 
  end
} def
%
/RotSet (set ) def
%
/eulerRotation false def
% Matrix multiplication procedure
/matmul {

  /M@tMulDict 20 dict def
  M@tMulDict begin
  /m2 ED
  /m1 ED
  m1 dup length 2 sub 2 getinterval aload pop
  /col1max ED
  /row1max ED
  m2 dup length 2 sub 2 getinterval aload pop
  /col2max ED
  /row2max ED
  /m3 row1max col2max mul 2 add array def
  m3 dup length 2 sub row1max col2max 2 array astore putinterval
  0 1 row1max 1 sub {
   /row ED
   0 1 col2max 1 sub {
    /col ED
    /sum 0 def
    0 1 col1max 1 sub{
    /rowcol ED
    sum
    m1 row col1max mul rowcol add get
    m2 rowcol col2max mul col add get
    mul add 
    /sum ED
    } for
    m3 row col2max mul col add sum put
   } for
  } for
  m3
  end % end of M@tMulDict

} def
%
/SetMQuaternion {

  /MnewTOold 11 array def

  /Qu@ternionDict 30 dict def
  Qu@ternionDict begin

  /normRotVec  xRotVec yRotVec zRotVec 3 array astore VecNorm  def
  normRotVec 0 gt
  {/xRotVecNorm xRotVec normRotVec div def
   /yRotVecNorm yRotVec normRotVec div def
   /zRotVecNorm zRotVec normRotVec div def
   RotAngle}
  {/xRotVecNorm 1 def
   /yRotVecNorm 0 def
   /zRotVecNorm 0 def 
   0} ifelse

  2 div dup
  /q0 exch cos def
      sin dup dup
  /q1 exch xRotVecNorm mul def
  /q2 exch yRotVecNorm mul def
  /q3 exch zRotVecNorm mul def

  /q0q0 q0 q0 mul def
  /q0q1 q0 q1 mul def
  /q0q2 q0 q2 mul def
  /q0q3 q0 q3 mul def

  /q1q1 q1 q1 mul def
  /q1q2 q1 q2 mul def
  /q1q3 q1 q3 mul def

  /q2q2 q2 q2 mul def
  /q2q3 q2 q3 mul def

  /q3q3 q3 q3 mul def

  MnewTOold 0 q0q0 q1q1 add q2q2 sub q3q3 sub put
  MnewTOold 1 q1q2 q0q3 sub 2 mul put
  MnewTOold 2 q1q3 q0q2 add 2 mul put

  MnewTOold 3 q1q2 q0q3 add 2 mul put
  MnewTOold 4 q0q0 q1q1 sub q2q2 add q3q3 sub put
  MnewTOold 5 q2q3 q0q1 sub 2 mul put

  MnewTOold 6 q1q3 q0q2 sub 2 mul put
  MnewTOold 7 q2q3 q0q1 add 2 mul put
  MnewTOold 8 q0q0 q1q1 sub q2q2 sub q3q3 add put

  MnewTOold 9 3 put
  MnewTOold 10 3 put

  end % end of Qu@ternionDict

} def
%
/SetMxyz {
  1.0 0.0 0.0  0.0 1.0 0.0  0.0 0.0 1.0  3 3  11 array astore /MnewTOold ED
  RotSequence cvx exec % Now create a new MnewTOold using xyz, etc.
} def
%
/ConcatMQuaternion {
  MnewTOold % Push onto stack
  SetMQuaternion % Uses [xyz]RotVec and RotAngle to make MnewToOld 
  MnewTOold matmul /MnewTOold ED
} def
%
/ConcatMxyz {
  MnewTOold % Push onto stack
  SetMxyz % Uses RotX, etc. to set MnewTOold 
  MnewTOold matmul /MnewTOold ED
} def
%
/RotatePoint{
  MnewTOold x y z  3 1  5 array astore matmul
  0 3 getinterval aload pop 
  /z ED 
  /y ED 
  /x ED 
} def
%
/makeMoldTOnew {
  /MoldTOnew 11 array def
  MoldTOnew 0 MnewTOold 0 get put
  MoldTOnew 1 MnewTOold 3 get put
  MoldTOnew 2 MnewTOold 6 get put
  MoldTOnew 3 MnewTOold 1 get put
  MoldTOnew 4 MnewTOold 4 get put
  MoldTOnew 5 MnewTOold 7 get put
  MoldTOnew 6 MnewTOold 2 get put
  MoldTOnew 7 MnewTOold 5 get put
  MoldTOnew 8 MnewTOold 8 get put
  MoldTOnew 9               3 put
  MoldTOnew 10              3 put
} def
%
/RotXaxis { 
  eulerRotation 
  {1 0 0}
  {makeMoldTOnew MoldTOnew  1 0 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotX def
  ConcatMQuaternion
} def
/RotYaxis { 
  eulerRotation 
  {0 1 0}
  {makeMoldTOnew MoldTOnew  0 1 0  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotY def
  ConcatMQuaternion
} def
/RotZaxis { 
  eulerRotation 
  {0 0 1}
  {makeMoldTOnew MoldTOnew  0 0 1  3 1  5 array astore matmul
   0 3 getinterval aload pop} ifelse
  /zRotVec ED
  /yRotVec ED
  /xRotVec ED
  /RotAngle RotZ def
  ConcatMQuaternion
} def
/xyz { RotXaxis RotYaxis RotZaxis } def
/yxz { RotYaxis RotXaxis RotZaxis } def
/yzx { RotYaxis RotZaxis RotXaxis } def
/xzy { RotXaxis RotZaxis RotYaxis } def
/zxy { RotZaxis RotXaxis RotYaxis } def
/zyx { RotZaxis RotYaxis RotXaxis } def
/quaternion { } def % Null
%
/VecNorm { 0 exch { dup mul add } forall sqrt } def
%
/UnitVec {			% on stack is [a]; returns a vector with [a][a]/|a|=1 
  dup VecNorm /norm ED
  norm 0 lt {/norm 0 def} if
  { norm div } forall 3 array astore } def
%
/AxB {				% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a2 b3 mul a3 b2 mul sub
    a3 b1 mul a1 b3 mul sub
    a1 b2 mul a2 b1 mul sub
    3 array astore } def
%
/AaddB {			% on the stack are the two vectors [a][b]
    aload pop /b3 ED /b2 ED /b1 ED
    aload pop /a3 ED /a2 ED /a1 ED
    a1 b1 add a2 b2 add a3 b3 add
    3 array astore } def
%
/AmulC {			% on stack is [a] and c; returns [a] mul c
    /factor ED { factor mul } forall 3 array astore } def
%
%
/setColorLight { % expects 7 values on stack C M Y K xL yL zL
% les rayons de lumire
  xLight dup mul yLight dup mul zLight dup mul add add sqrt /NormeLight ED
% the color values
  /K ED
  /Yellow ED
  /Magenta ED
  /Cyan ED
} def
%
/facetteSphere {
  newpath
  /Xpoint Rsphere theta cos mul phi cos mul CX add def
  /Ypoint Rsphere theta sin mul phi cos mul CY add def
  /Zpoint Rsphere phi sin mul CZ add def
  Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end moveto
  theta 1 theta increment add {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi cos mul CY add def
    /Zpoint Rsphere phi sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end  lineto
  } for
  phi 1 phi increment add {
    /phi1 ED
    /Xpoint Rsphere theta increment add cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta increment add sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  theta increment add -1 theta {%
    /theta1 ED
    /Xpoint Rsphere theta1 cos mul phi increment add cos mul CX add def
    /Ypoint Rsphere theta1 sin mul phi increment add cos mul CY add def
    /Zpoint Rsphere phi increment add sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  phi increment add -1 phi {
    /phi1 ED
    /Xpoint Rsphere theta cos mul phi1 cos mul CX add def
    /Ypoint Rsphere theta sin mul phi1 cos mul CY add def
    /Zpoint Rsphere phi1 sin mul CZ add def
    Xpoint Ypoint Zpoint tx@3Ddict begin ProjThreeD end lineto
  } for
  closepath 
} def
%
/MaillageSphere { 
% on stack must be x y z Radius increment C M Y K 
  setColorLight
  /increment ED
  /Rsphere ED
  /CZ ED
  /CY ED
  /CX ED
  /StartTheta 0 def
  /condition { PSfacetteSphere 0 ge } def
  -90 increment 90 increment sub {%
    /phi ED
    StartTheta increment 360 StartTheta add increment sub {%
      /theta ED
      % Centre de la facette
      /Xpoint Rsphere theta increment 2 div add cos mul phi increment 2 div add cos mul CX add def
      /Ypoint Rsphere theta increment 2 div add sin mul phi increment 2 div add cos mul CY add def
      /Zpoint Rsphere phi increment 2 div add sin mul CZ add def
      % normale a la facette
      /nXfacette Xpoint CX sub def
      /nYfacette Ypoint CY sub def
      /nZfacette Zpoint CZ sub def
      % test de visibilite
      /PSfacetteSphere 
        vX nXfacette mul
        vY nYfacette mul add
        vZ nZfacette mul add
      def
      condition {
        gsave
        facetteSphere
        /cosV { 1 xLight nXfacette mul
          yLight nYfacette mul
          zLight nZfacette mul
          add add
          NormeLight
          nXfacette dup mul
          nYfacette dup mul
          nZfacette dup mul
          add add sqrt mul div sub } bind def
        Cyan cosV mul Magenta cosV mul Yellow cosV mul K cosV mul setcmykcolor fill 
	grestore
%	0 setgray
        showgrid { facetteSphere stroke } if
      } if 
    } for
    % /StartTheta StartTheta increment 2 div add def
  } for
} def
%
%---------------------- Cylinder ---------------------------
%
/PlanCoupeCylinder { %
  /TableauxPoints [
    0 1 359 { 
      /phi ED 
      [ Radius phi Height ConvCyl2d ] % on dcrit le cercle
    } for
  ] def
  newpath
  TableauxPoints 0 get aload pop moveto
  1 1 359 { TableauxPoints exch get aload pop lineto } for
  closepath
} def
%
/facetteCylinder { % 
    newpath
    Radius phi currentHeight ConvCyl2d moveto
    phi 1 phi dAngle add  { % loop variable on stack
      Radius exch currentHeight ConvCyl2d lineto        
    } for
    phi dAngle add -1 phi { %	fill dHeight
      Radius exch currentHeight dHeight add ConvCyl2d lineto 
    } for
    closepath
  } def % facette
%
/MaillageCylinder { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K
      /dHeight ED /dAngle ED /Height ED /Radius ED
      /CZ ED /CY ED /CX ED } if
%     
    0 dHeight Height dHeight sub {
      /currentHeight ED
      0 dAngle 360 dAngle sub {
        /phi ED
% Normal vector of the center
        /nXfacetteCylinder Radius phi dAngle 2 div add cos mul CX add def 
        /nYfacetteCylinder Radius phi dAngle 2 div add sin mul CY add def 
        /nZfacetteCylinder currentHeight dHeight 2 div add CZ add def 
        /NormeN 
          nXfacetteCylinder dup mul
          nYfacetteCylinder dup mul
          nZfacetteCylinder dup mul
          add add sqrt def
        NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilit
       /PSfacetteCylinder 
    	    vX nXfacetteCylinder mul
            vY nYfacetteCylinder mul add
            vZ nZfacetteCylinder mul add def
       condition {
         facetteCylinder
         /cosV 
	   1 xLight nXfacetteCylinder mul
           yLight nYfacetteCylinder mul
           zLight nZfacetteCylinder mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
          showgrid { 
            0 setgray
            facetteCylinder % drawing the segments
            stroke } if
       } if
     } for
    } for
} def
%
%------------------------ Cylinder type II -----------------------
%
/MoveTo { Conv3D2D moveto } def
/LineTo { Conv3D2D lineto } def

/IIIDEllipse { % x y z rA rB startAngle endAngle Wedge
  /dAngle 1 def
  /isWedge ED
  /endAngle ED
  /startAngle ED
  /radiusB ED
  /radiusA ED
  startAngle cos radiusA mul startAngle sin radiusB mul 0 
  isWedge { 0 0 moveto LineTo }{ MoveTo } ifelse
  /Angle startAngle def
  startAngle dAngle endAngle {
    /Angle ED
    Angle cos radiusA mul Angle sin radiusB mul 0 LineTo  
  } for
  isWedge { 0 0 lineto } if
} def

/IIIDCircle { % x y z r startAngle endAngle Wedge
  7 3 roll % startAngle endAngle Wedge x y z r
  dup      % startAngle endAngle Wedge x y z r r
  8 -3 roll
  IIIDEllipse 
} def

/IIIDWedge { % x y z r startAngle endAngle
  true IIIDCircle
} def

/IIIDCylinder {% x y z r h start end wedge
  /isWedge ED
  /increment ED
  /endAngle ED
  /startAngle ED
  /height ED
  /radius ED
  startAngle increment endAngle {
    /Angle ED
    radius Angle 0 ConvCylToCartesian MoveTo  
    radius Angle height ConvCylToCartesian LineTo  
  } for
  stroke
} def
%
%---------------------- Box ---------------------------
%
/PlanCoupeBox { % x y z
  /TableauxPoints [
      [ CX CY CZ Height add ConvBox2d ] % top or bottom
      [ CX CY Depth add CZ Height add ConvBox2d ]
      [ CX Width add CY Depth add CZ Height add ConvBox2d ] 
      [ CX Width add CY CZ Height add ConvBox2d ] 
      [ CX CY CZ Height add ConvBox2d ] % bottom
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 3 {
      TableauxPoints exch get aload pop
      lineto } for
    closepath
} def
%
/facetteBox { % 
    newpath
    dup
    1 eq { % back
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    2 eq { % right
      CX CY CZ ConvBox2d moveto
      CX CY CZ Height add ConvBox2d lineto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
      CX CY CZ ConvBox2d lineto
    } if
    dup
    3 eq { % left
      CX Width add CY CZ ConvBox2d moveto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY CZ Height add ConvBox2d lineto
      CX Width add CY CZ ConvBox2d lineto
    } if
    4 eq { % front
      CX CY Depth add CZ ConvBox2d moveto
      CX CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ Height add ConvBox2d lineto
      CX Width add CY Depth add CZ ConvBox2d lineto
      CX CY Depth add CZ ConvBox2d lineto
    } if
    closepath
  } def % facette
%
/TestPlane { % on stack x y z of the plane center and # of plane
  /nZfacetteBox ED /nYfacetteBox ED /nXfacetteBox ED
  /Plane ED
  /NormeN 
    nXfacetteBox dup mul
    nYfacetteBox dup mul
    nZfacetteBox dup mul
    add add sqrt def
  NormeN 0 eq { /NormeN 1e-10 def } if
% test de visibilite
  /PSfacetteBox 
    vX nXfacetteBox mul
    vY nYfacetteBox mul add
    vZ nZfacetteBox mul add def
  condition {
    Plane facetteBox
         /cosV 
	   1 xLight nXfacetteBox mul
           yLight nYfacetteBox mul
           zLight nZfacetteBox mul
           add add
	   NormeLight NormeN mul div sub def
         Cyan Magenta Yellow K
         cosV mul 4 1 roll cosV mul 4 1 roll 
	 cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         0 setgray
         Plane facetteBox % drawing the segments
         stroke
       } if
} def
%
/MaillageBox { % on stack true or false for saving values
    { setColorLight  % expects 4 values on stack C M Y K 
      /Depth ED /Height ED /Width ED
      /CZ ED /CY ED /CX ED } if
%
% Normal vector of the box center
  /PlaneSet [
    [ Width 2 div CX add 
      CY 
      Height 2 div CZ add ] % normal back
    [ CX 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal right
    [ Width CX add 
      Depth 2 div CY add 
      Height 2 div CZ add ] % normal left
    [ Width 2 div CX add 
      Depth CY add 
      Height 2 div CZ add ] % normal front
  ] def
  PlaneSequence length 0 eq { % user defined?
    Alpha abs cvi 360 mod /iAlpha ED
    iAlpha 90 lt { [ 1 2 3 4 ]  
      }{ iAlpha 180 lt { [ 2 4 1 3 ]  
        }{ iAlpha 270 lt { [ 3 4 1 2 ] }{ [ 3 1 4 2] } ifelse } ifelse } ifelse 
  }{ PlaneSequence } ifelse 
  { dup 1 sub PlaneSet exch get aload pop TestPlane } forall
} def
%
%--------------------------- Paraboloid -----------------------------
/PlanCoupeParaboloid {
    /Z height store
    /V {Z sqrt} bind def
    /TableauxPoints [
      0 1 359 { 
        /U ED [ U U Z V calculate2DPoint ] % on decrit le cercle
      } for
    ] def
    newpath
    TableauxPoints 0 get aload pop moveto
    0 1 359 {
      /compteur ED
      TableauxPoints compteur get aload pop
      lineto } for
    closepath
} def
%
/facetteParaboloid{
    newpath
    U U Z V calculate2DPoint moveto
    U 1 U increment add  {%
      /U1 ED
      U1 U1 Z V calculate2DPoint lineto
    } for
    Z pas10 Z pas add pas10 add{
      /Z1 ED
      /V {Z1 sqrt} bind def
      U1 U1 Z1 V calculate2DPoint lineto
    } for
    U increment add -1 U {%
      /U2 ED
      U2 U2 Z pas add V calculate2DPoint lineto
    } for
    Z pas add pas10 sub pas10 neg Z pas10 sub {
      /Z2 ED
      /V Z2 abs sqrt def
      U U Z2 V calculate2DPoint lineto
    } for
    closepath
} def % facette
%
/MaillageParaboloid {
  % on stack true or false for saving values
    { setColorLight  % expects 7 values on stack C M Y K xL yL zL 
%      /CZ ED /CY ED /CX ED 
    } if    
    0 pas height pas sub {%
      /Z ED
      /V Z sqrt def
      0 increment 360 increment sub {%
        /U ED
% Centre de la facette
        /Ucentre U increment 2 div add def
        /Vcentre Z pas 2 div add sqrt def
% normale  la facette
        /nXfacetteParaboloid 2 Vcentre dup mul mul Ucentre cos mul radius mul def
        /nYfacetteParaboloid 2 Vcentre dup mul mul Ucentre sin mul radius mul def
        /nZfacetteParaboloid Vcentre neg radius dup mul mul def
        /NormeN {
          nXfacetteParaboloid dup mul
          nYfacetteParaboloid dup mul
          nZfacetteParaboloid dup mul
          add add sqrt} bind def
        NormeN 0 eq {/NormeN 1e-10 def} if
% test de visibilit
       /PSfacetteParaboloid vX nXfacetteParaboloid mul
                  vY nYfacetteParaboloid mul add
                  vZ nZfacetteParaboloid mul add def
       condition {
         facetteParaboloid
         /cosV 1 xLight nXfacetteParaboloid mul
           yLight nYfacetteParaboloid mul
           zLight nZfacetteParaboloid mul
           add add
           NormeLight
           NormeN mul div sub def
         Cyan Magenta Yellow K  
         cosV mul 4 1 roll cosV mul 4 1 roll cosV dup mul mul 4 1 roll cosV dup mul mul 4 1 roll
         setcmykcolor fill
         showgrid {
           0 setgray
           facetteParaboloid
           stroke } if
       } if
     } for
    } for
} def
%
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
% u -> e_u with |e_u|=1 
/vector-unit { 1 dict begin
  dup vector-length 1 exch div 
  vector-scale
  end 
} def
%
% u v -> u+v
/vector-add { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch { 	% i u[i]
    v 		% i u[i] v
    2 index get add 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
  end 
} def
%
% u v -> u-v
/vector-sub { 1 dict begin
  /v exch def
  [ exch
  0 	     	% u i
  exch {	% i u[i]
    v 		% i u[i] v
    2 index get sub 	% i u[i]+v[i]
    exch 1 add	% i
  } forall
  pop
  ]
end } def
%
% [v] c -> [c.v]
/vector-scale { 1 dict begin
  /c exch def
  [ exch
  { 		% s i u[i]
    c mul	% s i u[i] v 
  } forall
  ]
  end } def
%
%
% [u] [v] -> [u x v]
/vector-prod { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  [ y zp mul z yp mul sub
   z xp mul x zp mul sub
   x yp mul y xp mul sub ]
end
} def
%
% [u] [v] -> u.v
/vector-mul { %% x1 y1 z1 x2 y2 z2
6 dict begin
  aload pop 
  /zp exch def /yp exch def /xp exch def
  aload pop 
  /z exch def /y exch def /x exch def
  x xp mul y yp mul add z zp mul add
end
} def
%
% [x y z ... ] -> r
% watch out for overflow
/vector-length { 1 dict begin
dup
% find maximum entry
/max 0 def
{ % max 
  abs dup max gt {
    % if abs gt max
    /max exch def
  } {
    pop
  } ifelse
} forall
max 0 ne {
  0 exch 
  {  % 0 v[i]
    max div dup mul add
  } forall
  sqrt
  max mul
} {
  pop 0
} ifelse
end } def
%
end % tx@3DPlotDict
%

%%EndProcSet
%%BeginProcSet: pst-eucl.pro 0 0
%!
% PostScript prologue for pst-eucl.tex.
% Version 1.00 2011/08/04
% For distribution, see pstricks.tex.
%
/tx@EcldDict 40 dict def tx@EcldDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% e
/E 2.718281828459045 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> true (if |x| < 1E-6)
/ZeroEq { abs 1E-6 lt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> a b c (ax-by+c=0 with a^2+b^2=1)
/EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub
  2 index dup mul 2 index dup mul add sqrt
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch pop
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% orthogonal projection of M1 onto (OM2)
%% x1 y1 x2 y2 -> x3 y3
/Project {
  2 copy dup mul exch dup mul add 5 1 roll 2 copy 5 -1 roll mul exch
  5 -1 roll mul add 4 -1 roll div dup 4 -1 roll mul exch 3 -1 roll mul
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c (ax2+bx+c=0) -> x1 y1
/SolvTrin {
  /c exch def /b exch def /a exch def
  b dup mul a c mul 4 mul sub dup 0 lt
  { pop 0 0 } %% no solutions
  {sqrt dup b neg add a 2 mul div exch b add neg 2 a mul div }
  ifelse } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> Dist
/ABDist { 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> x1-x2  y1-y2
/ABVect { 3 -1 roll exch sub 3 1 roll sub exch } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 x3 y3 x4 y4 -> x y
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
%   { pop pop pop 0 0 } %% parallel lines  % --- hv 20110714
   { pop 0 0 } %% parallel lines             --- hv 20110714
   {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
   } ifelse  } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c R -> x1 y1 x2 y2
/InterLineCircle {
  /CR exch def /Dc exch def neg /Db exch def /Da exch def
  ABVect /Vy exch def /Vx exch def
  %% Dc==0 then O belong to the line
  %% First project O on the line -> M (-ca;-cb)
  %% l'abscisse de M sur (OM) divise par R donne le cosinus
  %Dc neg dup Db mul exch Da mul 2 copy 0 0
  %ABDist dup CR gt { pop pop pop 0 0 0 0 }
  %{ ZeroEq { pop pop Db Da } if Atan /alpha exch def
  Dc abs CR gt { 0 0 0 0 } 
  { Db neg Da neg Atan /alpha exch def
  Dc CR div dup dup mul 1 exch sub sqrt exch Atan /beta exch def
  alpha beta add dup cos CR mul exch sin CR mul
  alpha beta sub dup cos CR mul exch sin CR mul
  4 copy ABVect Vy mul 0 le exch Vx mul 0 le and
  { 4 2 roll } if } ifelse
 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% R R' OO' -> x1 y1 x2 y2
/InterCircles {
  /OOP exch def /CRP exch def /CR exch def
  OOP dup mul CRP dup mul sub CR dup mul add OOP div 2 div
  dup dup mul CR dup mul exch sub dup
  0 lt { pop pop 0 0 0 0 } { sqrt 2 copy neg } ifelse
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x y theta -> x' y' (rotation of theta)
/Rotate {
  dup sin /sintheta exch def cos /costheta exch def /y exch def /x exch def
  x costheta mul y sintheta mul sub
  y costheta mul x sintheta mul add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% N -> x y
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> ch(x)
/ch { dup Ex exch neg Ex add 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> sh(x)
/sh { dup Ex exch neg Ex sub 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> e^(x)
/Ex { E exch exp } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x f g -> x y n
/NewtonSolving {
  /g exch def /f exch def 0
  { %%% STACK: x0 n
    1 add exch %% one more loop
    dup ZeroEq
    { dup 0.0005 add fgeval
      1 index 0.0005 sub fgeval sub .001 div }
    { dup 1.0005 mul fgeval
      1 index 0.9995 mul fgeval sub .001 2 index mul div } ifelse  %%% STACK: n x0 fg'(x0)
    %%% compute x1=x0-fg(x0)/fg'(x0)
    1 index fgeval exch div dup 4 1 roll sub exch %% stack: dx x0 n
    3 -1 roll ZeroEq              %% exit if root found
    1 index 100 eq or { exit } if %% or looping for more than 100 times
  } loop
  dup 100 lt { exch dup /x exch def f } { pop 0 0 } ifelse
  3 -1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fgeval { /x exch def f g sub } bind def
end
% END ps-euclide.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: finclude.pro 0 0
%!
/fstore{dup dict exch{dup 4 2 roll put}repeat def}bind def/fshow{gsave
72 TeXDict/Resolution get div -72 TeXDict/VResolution get div scale 1
DVImag div dup scale get cvx exec show grestore}bind def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
 
@fedspecial end
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:46:05 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 33 /arrowright put
dup 40 /arrowdblleft put
dup 41 /arrowdblright put
dup 44 /arrowdblboth put
dup 48 /prime put
dup 50 /element put
dup 54 /negationslash put
dup 57 /existential put
dup 59 /emptysetstress put
dup 63 /perpendicular put
dup 92 /intersection put
dup 106 /bar put
dup 112 /radicallow put
dup 125 /diamond put
dup 161 /minus put
dup 162 /periodcentered put
dup 163 /multiply put
dup 178 /bullet put
dup 180 /equivalence put
dup 189 /propersubset put
dup 197 /plus put
dup 198 /equal put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735FB6B8836B8B5A4D2AA84
96C5E265C58458246B1452B308A022655587FDF933817766BE8A1E6C29DC4365
DC1ED202CBD81E0339EC4C3C57B054EADA2C699385B3CD763CA06787E96684BF
86F7BBA7009447D8D50167498735295CFFA5358D068EA503BEBC2D3A7EEDE760
BBC03394A6B01B1AEC021C9F06834D1CDE5DED19A5A1F909707B6F82EF7042E5
6DD6D3A4540C44C2F714255DA49DE3F4BA0FBF6CC7C70DF469DA41C540BB8453
9E2165A3CBA66FE38B053AAAA785F456C3E7348488F24F4F85ACDFF5DC9439BC
881F312AA2F124B9AF0C3D49B66A69F1466F269CD88E61FC97836601CA7468B6
3F6F9073177EF4415C668EE979D6CFDAEC7424E3FEC17140D4D9D0853290238A
A883722ACFF7106D2A3AA6CEC2FD5AAE058E596DC51C5938D546A4347744EAC9
A06070916D30CF4AC00217C6F5BACE4E0F6EC0988A8D20676BEDE44664D4EF04
C838C8256DD545D8E917E135968FE7F3EA57DD9DD89D32D6B19DFF0941DE0F4D
45E56E303FCAC5D36E4835BB3D1B132915AD020B31395793CA98B653B439AF27
33F7E52F8C084DC9FC1ECD7A4E4C73E8968F6AA9D17C1628DD5027F5B1179773
8489B35134733BAB12D53C09FB0923D3A6E3CD2A558563220A83B509BA7483B6
71ACF293916F5898377CBA2559EF94EB3E3CFBB92D7DCBBCFF2A88709617FD7D
D9477392F01BC2880E9892729C85697113AE6D33237A378F1121815FD64161DF
3C6DA0964DAD3E1AA98F2E5EB9ED4A65CBC1F4DCA717FB2939E403F7EFC65357
066B419929C3C790D1FE83781A41DB3EB1505E58907E48FD7330709F7DEA8556
CDBED593060E6A51084D30E15D606775CE57579BBF83EB0AA36B2122925857F7
C756E966634BD3A4344080693C3A18954DBD1DC09755A6206DF278938D8631D7
CCD5AE75550A389218883B8F22516F429395F7ECC290010499476A3743B7C2C8
1BE9A3CE35F46FC612BD13BB54C70AF4474780F54BEEE3D0E363C0255FDCFF71
0C784B2F6405EECEEEC0CE50C2EEB85CAB389915C5048C26E4A74951A458B864
A917DEFBBDD29618D7992C53B25D63F8ECE3BCDD344D37AD4DE21FCBA744AD24
6853473994AABCE00532FF98AD288AA0F078232CCDD15C4B13718DAE36255FF4
448CDBCD244F3D77D5072814B5836AFB07213F6FCF760193718BA22F031C4AD8
D247D08DB7AAED1A530570DEBFFBCE880B4D160186612DAC8F8B1CE9846B38AE
80C551F5CDAEB6BD59067E28C40021CCD84C73D56CFA4EB4F52C79BAF8D75FC7
C9A098B5FDC8F6ABA3692BD07CED83D54CAC9444C14882C89337A7D317D39548
17CC3A45E1D2813415DE1F130AA6CC8D6FD73D9C524E45E8781C8D402985E837
02C6288184CD2B0AE145DDB6926B20338E1F7BA03EC816CA6320BAF9E8CB9865
35946D2CA7CF18DCE94F4299533E6EF202EB24CE03A739A0D3872D3C878630CC
0ED8E1A4524E22AC76748A04C4602E5115EA4FC0A3D6AD44A8AF93A1A700778D
C3D814D6E9142EAC314F8D2D8B05FEB8CB263C5BD6AA96ED68D66B256A15B81F
4B71D28C78E0B177B917C09D07E2EAD4E502D54148CB6D877E5D18FF13ED732C
79E074DBD62547849C1D3E6513531BF46DBAE59690BF9610EDD05018D28D0E88
FF56CB739B4376E032971741BE6FC445B9E2530EA7EAC5B3DA5B43FA9C1E6360
F0C49AD98B3A135FF0F70A21C9E55F57BBD1CADE7B48A3FB206F1E34310A740F
7C8CD3ED8A76A5D69AEB3317975EF4F48733066998A9197AD2E3B59BFAF2D3CF
20A1EFEB30813F9639E19BA23BC194EE401AFC812C417DA59075C426125644AB
95DB2E3301980C3A7F5546B66B463D71B0D6EAEF6DBF6C6E2C2035497CAA56E8
B57402EE94575ACD9B5E5EB22253D070ED31911DF966F3010D2AD970FBB6D46A
EA2DD4E49FC082F23F49C689ECA6863B72FB97A35C75C16CD68474A5658D286D
A3D74D0BD911EB69664364E7DFF914561AA409DCE242B5B97ED8DD8AB71BE7B2
3D14A06C297A52A853AE5EB7E4C87F869E63DB980E3EE7A866575D2FB1116F8E
6F9D7CFD8CE4A788274BEF8F143012765287B0EB8F4FB8E46FCF618318D4111C
B909C1D293FE2A034566E1F0E980C6F4D8BC1FAE59D2B38774B845D2C0D60966
E48264432D0E9265075E4426BD79711718AF56D341CBF60523CBE9C3273F0EC4
37AA6788923D087A3E0F0DB2C4891E9678D2270677C6C2258C8A3C6027D774B5
32517EEA67FB52D3F392B6795B79A33B926F7DEA0FF686D94BE3409C0E85A44A
370B01916A2D734986AC6AA64544768E6AD13123F9C98494587C60D0DEEC715A
BE350DF1AB74821D56241F88125A903EE8F89CCCE9DFCDA8B132A978A4DCB85B
FB07A4F20C39AEB3F72D774C99FD2BC0C709029A9B7E781373BBF3D088D9A195
D8D6F97E76C68E0A9CBCFDD27F19D7370B580BFD559E7F8C8CF44E1E2AEBD2B1
0037AE14199F94D260A43C1E49672FE0F49E18C5A7E598D27833031B59777C25
EF368506D9549AB56E4C3F6F0C0A6CC82FCACC4502C2FE6D73BB949FE00E0E46
E92CD2E7D934A4591ACC23AC0008AC65D21EA3DF8E29262AD7F859F6A5B3009E
BA7DD5D94FFBD2A862EA21C18A0CCA99708CC5A3D1CF05E7CC637740169CDC87
C411A4F06631E4ADB369FF1ADDA684F98569EAFA562F91B22BD23B6E740117F6
8020B54F5F6186E454F374C45EEB969A4007E4188171DEBD0A2DA7D316F944FE
10A4FA86281657B944544A737BC7E8DCA285B04941541955CC88AD00F84DD47C
DF3B81B90172EB397C113CA7EE7940DFEC5AA274E069CB634036790971F2F78B
823BE8B7C1DEDC2786ACAEFC1C8D47E439ADC961CA45E38A226BF7EA6AAF8EB4
A56D60190078B5A42E9BCB716E97F4EC2BDE5AA51D93BC0422203CEA65F979DD
485DD8A5BE4196D80F81AFF56BD00ACC014928A2033A5E6868B99272376E849E
FEB5BC764E55927E1D5CBB3A7E9898F52DFD48751DDEC63F677AE7095B69C8AB
2808479687916331494B2F6EE717A4BE75E627BF81B66EBF068909348CBEDA9C
49372FF6550927BB4A5C0663F9948F28B45FF1CA6D3B0A408999D21E2ACC40E1
5E9500271812534039653B0C961806F9903E792948494367E2D65C22A37FB1F7
D57F3F591A9D5F9C12B057B17AE2389F656F1A67CF3783BE45E44B62018C71CB
FE3F96247E6B114591EE750B4EF8F1BD00401D4976A36FC4C6216C17771C62C8
F4E91EF4F557434BAFB880F99D6C6E2710C11059128477BB08B8E2CD6F531E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-Letters
%!PS-AdobeFont-1.0: Fourier-Math-Letters 001.004
%%CreationDate: Sat Oct 30 17:27:29 2004
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice ((C) 2003-2004 GUTenberg) readonly def
/FullName (Fourier-Math-Letters) readonly def
/FamilyName (Fourier-Math-Letters) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Normal) readonly def
end readonly def
/FontName /Fourier-Math-Letters def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 126 /vector put
dup 162 /Delta put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-80 -247 972 755} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DD8F78AE14C
72A7B8AEA5D41576411085046EB76258673C5CF40021E812997FA677D59CE155
7C55D36F8B6501F00808AEE2A8934EF6E7DF27A6D20490B6AD5EE97365B26935
6D798248ACD56BE774DE447B7979B08E595DB252D6EAC137A081AB9E002A195F
08D19ABEE28C95E9EB56094AACD6A73761A3E376674258165DCB3565F51AAE71
E9E3BEA4BB485DF2A75CD2A4335B926A3CFA77EC6765989F03A680DA1A20D708
470FD9A1DB35B2C937E5FD9AA6266283CD76E05138D55F0932678F1088EF5E7D
EFA66BBBECD836DE750970D76D32957258C0B88132232100F446B1885E4E29EA
B8959844D652017B77C98E7ED6D7FC65E1A01EB35DC733347DA3B63F9ACE67A6
975D81865DC92F610E531602C57AF9FCAB91E2EB7A5A39DD2EF594A1E2E5570B
896D14CC26EB1A42F74F76F2231DD03A6824AA2D1005943DDAF2910597A36559
E4BD2F9380A95F7FE63996A81EBBD94329601C7B1DC913319E879728A46CC916
CCC5A010A86E5C572AB48BC20494C889CCAA475A1782731922CAB36A7EE9AFD9
7CEA3215DD9F8FC10F8D4C3F94311A56C45FFD85FB0A91F315F33490242094D2
1996C1071EAEBA4792B29201666254BF49CB393ED233BC236B6BD7617A918696
D74A776613FB94DBD590A7893CA7FE1606C576DEB3E4D7DF25A7A5FE84A8DFD0
9BF199780DBAA1832D07BFBACCB7B8E9DDA897665613728537094E1E8933F961
EBB5ED1BFA4EE2856B8982377719ECF1D7B187015A90CA694AE0ECB4E32BB9E6
AB395207397C971034AD10D252B419D2C1D8841ED02492B3F2A9D73EFF9C12AE
9F92D8858A5ACAB071F8E0ADBE0794A62FB244F098A3940C82C391F0326B9F50
39B18EBFD2C105167F452AF2841C1AA728F941530ECE5D9C861EC8569D27AEC9
D0C19F35A3BDA17F09D2293012310B114FF0BD4D1B99A685BA61CD6E4D63D45B
C47199D41B4DE8F7C00C0F17D72EF41B22A92D559DF471E29954893E6FFE85B2
98AC23152C26ED5EDD43DAC6F23F9D3D0E28D770CA6093A1AEB5365720153023
8DBF05303D4B957B2DA2159F8EC25CB9E26D04C079FFEFD11379918708B95247
E9E48D274C2D132FC179C2D86618C6D860F3C8296158271E84F1B447DA36CE0C
C17F7F53506D835B0B47A2DC4D25222733C31D838A857D0385760342AC6163A9
9DBBA437C74FFD754EC39F8766251CE7ADF2FFD3CCF24D9E891CFEADD289E4AD
AAA092BDEEA4AEDDA73DF7D9D72204FDA072D92518BF19CF2A93D886A46A1CA1
0B1987FEE08BBAA129C3874ADC2FD998E434BA17B09C859634DA9D576A9A8E33
4C4DA292BF63BAA309EBB555325C5DC3EC9300E4B117D9FAB1365EB2D30600A1
31836DC102716CEA1D1618B3D62C4442BBC4C1C3A65570F39E2E702514C1550C
5500F0BCD4158E07318941E241DAC6A1070E5FC0DD3630AD70C60F0DEFCEFFA5
8F3B347160B3E86D1BDB0671DDFCD8D34B125E0370F599C0F251A767
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-Letters-Italic
%!PS-AdobeFont-1.0: Fourier-Math-Letters-Italic 001.004
%%CreationDate: Sat Oct 30 16:49:00 2004
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice ((C) 2003-2004 GUTenberg) readonly def
/FullName (Fourier-Math-Letters-Italic) readonly def
/FamilyName (Fourier-Math-Letters) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Normal) readonly def
end readonly def
/FontName /Fourier-Math-Letters-Italic def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 124 /dotlessj put
dup 174 /alpha put
dup 175 /beta put
dup 184 /lambda put
dup 185 /mu put
dup 188 /pi put
dup 193 /phi put
dup 195 /psi put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-80 -249 825 751} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D440EF
6A6F1325CEC03C3A3F20FBB1DD06C21761D70838D1E83592E85E284B4270E83F
629BC6D3971271C950F0BBBEADF671311AF5411D45ED8085300D8E64F313462F
D04E2C3161217FEF562725FC5DC27438784EC45E8F533487F0B4622BD496D97F
F162ECFD0A3F379AD617BE859FAD42B9260E56747BEDB156FE844C8F7CB9A067
E940C5658DE86647C65CBC0C2C08D79C09F07B00890641C302576D48FCAF0EAE
D328445325AAAFFD80EB6CB76F52E22BF04678BA9FACA7B18B2CD01D95FEDAFC
DDB9720701A17522D74D4DFAF4F00E2534412DA11B60161DC23E13B16B54F7AA
8730C5C0AE9AC9EB6903540CCECAF0312A0E4E4D61402D7A7B1775D9591A2EB5
F284D11E9DE117B588FE6BFCC3C2965579F10F096E83A53FF334587BD24B0D3E
5783469281D7C7514BF9448059616084FBC5B2B797D96E7C7511784C9E290A48
088817AEE321C6C7E1D103680C8B1876C552361F3F6C2AE4090C120A08BAD8E3
5942031F8A3E739BD16DFDD228F01C1A01233D1B633BB37C6F1CCAB278FE8F8D
F6EF0C61C428EDBA1DDC254EF1F6109EEBB032CBC33DE7E1BEF1F4FF672C2D12
F48EE105D9B48C8FBC0C8567FDE51492E87EAB9362A1F3E3670416B0BC64480D
C4BE1681D05E3DD8B659CC8643CBADC4D1D4CF4190F7DE32271EB1DF06C7BEF6
013ECBB9CEC865C2FC9620587044E26D17216D2F99571097694DE10F548890AB
ADEA3D9EC11501D1F492837CF931D1CF1A7EC8388DA83793B661D8057DD36586
43EA5A9CF4C7437416A31C5CDA9FE54518A2EBEF1508E16AB5B944840D233F12
9DC0F470BFFCEA640B6CFBFF6FA5585C8E369D3B09C6A08A8ECA9D2481245BB4
CBD54FF3DCE252AA7F9820491384089BE8305D95BF3D75687FCBE284E3D9AAB3
77DDC4718691116BD79E3FFBF6CB06BD1AE9F92AFC1924CEF1C472AAC24A2F59
E2E104AD5B44548FD5B6E6F84EB5E36C3BA6C2DD7C12AC42F8DA3EB07A65ED21
814D5132E07D90A7B07E5D5A2A548F5B44F246757D0253B42822FAC82C374CBF
D82D5167D79526C4EF41C83C826A94C6EAF95B60CD1948ADB3D9F6CB6818DD96
81E380969869EE0E503AE7505C3FADB05A7962C3723BF6E61E3C3E10DE25AE19
08F86488E7B23653E0063E0C15FDB7D763FCFC95483BB0D5A86178956BF7940F
2912421C4F3BC76FD991E3769999035BFF29D6477B2C3EF7CAB079820BDC770B
D1BC3F4E65A4FE2BC28F1495C6BE640BAFFAC4508D66103E6455B244B9BF9C40
0BC802A021411BFFDB75D908712A1DD141399F362B868DE5F556B5B7EE9DDBC1
7E8CDAF6DD7B3F01AE728211B0CCB196A462A0743F6D424DE652068729BD1561
599182255850D321F0C6498DBBE7D71F92BDB8252A21D24F8878AA51F7EF68D7
9AE1FB73F894B44FC1776F47B0347D62A7F41A7CB83003489E0A7338980051E5
CEA887FFC56F020E4CB97DCB72F52D8F162A7C32F7355B9FB48051FBD883642B
DB55525358ACE2140AA6CC8D6FD73D9C5269F53646664EBA2D466447028F139D
9C6DF8674F6CDF12D2FDE4B981EB981AB0EB210E41CD533D426C7859229DB426
14A54EBFB4DC8097C0D9B0FB9C16475ADF2D88CB239FE3373A015B5CA29A7E73
293A7D2FD2622C3A6DEE1F9AA4A8C69D6A244B6353F23C9BC2D4AD8C286AE8F2
4B4C1AC770D3C56ACF5456D287D9CF2FB4A626EA3E546717AE6E23981338327D
69C1A70FEF47DE1D954392B61E683BB1437FDCD531CB75C377D3C5C7267BEFE1
51C52A60427176D702F4CAEA8976F522C889AA3F48827DD9280D36D698735B34
BADBE914004577EA5DA2CBD75E4BB6D0402E35CB72F4E196336FB352BF532FBD
0172B8082239DC409FB1FF3D5179BA96D4C42B0063B3407F3CF897C932FEE968
7D91EB5B8F0E20A4FD5984624C21F595F9DDF52A9A0C81E94A8380D89096E480
D7B112A801A36951EDCB53A951089E15F99959AF4B4F93D78FC3C4F94459219E
DD29984942CE3E5A6990F99FFDF77D85D43207C5DCC0AB2D5635020D26B524DA
CDFE0D8DCF2F1B1D3B1E07277D77FCDF7E4E239BA6F6C7272B77E3681DB0C37D
9845AA9C7ABB9B6D42A75B38CB7955B07CF3C93C299FF21FF22C22F84C48B07E
5E517FFB4FBB8EA311DE6874945572713A621C127E0A0C1304AE62FFD20D8832
B4B5DCCD38AB4047E26381959ED9C95817D2F0158F70C9645AD42166EDA7834B
E592CCE8E8FBD3D3E9171AE9B8C4A067BA9193F6E0C39A5F557F820AB7E8B18C
7B8C41272C99CEF50C236C6047499118755EE07CD09E6599C9F7696F7B08049A
A54889D43B95104214B86E9F3A5D984E69BF65497EDD146516938637D1DDF0F7
25592C44D3B1F3590135FAD1A3EF9CF15BD96008A6B53548F95E0AD32A8EDB95
88B369B19355EFD0EDD9F8565214B5BCCBC707FA756BD71FF74D8B7E2347719C
81FA79939BCDDDA764C7682B32FE2ED8076858D98F407A440B4CC78409A316BB
5A5F0BFED5601BB39B71A72726B24CA1AA67820CFCD913F6AB679E25A8B4B42D
B70F06EE4D70FC30FB047A05621739DB04234B79C85770770760D0B64B74C227
91CEAC9410A4E5A7290BAD381118428CB56827FE27B10BD5F74DE2D4EDC2F52B
5B6A223D3FA81F9DF14AEB3187D166B190B04611D372950F43A5E85219A75D70
CC64997EBC3DF4D1F4C99F4BB6666860FDF651C0CA2C6D47F97154101186DFF8
48AF6FBC2E8551FDB885A7DD156B93A989375E0DE50786151ED0CDC3C03B8233
B975EF4852C13CE97BC05D0B2CF09EB30330C77AB84D80CBA7190BD6DDEFDFCF
D7040C405A516C3D4E7F68012F7B0549973BFEC6CDBED2093B6496E449BD7A6A
372204E1857E52D7951CE2EEBF02ADACF45F3B52DE73B50E0163C719490F63AA
1D1D5480C32C2EAE500EDBF013BA368ABA39DB8C281863069229B0874CBD4F0D
42735C68C831365D798B41E1314B97E78A9F534E3D8AED8CE7F69339040D7B51
443F19C9CF524FBDF5E9241CC3BF525AFD5FEA4BEF8F23CDCE9A37D40253124E
B5CE13EBC7D0EAC31C84CF674BA9FCF292436734E8C123FC8ABA1EC8C6C9EA3A
587D7CC55B063BD70092EEFFF1A0B29BFB300CBFBC2670D46B007A6BD842D9F1
94145368719A338608BB24A1C149ED84EA68B5F9A2CF2A770E64339A64E29008
4661E09BBD33E28A611600A313ED9A6B48071BC5494EB3F7767ABF7AE24DAB19
020C2C86A768C077329AF9AA055935431639EF60B7BD5D6F5A192B8BF32B0705
6C472218C6063EB7106E9EB832DA99AB80BCD11651F24994B1CB1E02296B0C72
2A1C9A282AD214A40D383599E958BBE18B3CD1B3EFCAC58085A832BF4FB5A697
37E0EABBB4161E3E3DEF1F46EB489A09BDEE4D2DF9FF88FB10713B5CAC102D5E
82031001A2FD65EED173F3FB23F23A7494175D6157DC1E6960ECCA929AC72F33
CDC812CDAA1C8E07E689950B9F48E08C20A8BF3CDE854D67D0B309529C90ACC2
309105D1C612AE422A161F67F93281D7D005F49689504E5D6C7ED38328F574A5
343F4B0185AC7C44A9CC34C833D8E88D51775EB728FECBEFFE9FAEB8D0DE8012
69054B37654DADFAF819EF071923D440D988C1799ADEEB0619D5BAFA2CB895B3
F8C1954F3330B64475F7947F2F1E8285DDEA691E06358FDFC118CA674870017C
EB56BABB7B5F05727617292DD897C310B7106A4EA9B73143C6F85E0EBB119D55
A5D19A3BAE219792241A1F65987AFF11FE9E5A57BD4C20DA638D6597BF572F1B
5B628DD1B67E645F8C48FEDE7CD3465A19FBAF624382F3EFBEE287A609D9400F
8DACFA4097C976E71DA32681572BD35880C6E5DB86381B3AB454DFD09C4E4AE8
9DBCD2AF2C6F6DEE5D86D5161211520C3ED51E3B64AD9F193ED97C53F2AC5E7F
CF40C32EBC13BDDACC8F8295C0F57E18BA88E90F9964DE7F0EE2A4258021AE53
7F4B677C82885D70C3234BB3C719CE71FE64B56B1A28896D05C7899880A2A4AD
B914D744E1870725CBE0D226F6D757796361EBC070A53C5FF67C0306F3D4D690
F92F8000CB094708AAF1FB8CE818E42B219BD9AE5CC0AC58E599D68979C1B9D1
2CF4A0CFE079E71A57B3836AD4122114E792BEA13F8D2B16EFFE282D9D26E1C0
76E1D99E668A70F0B68DD2A8E09B2EC9C90E3749AF0C228841F423D93B2BE3FE
B23D943591FDFB508BE75265E203935FEFB8B340CF27E11CE6C8A25A66A79824
65843186FF2A8D4171571E362D2290254BCC3C651C1B9FB10EA33851C573B533
F43E7D4558D063D76190DB646432A3397E4BD348574080E268A20892890F36F7
F62457B606EEA4FBAE87B9574DFA532BA2D6DA713729AE9A282F855155A4B004
46E5D844100C8D9E6E1E46836CAF22F1A34B2C025B19E2529F199144AE79837F
044F33A2868C21080875B7CCCED0D056D2FC8B7EE27353B854896C8F6540DC28
37DEDD0C512841E289BA34F7732450A9E13E7324DD366A68DFF53524E483AFCB
EB5D5D6497A4BEB0C555B382BD620DB55735606B887A1899A4DE3172A2788434
B23D4B4006D47CC86EF37F5F3D942916B50451AE3402001A81F3637D20B91FD0
F80E249F6B49D91B9179D3850451D47F524268659EE0DAFF4649FC3CD644D02C
1CEB19C9FCC2CED545486FF368ABDC5EBD6738B56B0161B12F546E9B66AD753C
21F8240F9DE4249511CC532E61CF1899516C76AA21BD96AFF790DB0B6D37176A
D4818504AF28EA4DE1027E44
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-BlackBoard
%!PS-AdobeFont-1.0: Fourier-Math-BlackBoard 001.004
%%CreationDate: Sun Sep 14 11:40:06 2003
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice ((C) 2003, GUTenberg) readonly def
/FullName (Fourier-Math-BlackBoard) readonly def
/FamilyName (Fourier-Math-BlackBoard) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Roman) readonly def
end readonly def
/FontName /Fourier-Math-BlackBoard def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.00100 0 0 0.00100 0 0 ] readonly def
/FontBBox {34 -199 886 747} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18A96F6D1C771F81C4B3B8CF0CBC2E8
4B44D923DDCE84E17DAE82547EA9EA5E732D78F03AA245377BF0780A3752527B
6E63F6A41202E7A6C4E4F9330A0AABBD04387E12F2ABF531216BF498DC6B6BE6
06DD50B385DDB864515170905E2BF225AB9AEF29A2181200040460795735C124
59C90AE9BF9F01F42A2ACC5A5D97D4F6548FBC903ECEFE9FBC8492EFEE55ED6F
F29A7BB50432A42FF30DB3CEBFE1C2BF83D613F2C846B7F2173F00B4EE5FAA8E
12EDC39BDDF670F50F6AF072673281554416E77FF134014D5C465127C28647BE
3E810BBD9EC9F9580C21D2E9479B8F0435749734B76F4C06995E769710828768
3141ACD67803BC92D5B405AEBD4B25D5DF255B110F1EF1C35D45D24AD0B1E0C6
8816579DF17721764D5D2CE396276ECE1E6142DC2EEDF83FD7B65717064CF671
051D92A9993F82D241AA1C3254DBD3DC53886264BDA18DE9FB8F584DEC9A32F9
82A6131D7140BC7926C074E26639A7141B87ACCD64E61A25DD7E26F463FD7834
964655DDF83538CF1DEA3D6363DE79EBBCDB429279F84F5DA8035CE823A76FDA
C2FE77036F5B9D71C0CBB063689C0C9770514E550CDBB1BE97D763729B78CFE3
DD162726B3F3190F0003F4812E9877545507664B32A1BC0E6C933BA64EEB3563
39606495CEDCB8EA6E63ABEC9F3558DAA0BAA350F45A6E9B145480D9513B87EC
14F7551489E0F96B698A104DCDAEF9160549D551093AB3F5F7EBDDEBCAA3ABA5
F0CD388ED13E9611675BA045A8E99C002616ED89D1F3EF0537C6E787DEF9B5D3
F20879DF1555A646A79400D3EB80A209937A45A6345C4E51748D3A5C523F9F93
FCA3628D463FABD8537A948B3A3715BAAEE70345F5186A550FAC78ACD262E671
AF8FDCC133800B82183CD17B4EA18EB6AD976F91FE3C1447EAB9EACE7CAA00F8
69C9D899C80FDAA551B57BDFD7BFDFE5BE081D0AE6FC30D89B49C43AB5C8F923
13C1E770F0905663C6B7FF3B02723580D7B1E8C0DAA19968884E622821BC174E
58859FA90DF4D140C225017AE82F1C01CF0FE1952AC0CBFDB2B2AE148026C116
8E9D2D51BEECF04E3D194C3B62EBBA84552E741659DB3BEA3EB1887DDF2FF5EC
E616B5DDDF84603216ABD3CC62CCF91FCF4BBA041DB075C2A7DEFCE18F39B173
F296A12AE1CDD8B0C1DAD85E3F73F5D378EF9B3E44241869EF76C09CDA729288
046DC05F6A8281F31175DF235627E657CD3BACEF2AD0B700ACD6976C54D0B1E1
803BAB50CC45C5102647D7D2B835491465DD1A2507761E496334D370804A5E4A
5F1481C6A20C9AAECEBA628202ECD441DDECAAE92151F47AB7999A2290E4
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-Extension
%!PS-AdobeFont-1.0: Fourier-Math-Extension 001.004
%%CreationDate: Thu Nov 11 14:57:39 2004
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice ((C) 2003, GUTenberg) readonly def
/FullName (Fourier-Math-Extension) readonly def
/FamilyName (Fourier-Math-Extension) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Medium) readonly def
end readonly def
/FontName /Fourier-Math-Extension def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 56 /bracelefttp put
dup 58 /braceleftbt put
dup 60 /braceleftmid put
dup 62 /braceex put
dup 113 /radicalBig put
dup 161 /parenleftbig put
dup 162 /parenrightbig put
dup 175 /vextendsingle put
dup 176 /vextenddouble put
dup 179 /parenleftBig put
dup 180 /parenrightBig put
dup 181 /parenleftbigg put
dup 182 /parenrightbigg put
dup 189 /braceleftbigg put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-32 -2960 6882 774} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DD8F6FC13F6
FEDF4B792B4382E1B8DD4D6B66F7698F4BD76CD673F74E2FFCF34A3EACBD4F3C
C6A935F0007CEC07779EB225FD87A32485FCE17DCF5D3B7363F4BADDDE608D74
12F1DE5225D1BC9EF64A528CBEAEBAB7C5CA75B68EE58CD3BCF098C552B2A1FB
75BF21F58BCCBC9B908C31E373408147528CAD183940FA19AF923D72ADC1836E
428B74A5B3EBB55F5B6E33E8FFA3025EABB8E4A824D430EC40A31F0D72A210DD
75759CE62844F0F7D49BA3D4BD6BCF66449B9AFB9BE875F751E394E0A4FCA52C
D8C522586A8B3F3C5C7804B68E3155F94CC622FBDDBFAD41C583E43FDFD10651
DD5434E0FFB349BDD07170A0FFCF4250E226F07D9C2CB416DDB63CF486B33CC2
389BF90C05271234DD30D97680F6B41F2F0B28FE0C84893AC64BF925683F8DC5
3DF4B96610E5CED82A6C57C1FB68FDBC3B4B88424038E1CFDC34157B77F9B99C
F81577EDF8A82CE0C6DC7397945E5E5C192725215EEEF3F0D0C2221C24A174AE
4D6E8C782CA8C003D204EF2DDEA75F563DD5FB33095F872BC457CA43C979BB8B
2E1C6DB52A659C726EF3BE8A44E2B2B189665BAD3029377EF989951855031A46
35A0F75CBE72536243DDC09E4D3B70D9EC465BA6941D05D1D74BFF1C090C9996
15ED42A15A4C030CD533FCF76E5546E83980D04F8DD9962B460B3C60A99CD0FE
7B537712FE685EE1FE724EEA199D4838F94802526E95371E4CF3286C1E798B32
A642F4291525C954A6B2BDAEFE1DAD4CE1FB64C375A74D82F10CD0CF9F83475B
A369D5E80CAC68B65C1FBA3BBF1F862840E87BC0506C09CB74B3EE444827A146
8C41A381661337DFBF94EABDD4B743BE6C59A09D75F1D53FFE1ECD5A657AC072
0D8A9C8B302C0B083B8C0DE2AD196CFC2ECF729C9D0C76D13C92B809AC27FEA6
C330FEC170655CF30348614096A284A249D6D0B3DE0773AF74ED5B7B4E0FFD8A
D1A36B6B58BFB4045920819ACA5B5A6609332C16C8D21C2640DC780ADF604B19
84ECB3208C2DC55AFC5016FB2C4F62EADEF7E262E32940DB52D0635323E8E33D
DA8076CD217D78472D45D88F12CD081ACF2464284F56EF5523D6EE9BC66EF49B
A3F2E9C583DA5729C577026454C526D89B6B462950D2FC86826B08457AED0D87
6BE2E74E8B47BE08F29D5C260BBD9280E2EDBE1C80C04908F595816387879D65
69D2E42BA1351FA42FC6CE183F72C2571F46E81CE317A0B867554FC41A1E4A01
0CABC53339E8CDF172B872311C783A8F2BE80C2BADA50A28342A2B7093A3F731
4F4F656E97438C08C8DD404ECE7B7EBABB8F8300601476CD50E2FF84D9A07160
C8B6E2F7E8722E8B93EE7FBC1D5909A63BCDF12ECC6EA8BD938949438A3D3510
D28B3A9C69867BE3FE4DE1CC269861657DAE11CA5F1565C3CEA89BF225E2EB26
EE41DA48C15CE91EF664C3D906427BCB9E162EB6A073A1A82E0B07CF2B4B59DB
9822DB3DB990B06476B4EEC6F78AF8033A68854623B8207F86A25CF452C2D539
5E2FA6CE3FFF917C8E16FB076752D4BC1D166C3D8CD81DE1523273F64595E7DD
82E18C46FF0E8E2A78E4BC921EDB79D8F5F0F26D63E9FF01B2EF9BCD3F193C68
299B67BEF2B4140A9400ABF243674411A206650D57FAEE10250D1F488797E3D3
4EF2FF89A7C9709274D7BA4FCA504030CF260A27075D95947A35EE641396E567
24ADF5FF2B71CBA7A1BEBD1838E94D86095474438D336B744A94694B0D4EAFBE
71E40E4E2B1B71D865367BD33143EE551E5212323E5232F445280570566B7F2B
93469CF1440B1866D79498DC6A302B5F8ECBA2716CA2E461536B8992FBC80415
296586CB29C48E250EABBBCA3030571CDB4AE41E31270BC079C7BFE4625B7551
39A70016E777127BFD1F3A5F8FDEC962B7C151CE6FE336271A0D1FC6441CEC50
B9D32D56C8CF4E769F390575083ADE584EFDB49F97517C3762204A17EA4DCE06
2748508512E82E4F207783973F4FF52049480305529986E8F8EB6F3F183DF094
7C23F84E2838D99807935B8B4D15BE2F88B4423AB0B6B789B6B51B2820142AA1
372D49CBF8C37A381356381B2073DCD16124AA3A1A68903D7230B3F6B06D6DE2
D60B46154489BC2867CF32C6179401D945B37A6194F98D79BED611B22026CCDE
84E55C4233E8ED26A483C044CEE0B3EEBC1198C4BF14B61684EF36BD9A13C5C3
84C3234A7B409DB7442BBC810AD2B4513456EBFAA3A48C2BF97D62E229F91270
6DF97018EDDCDC5217DE0B0DFC28CBA6CAB10B55E4C75A79B1070A1DF50A343F
1468E4FFA8F51FA149AF5C65A83ABCDE3A19ADEDC93F568A262CF4572325164F
5082BD76EC1778765CCC40EB5F22E055EDADE681B07969CC5E81BD5851B26298
F8178C44E8347189065912AA50728FA696FD790C99C55C74FFCC780315A037E5
BE62DBAB68777BF7F3ADF93CAE49CF2EB4F4A2A3557CFBD20B2B9E06DF79C195
6A1673FB120673696E1CEC012B575AE1CA804ADB6D16C3DB8CC872E053DECB97
2E7EDC57EAE360093438F719DB59CFCF6E4D7B5CDD368AC62F0C9CEE6504A2BF
00D8269400D2452BFBDDC2F80A597180F73EF5377988E87F456960260ADA6231
7DDBCED9E9B1E4629FF90043770FE8D9EA96D0812C52955A583F989EC1BBA93E
7BBE5A9080991C85B198FE20DDB6F1F22A45E8B7876688A94EE4E04709B1E84A
ACCF4B260729ED4B092711D252ED600AD5932C166441D727754B379AF171DDC6
EAD25D6E9EAAA97896B0D94B3A8E791333F29A0558B1BDC7619590CFA8C6128C
2B16829563620AC2C45940A34443FDEBADDB6DC82F94668EEE410B1BC50099B1
54D0A129BAE2EE34FF33EA75C2A3BA4808FF6CC8F3F259C8EDBAAE1A2B11213C
A2980E4DC7198CD52FC0046C8C3A488C9BA9B5EF7E914947D998A2F590718184
1431FFA2542A25EC45D33AE2EBCBC29C2B00C25DCD6930F7382DE9189198E1BB
E446825F706F90F70D1FA2A072BC8699BCBE73D0CDCB0EFE1305C6EAB7FA5027
D51D3C4C96C93D5DC2150A38BF9F48EF52E7F2CA921E17689AFEAD0F3D2A9D51
EFC520F56F8D8B33CF05C11708F9D1A401E8AE1C1720846CA76181DE1E4528C8
1F37EE54C821D1C61F0BC310E6FF281103973B5B41A1B4DC97E0B574DD613D6E
EE820A3653C52AF87886FB3FD66995ACB6FFB5CBA390EAC105A58171ECAF4908
5FB05DA2123119308640BF109ABC7962A7A5D7C3857D2E551A4C1DBC6F0C2BD2
0E78632F4D766DD04E4FD8D1055E506C878393D3592E625641A89A270BE9F485
FADD0346C9FEDE554D923C83207A762653D675059830FB9C04F17EAF2015E606
3D068A5375A87213FA874510953A3D94D0E74DE356A004C9D801162315C469B8
A9DD70B0B8C1FE3AA5D0FA828F2685B5D327195D2C19220982E7C9CC8821B041
3323412D2C6E17D4B38D0AA5460123FE593EEE0C430CCC87A8521603B8CD7565
F0B9C0DF4FBEB261C6ECA7F2C817E9F7163E4F3C6B6EA21BCDEE80944CEA2A77
F419DA5AF80E9A5CAD787C8CA5FA28F7FE05B8D2B53E6BEEB5F4CD0513902F0F
661915FBF545ED41686AEC743490208E21736EFF865BCBA4441CEDCD28B8DD48
9EEAA8F0615A8932D37C30A42351564E4E46F9FE4C9CE45A2B24B539C126F934
D83A8B79DEA3E9B46FFBEB77F7FEC1442D45C9ACC038D5A9005BD7C4FA30BD31
53071703DC40CB9AB17E713559D976428E280309C4F7A96DD740D7C50980621D
1AE2DA53A6C8042547CF6443CB7EF7911EB8BA7DDEC13B66208ACB072FF45E74
2074E0899B44
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSY10
%!PS-AdobeFont-1.0: CMSY10 003.002
%%Title: CMSY10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY10 known{/CMSY10 findfont dup/UniqueID known{dup
/UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY10 def
/FontBBox {-29 -960 1116 775 }readonly def
/UniqueID 5096651 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /minus put
dup 33 /arrowright put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A581BE543D73F1FED4
3D08C53693138003C01E1D216B185179E1856E2A05AA6C66AABB68B7E4409021
91AA9D8E4C5FBBDA55F1BB6BC679EABA06BE9795DB920A6343CE934B04D75DF2
E0C30B8FD2E475FE0D66D4AA65821864C7DD6AC9939A04094EEA832EAD33DB7A
11EE8D595FB0E543D0E80D31D584B97879B3C7B4A85CC6358A41342D70AD0B97
C14123421FE8A7D131FB0D03900B392FDA0ABAFC25E946D2251F150EC595E857
D17AE424DB76B431366086F377B2A0EEFD3909E3FA35E51886FC318989C1EF20
B6F5990F1D39C22127F0A47BC8461F3AFDF87D9BDA4B6C1D1CFD7513F1E3C3D3
93BEF764AA832316343F9FE869A720E4AA87AE76FA87A833BBC5892DE05B867F
10FA225E233BCFA9BB51F46A6DF22ADCEACC01C3CD1F54C9AEFA25E92EFAC00D
7E2BA427C25483BA42A199F4D2E43DFCE79A7156F7417ACF78E41FCA91E6C9EF
B933450D851B73A6AB6AEA7EE4C710CB5C14270D1674FA334686653793FCB31B
491E870D3C2BC654D2C1DE463EC9BA29D7371AA1078800EF93D3F66263A2EBBB
F5723697BF7448BD0D2E301544BECF497FD475B85DFEF52AF4F8F8BE445CABE6
019318806D10C5952157FF8F8286C1EE701545C8F60EFA854EAE66835A2046A6
915D395F1E0366EFE0C0391583FE001FF16D82A2E2DA5F57754A2C6F69306E36
356ECF8EFC3F1188AD6FCD2427E0580C97A5B69B4E0E09B85EEDE142F5ADD2F0
5DE51D6DB72B127412A0D57106C19CA493048A4F815129ABE767D51715B1515D
9C21067CB5BC88741B7298C83EAE36A866DFA87D8981F179B1C31292F56BBB64
3C430779468AAF07C8A8B4934E1E775FE3F35186BD1FA6EE3689C1C750678AF1
FBF9B23195A124C5C991FE670AC0C86FD39D2B07B9A319E74EFD498B45820252
720ECDF7294F7B0B137CEB86D33BFCEB8606985A3260FD669E461C8BE94216C5
D434FD8854F44EE66E5A289A9F9E32BC36AF645D53F96652602BAED418C8D726
BD04A1B4617551FE4DEF54083D414F7DCE004E6BB2DC9C2EF7CE232B254BA2C5
7DCBD36C2072ED46FF711F121A701E2284BF1B718B3164382B8F453D68FA0377
DFE106503B8401D4DB87F5402A3AC9A442FA060B0610A9524D530C7157C26B56
AC970FCC1D5655FFFFA39246E6420CF97D08ADFB7B05822679BD40C638DDF0E7
A97BFE8918B611A145AC965C203F1428812F9D340AF499B3A915B22BE798594E
0F520109FC81E452180AE45B170FF999C5FC2761C6CECD8742A5A6FC97F16743
AD4EFCC6572A6D3F3E4E330C5CB2FF6FEA48A5B64DD3DBE943BD9918D4A18E18
CBCF598AEFBB6AB3CD2CBC9BFD6099272F6543F3E532E0E21E614BD2880B1023
0AC234CB705827BF016DB84E00E8C255FDEFA0101A842929540B7B4AA8A089BD
5EFF05B72356B6BC3727817823B5CDBB1B963103000D7F2A4E2A1472FC3E614B
5CBCB6D6D784023173DEFEBFA8F9ED87EC1A0A9EE98CA59CFC964CF943DC683F
E9E00DA718C4425A705A69D99988EC6F152525C790912C2E46A2381A569424AB
54DF4798BC2D7E7A361E7991641D4B756CE2A7FF4A2848927092C59C2C4B8809
E13AB84FB6B111E680D7FB9F2FFC2C5C66B0B501E4447C2E46C10E2F6124476F
A140C404CFE2DC9E0199BF61E035CEB481D438139A9630934E541D261FFD2906
4CAD99E20655FA746AFB81EDBB5601F5FD6B1D6832A01D585E2C55053F6A7378
4DAACCAC7608DBDADAAE732D66B3E7F87E79756337C1A961E53A4651BE7C77F4
038B89C87F650C54A2A90EB7F1D525BB353F33318551EE8D84A6A83C718EA5A4
B2AC0F7306B1E095819B87015A90CA3ED739B09061782C28CDB36BA4BD5E5308
5CBB70414E4112193DAC4A1FA30996327230D1E021F3CD8115E12D239D93FFDC
B645910EB29E40D830E7BAF2DB255FD7C4E776557BB38157917D993EAC245837
A3B515147043574157B8342D829C7228CCEA843ABC89D1785A9672A5923FC4CD
2F3FF27E6FCACF84E2D3136CA2C0FD3EF1EE7354CD04C38B5FB874553646ED2D
CEDF7E362EADD04B18051F20A8FB0DE18E152385B9D05F98A3A7EF177824E246
455ABE69E2F700EB78185CCFC07E3B4C6FA301112528D977367D30D0D5D59EDE
FAEB706DDC970A9E296236C725B2B55B09B9C336B8E23CBA5FB8692D56F33B03
16294E5FC7FAA42E96395A57CE51CA8DDD77442F142E2E576B778373FB31C81C
16840BB422CA827E30A81829648BDF1CA36700EA32AD888D097C1FE0A05B2D9F
483AEE40269DF09AF0D1AD3DF80C45DDC59C2A03FBB661C79B87853737C6D352
67626B657321B16198DBD6DB98A092F17878AE4698121E1006E53D6F9B0A3BE2
3FB68828EF854A0CDBAA68B37ABCA6AD4A3D809AAF0BAB1697A81FE59C98C472
1E33CD70A75A22C249DD11D76C2575ED3370A25892A16D2FD569CDA70C130770
93F493C7D47D6F9A5424A7A542BAD726BFC3AB225DCEBBE6AC4BE006F8C7C0EA
051424B08305BF2D951AB2986AAFEA04E078CA79B399585BFF0F1ADCED02E15B
8765EB6BF6A8E4D0901EFF2C3AA104924EAD9637A35D877E0C51A3C37DA78CD4
8643C8CE6DCDDE3F116A6C2390F948E5371BEB5AD2E87B41C5F01FB5C196C436
6E256A88D082E3F46E4EFFBF605B2EFF1E9D9AD5EE4DDC323A137CD9451EDEE0
06F7D82898D71FAF2362C0FCF1F726F97F820305B7CE20728CA08C63575083A7
84BA28B7DE2B916432475510E274C12FFD1660A717F51DACFDF0A102D85224E0
D6DB607BB72569ABB8A7BC6A10354CBBC01732EFE35B72062DF269CB25EA3DE6
DC603B04C90C5912D2C38D7A5ACDCDD3F6F116D884F0D8C528F69D5D47BA20DB
0A9E585C7D8CC3C324FE8A1DF150279F7E8FB43BDB720E624E5E9918032C02CD
8020636AE5C38DA2484B7F4B34163E0D0A561B43B80E97746DC05C871AB620EC
C5D47101ECED4A7E25F291184BEF8B80024AA7BB456C1B83A907652B331DEA34
754226C39C6889EBEEFDAD081E01EF8FE47751987667836FDE4C8BB8A3FD4406
1E643B4EA37BD370734D1A2DB17C2F4B74B4ED75098B433601F75A88C9A37A05
CCB157EF6E32023BFA33973F3E655A4D58289136996FCFA61EEABD70791B6523
1FF5DE71AB8A17038923118A5EED8D59C4C58D246FFA9BB26472346B40C8741F
153D19CAFF20DD2A86C6DB89154A630FB1761929FC3F0448EE2F089C1C953E02
905BA8DE75D101A982A611056C4B237596C10951DD98BAB838B742D3CF7DE718
617DB72E5268583223E37E029D1C8FD3F1D21690151F76B76C52C725CA135CA2
8666553E863CE188BFC9B99AF56AC2DB5BFEBEB12FB563D00244EB89E478657A
98AF2E1223C1ABC25A4500E8119B86EB3C26B8A2F3505A3E5610F89B7C34E278
53FA0A54A7F46D84A35EFEC36AE660A9E3C37EE3864106702DE5AF6C45ABF64B
888A4A51323138CE77DB935576FE6B4824B6942DF80625098CE1B5B32B234F1D
052A9D6039697118A9D793793775D8729D8574A2E74D7109C7B7E23BC5E2E87A
CA8E019203952A4892544E1AD3D4EDD22971611358AB230E9A2ABDF00A288501
A01B67C42B33F6B78C39562DB50F4663B922D9BE0D8A150311AE44B83C1F129F
07337323E9A23211EE58E16043E127C6F9574019179F5635648A011266677B56
B5D0201A4E1470B952A1579B57AB2329CD4C615395023C653F784D36B5EE3672
10D191F29EA508CE84763CA4CE7C2C5229E38E241255A5CABCD6C7CBAED901A2
CA53B5E24111921CDDF83578D33D463D70EDACA0E470D8F592303FB6BFD68B4D
3F3BE2D7C5EC8BBF10C90111A33E205F2649B56E8443F6FAA6C721C66575AE12
D4C40F1F46CF9E9DA675AB5D5840D938780CD9E4AD6736ECBEB6A4397613586F
849B51048AC5F9405E03E14540A5E5582F61CDCDB57EDDF95A8C6705F433EE16
648F098C03DED8A2AD94AE3DE202D629B9422ABB031318D48F2C85F9DBFA17BE
84708AA3B6C9F81F4508F7A5CB7B6646AB8722ECF817877B77D473F577556DAA
2BA0ABACFCF5DEA7498C47328E873019A956FBB250FD9D8885D21D368FA70CBD
2709D2DA44EE7A9869963EAB48789541906DE49FAE785ECE1F18A22C7E7ED204
9768896B78E9EB7A2BD6EEC1B26083940656ECD689D92942CC8AF05CBF82AED0
B45A7DF4DD7AA6526FB597322560B9ED3087A65B5EEF1371C328A021411BFE3B
D9B5088B2F1AAE381FFED52D2D1E02CD0DA78683E3B06171CBE94BE9760005D7
135893D7CC2DB097F6AC664D9594CF1C650F84DA80D2EDE04802DBA33CE3DAFE
EB7A37E8AEFA4FDA6252FF21E8673DD98E67124D5DBC7BACF361E57077B71939
C1D1FB923E4E35C075CD1BCBE0E80DAEA1320D55B43EAB45D9B26C366B278782
7519FDC482D98839BF0DF2E7C3A56A1C1A3FC0E57A75CA414F6536C1FE8EB7A0
4ADFEE3BEDA0F53BE8CF5F64230784A797133E8CD46BCCB3BF38BCE38A73CCE2
9E073ADE792F7128231DDD1F63E6156ADB2609C200837C2E8A2D93D2A7BC9171
050C709A71E44E32B1B03C92EB5CF1D3BAB1C38E027DC4ED9AED633D98CD7486
3F773ACF8AE332631CF2ABE6D606607593FE862ADE31803964E3F4DC3CE3A271
C76BDD95C87CDB3B87BC26FC7A16D567EEC62E6FF0D471B4853DB8A94D4CACF8
843824F818083F10E88D52FC4253E8203292CB40F1414AE7E51DD7347007C342
CD70E8E9F2D2A13D71213B841DDEAAB208AD9EA644591C15DEB084165F9DF24B
B91D3BBEEC2E34E38EF16A0C3F00700A7BDCBBFED2EC0D09601AD6538288DB50
3478B051B5E16B604A0341FE621A58718D960D699D3FAD284310DCF54EB13175
19A75A539EE98E804AEA24689D3540F0F12951A3C01FACCE9A7BAF4D0DAFA946
FF65A4D2A4C39969607272C6886F44E90ABE27CA3A1F12A29D9B32E60E8E34F0
17C5FE43D0E69A99A922D98909B2BBCD145E59A5E7F5426B3988F73B09A525F6
8BD4915663C1301323180E760BE81CB874B020FDA3AE63340E4261E4F3E4949B
CC0966BDC4426190BE9F5D77F76A72AD925662E5FE1CEF9CCAB68F0BD33DA003
F11EB91AC4502FBD6AE48DA0F9D07C35B96B103E379B8A83A05FE728F1716194
1F650F75BEBADB2E3810388F3E2DC7B19F1BA9E32925F2FD9F19F4E8701F3E4E
4069125D7C401144740691E7A460021A47B1E27997FC1DDABEC5BD0EE0B20194
2D579C7D6727AA124083242BDA46D8E116E2751C5F298851A62B60AEBE82A929
9B9F2492BA35690D1EFD16215B8EF14E7A3803B93C28FA41D971B05B6AF3B593
E74AD1E68A5FCE12A86E63B78BFEA87D3949FD164F12277A4688BE96356791CB
8671C49365608F3EDECC109321AF92B4C29CAF073DA3A7D73E913D0D83FAC5EB
BD884D4C686056404DAAAD6F82F94F803FA1FB0DD8908D1DF08FB87A8BB83027
04DE0CBB1C6FEB6B517FBD7CF065120079E608CE41893C2BC96A347826CCDFD5
C69E161217F2127A59F1A6F22037641613F191F22D5B4CDCBCC2EE5615623404
ABA7BE6C5FE475481615B2AC1A2412E54688DD21E44CC9AF5F16E634AFCA389C
4D740B7B51BB141BFAD1080E7C726C1606A28ED492E6BDE9F800EFACD1513909
84E98CEB6A0B7A2A6F3E1D1DCC3B2552795E0932673E59ECC56DDD37A1D52BA6
C3F0E905978AB568941A163F4CE3AAB5C5B16F86016EC47BA6F3F7AAAA77C3B6
09C8C3ABDB6D514A76ECD37C37AA88B5860630B3406B494F7725975596F84777
D9CF48686EC9C5DBCC1D78513F591C7C10AB9D153B3D41426B7BF668B0D04503
56BCB686258462C1DC61095724B9F3312316262FD7C1AEC6E54DE7E5A7BD8EFF
035299B8FD8A4A7B0F51404F4A760F4D8B4C0FB7A32FA4B2383AB6E9C78FDEDB
FE6A5788D38A6701B123630C2A6D820A684166FBBC83DB17069494FBD411B333
CB37E2491C5BD035A33867A6D3A3D420CC31ACF43AA07182CAAE67E40EC63663
B678F71D4C6E0EC3A0AAF904CD3AA66E0DE5E3CDE049E94249B39A1C06E3CE9A
F974B2484BB2CDA14282B9511E505B3C89F9C802218AE40D1A7541335C5736DD
CD565D4B9F4CC78F3A393737EDB4FBD0DA299E21CCFEBA5478EEF013F0552A8B
0BB11FF46CCDB784E8BDCF730A16363E66572049E42C695886EAB42A9AD9094C
B635DF4B5B9BD9B9AE8455DFA3EEFC77653190F9A8B1E93B7281C2A21EA7DDA9
33484745BDF7E3DD63C7AC66C286C9A5A698A5E4D7A91710B7FF943FB23609B6
4B442F83CB795788FAB5E9CF3F75D5487DA26170E4561C7941C910B088C3B86D
F844B0F340CF82786A3FCF347048463EBD2006281A816627065DDA6CD4D3AC5E
2024BC96C7D896381BBB567951E7A1F29D4E95351298B000D29E5F3D0448CB5A
CFDAE1BADE9403B90371C3A07D208948AFA022A69C519434B6813086ADF518D5
88E0B92072A44BA1B3EBB630A13B7AB90992E85B6D67361C8D96F3E0D826FF37
17B67E4B1EB7BADFD98D7F4FD17BECE740ADF13C141EBF0A91CB105DABB32FE0
55086D56A0D358841D15FD349E6B95512E4EDF4C430216FF85C2ABE995E4B40A
A6044CC8820AD885C07E052B3F91C2E9A1D163BFFD210F7BE95B923E2500DB50
2075106DB541C267BD450B25B670CE80BCD068D4DBFF2D82634175B61FBD3BC3
406131F44C7D6F18D375D1F2270829DDF29DC14DBB58A30AC193245D18DE91F8
AB88AB548D8138605BB5A50073295534E314366E26665AE70482B890E4101D6B
60E4F3B37ABCA1346DAAE8FDB8DD9C832EFF3E73BA470E2BACE7B8515CB43388
C27AF99FF9322175CF8D4947E6B3846AFF5163E972156847F58A66660EC8A3A6
5FB47C9F637B4CBB4C73B6A080B0CF6FD1E9665E92032540570FFCC747C67C50
822811AADC404BC7ECD1673E8AA6C3A2F1D82F39430B58C29145E2F1B679C46E
94EDC711883F1E4EA84117A54757E8895A40401A26E1437B39A2F65CAADD6E02
D71FA8AF7453668DC613F326A3344F74AD7AC67569AF399385500ABDA5EDD3BA
343CC5EDD4B558467626850E752B9959FEF1454E53E7A3DCBC2255AD8F6AB4FE
894455118A61C58840CB68A925ACCAD75CEACE863D806916228F0614191A1CD5
DC9BAE256018615AA3725834519449B0A88B4F396654E74099C007930ADB1327
DD119BF799FE3B0B223E1EDA04FE2DA7A1C879143E1C33B6C6344F4BA033AD6F
8E88C33DEF1977796B454BAB2494C930F492A518E8198C708A75FFEF8C49C324
A718AB59B889DED521229E741FFE53F98EBE88B0405AD523254FD3FA4BBE96DA
DA1C27C1C979A0DD4E61C3B1F4C4DE01E42F1C4435EECFC02D97994BC8AF5270
E7CB1458D76ED0229C5FFB4A23B8716018F9050970895D51722CDE8F2EA3D947
DFF374D84915D5C5D16463A6FFCD079D1ED416C4347BF831FF0C4ADFB61295DC
4D5785BB0852BF472CFC97EC174491CAF961AB90629F055E75DAA6D9898E8653
5BCF379816CAE46FEA62E7BE8E9B953466E51828172C4DBD0E1BBAD1CE28B5B1
02B3E36403BE80B49A47446A6677FCED438F01D60EB10F478C89528FA337D0D8
88D3FC123C076507ACDAF783A9A6E24ED73BF24B6E0F11C13E532DE5F70EB02A
60651FC2E263002D3986B7B20CC2AA08330B9FC2E26765CD52266969A86EE30E
71E0B41B6C1C6DA423D3A7E1553D2FAF26EF40DC183099322D362E4965695C52
9FC3E5BD7ABD743CDCB717DB10372A722A39CE53FABB454EADE2179C4CBFC016
A8E893C28EF549CA1692C8D8ADFC471DCCDE266FB4E97A1F3035801F3F034D44
AF3863EE8A24A003F07FBF0DFBC12CF2625CE95B5F1C575C28144E1D3C8CF5D7
6D071DB7562414E228147876D452804B3142DCDCAB22773DE75726823F1BB198
1C1CA8D89B59FF008B054F0322A543DBCCABA518AB9945020DF8C049A6E112C5
3F67BB74E95B7EB282BEF7147BF40C5A3FD4BA839B17CD431691921679ADB9E1
D6EAD8E8C273099E6E5746323C92B16886E33009706CDBC81FF7B5D5BB611934
7A047DB498E7ACFA77102D761F64D98C3135AC26A5ACCEDE71455F41425652A2
826AA82257415492A460656D594FBACA8287CE1A05D465E3E56A04812DA0F2F9
4F98E3144143B33514889C255204901EEA0A8F480070082F18DA981E95E09E12
DC0073FCD7E6242C22B24827EF073C7957B719561D5B040B3840EE3404BC0F42
78313EE13A9F086DC6D26670F347DBEAC0517DA350EB73A1C5D869E144A15D7F
EB8D39EDD1190AF018AAA72EC88E86CE63B5
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: stmary10
%!PS-AdobeFont-1.0: stmary10 001.000
%%CreationDate: Sun Mar 22 10:51:38 1998
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.001) readonly def
/Copyright (Conversion of metafont curves by Metafog (c) 1995 Richard Kinch) readonly def
/Notice (Copyright (c) Taco Hoekwater, 1998. All rights reserved.) readonly def
/FullName (stmary10) readonly def
/FamilyName (stmary10) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Roman) readonly def
end readonly def
/FontName /stmary10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 12 /sslash put
dup 16 /varoast put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox {-123 -2958 1055 803} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA3140A8A4C99ADB
B3214E61CB091BB87421CEF35FF5745EF8DDC51293183D75AE11F26462B918E3
F15A016BF051C59D797E59AC042DB329D8738C9DF453DD062F0BA8A59E23E500
D03758832A6150BF51F1096E643C98DA553929EDAC78FE0F28B0D59B9D56721D
00317093DC68A43C1B7BB7F4EF1D185ED2AA7A6E6F2D367BA67AFB0E7EC23092
A210DB79335BDA6ABBDAF5E5C4842B0A1EEA9B308FEAF483C1E8ED22088C4876
BE91F5D97B1EF9C6C943DC1FED8893EA22A5A265001D8B50A4F9FFDF83700265
B2385BDCDDAFC00F453DCB457F0AF33A1D8FF22BA6C4A7951F591ECE699C3D14
E75F936B66F381315F7DABAF8408AEBA61B6BCCD94269FB8AF5614B23A6FAA9B
331A47310A3337123061ED33479DD2F676F112024F940969472F7302693D0058
762EFEB05BA41394AB193F4563F3909CDE861E5D53A6238C45EF9710BE15FBCA
5D20A8223E5B377CC3B3438C5257F4033D36D2F6F43125802E53A348A51F9D87
A07E47DE15DB238C3B64337A44F4C88167C0FA1671468E030FCD02FF3D075687
3956DFF8A78C4BBFA06C711CBD066DE67958FB6D857C2B8851B1759285D79A11
EE35885A02259A2A785C64151FA9BED5BD06B8A0F84F05696E88FAC35B54F9E7
468DFF37F9DB581707C977F96CE3585CCC85FE9481C8E7ACBB9CCAD0B4D05070
4609CB0F1CF22B7C2F2BF7DA7064EB101904D2E7941490B5700104D9F84810B9
3F60D774F2FAC9BF95712C97B1F097BEAD4EDE4569609C00D66C3038FCAF7C14
6A92804F163A09FE1883EE040640E8C9E5476C6DE456D731C8DFD998B1DE9DB6
E5FEE8DD02F53DBE587DAD016B69F8AAC48AEF9D9F3379FCD592E02C98E65265
B0330B5F90F3B2FA275130A38A51B654C98317E867F78A93B8E847EAD914493C
6D26742E16DCD21E6AC62884E41A3CBF9BC0BB4B083155753E262EBB88B1188A
A5757A22951FCEEF0035FCDB592821C77978CBDC7BB06DA2289639211F070C28
6D6107790BE7B3C7F55F6840440E36581874A117F879FF966298B0FCEF744C8E
00300B4AB28E3A0D20565BBD3D4DAF867655D5FFE8B96DEC9F3E71E5F4A44E16
00D8933AB62879A541530FA1ABCA84E043EF7C2E675BCB40590BA9D435447676
89140804E1C76BB320C63B321F0584F9AAF0614ECAB678AAD39EE166F390229A
A4D1BA04705ECEE1A3B05891760A851D130EB4C679DEEB63688A703675C9D7B5
E05E240FFB0F37AF9F47B9A866BC0C033084C8A255F24A56CBA193AAE82B4C2D
0B8D22501B3CC8550AA16CB3F396AFE9698441F178DA69E28C155A80E7E41043
66D85AA6CF0EE721376AD31D13A4D2FA8029E9FEE95E76CB6FD5D423CD9AD6C8
E954C24B7F8573AB5B111BFD0E18169DE9BA9FE9EDB0B03E98EDD9DBE2E0970E
F2443D74EFF7B3A7B5081A0ECA4C321268AE868E0A4ABCB4ED07D7D3F77023F8
16C1DB53557010A295F4B7B6EB19BB9881769640B5DE7D1C3E2FD5EF4A1A3D9A
DF332D30A0F059508C4B6BB3B2AFE2E8C7F20C57D98A2B7D6B5B177C06DFC8F4
B1242B786A38909E56BE63396EF1C76B45800591928D86D15FCC0E23D13796B6
FFC23B6B5F5399E67CBAE6C7AE04F37078A5890CA4BEC21BDFB7D329862FF25A
7E7B93EEED6B3BEE88EFF4958CBBD58D4CC0D1103DD520687188D69E3D641E4A
975C48AE19AFFEC4E5267F34E8F208D1C5B9D04C7FC5D4D47A9CD10060894DBA
6DB0D072E8B9D7F97AD90AEFDF77AC22AAA2D41061D21CF240E6E6FA5BDEFEE4
4BB3CCFC61E41D7D7A2AA8FAC20C190520D776D552199B0A4A7E78A8F35A508F
81D1FAE01E15F712EB7026D6E57E967F6639D75CE53733CD2D921C10DE3CCA68
74D89F236E3128345554BDD39AB482783E3773E1A9B12DC40B55E10CDBDDEED8
EA347DF43B25B16FBB7ABBBC89F5674E62C1BCE02A7AD802E5D12E8A989E0912
46341B7B143B147D901451807E5BAE1BC7EAC2A7106F4EF0716F6487293D3468
A152BF43AB9652E8E4A52BD9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMR7
%!PS-AdobeFont-1.0: CMR7 003.002
%%Title: CMR7
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR7.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR7 known{/CMR7 findfont dup/UniqueID known{dup
/UniqueID get 5000790 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR7 def
/FontBBox {-27 -250 1122 750 }readonly def
/UniqueID 5000790 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR7.) readonly def
/FullName (CMR7) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 49 /one put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB981ABA2ACC9A23A5
3E152596AF52983541F86D859FC064A0E3D5FC6647C3CAB83AD4F31DDA35019C
CDB9E3DD3FEBD4C2B36BA3CF6E6C7DA85E25D8A31A9BAD39BDF31FD0D1790707
9DE6A078E8A409D8295F642DF492AC4F86AC84383B0F4C6BAA7C22AD5A898A71
D6CB34D2CD12266C486B75E75A69C14819DD9BB8159088E04D4717E576B8482D
BDA52110AC8B8A80E4E9D58F470EEBD3CF44A1E1EE8DA318FFF3611B02534FC9
F4018C7C57E80570D2F634D98BE5D5EC6D95051157F0EA94A3D12BE0B4B79939
F82F8D73136D3337C44E314B0B16CB030D9A12E01FB667105F334C3EE965E5A3
D410D2F1531547A4497C355AEEB295CD3C5334BEE5232992960B757594B89F3E
52095042DBE6B4DA3C3AD50CA95EA9EBADA10630B500CF1FCCA7D60306743681
7E428D33B7F7C40B425CD58E4CD8AB474BCE6A307BC6C6EBC15A8A96E0E2977E
A33389154536F5C5D8CF036D07F24094E779E5ACBE5502C92892F10F4C6DB627
C7EC4C7BF20B39418A8A85D7FD9B0EAAFD871DDD41F93BDE5FE619AFB8711824
DE890E62C1969A6FE28DD3578AF43D58A728FAFF0B9FAA640962C8F35A26F76C
67F3548D6DB54A25CEB368B47F97EA2B0C4D7C0E7894A4F0C823C6C1922CF9DC
10E05600556F1C7C9AFB33A2DB6F8730F70D6BF94B1FB0887451F2FFEEF3584F
DFADCFA9A2D4846B8F0E51620E1327D994CDF973B837D10C90FF76DE22B47CD5
EE3183898D156861AB4DFAD34A1E3FA260B8164E6680BF58413A553E88F6100B
C4F4E8E972C81A5F88A7DBCDC308B4C3581BCDE13877B976B1F84330839FE5CF
C78551620EB803DF94A5C921F8EE24F7EF8FC4C3E1653514212631F54F90E3DC
E9EAF96E998F340C4F729ECF7AB430FDB7C0BE3DF2C0D23015820E28B743CAD7
7F0AE95413C3EEABBC69E852F53EE1DC260D7F1E712BECEF2F18437DB23D8E74
2902AAFBC733AC5BAA452DD6F3671859AD836C8564E99CDC4183D8495AFD99D6
1F0D65B6588CE7546717911E25BDCA6C2649E3A7466A3E2DA7C7994A30AB4449
672EFD00632EFA8629C1AFB7D53D801028F77C864869FE636213A69173003EA6
BE1ABA95EB07B13D1594BEFCC95ECB0A9CFA9892EE0677D6B6C250855762B7A7
8E4E022640F93169DFA0303A0D5E73BF3E0F4D4AAD10FD7E4EB20532BA30371F
E9F480F9513432946F9828AFB5D4AEAFA5829B2CB544E5EB634C4537EF7DF08A
A1CFD94A52DCF0E7CE4C5EFFB01E6D50558B75DB4C8D5512B06080F27BE62E01
2EEA6A0357441401458C842D3DD4C35B8F561D816B336216CE0C14BF77648AF5
E33912CF95872A1E1AB9A18980A0B29A881D13397C15E1CBA5D3E0B27943EBE2
F3003D15EB446BCFC1C231832475D5B7AA19E4CFDE119D6CD62D053C6D29C333
5F729791D17B3F7108074EEF4D1BD101CB33E01004532CB0D716D2E54D169C6E
80163E70C0E9081F31A1ECBAE079D2A518B790B0CB2CD03DFD034A0F4788E800
B0CD2DC1FAFDD487C2F381EBAB2A2F3F3AF82021B211DC9CD2FBA6A1BB3D4AEA
4C7F3D9A5C21DFF284CCB827D205A69638E98D5DD8E36AFC1A4481B5CB2A2E8F
D6C838DA6F81990F5ED928DC7457501B5C979FF4CD20A830896A460C5DB13D56
A3B2B5D9B292374A9BF392894DD99FCD6A1E655AB395E839F074D1596488700C
4E2891C8AEEF66568E82A8B826F9A28FF84D4D9BDA21F638EAF96880B4EBE0D8
081982F34831A03BEE81FC177700C2360D2A48915EC40D5FE85B400E175D5AF1
067FA0097904FB647757BB44B4042D30D1557BD0F7922D731142FD682139CEB7
58CA4C8C240A0B86B1888CACC507E24E04020BF1882BD9B4CAECFA97DB24D7F5
AD64C69454027F198BA35881B94EE9159A2D73E450C3BDAED66B886D6DEBC84B
653E165176228F88993F12A170775A8D7038BDF2FE8DC1F7B98BDC02D1E6686E
9B834F6C0AD90780B17DFE25F0A4E470CBA84E73F2D22BEE09A040F14CFA2C14
0FDA5A5149B5FAFFE49F55EEFC43831BC43A8326FEE9C7F469C0FC3B000884FA
41DA7318EB57262CB96FC4EC7F16CA07FE1C3BE8C2DBC8A8135953D6DDF20BDF
75A2B6D26074FCE752BD32FB9F5CA797775E8DB9BB9786B469A3CD65A0D9DDDA
C2A166E454A94860EEF5B5C12172DDFC576A03F6E6F8A735FF21A3E9CCB4CAA1
3064893487697986A42CB5888B2B0A79FA3C74E8187BDDF7BEAB884B70B8D4AA
AC6615745AEB906E08BF831CFDE222F58D02B428D55E9D5A3CDE74E42D8A2CB7
E1A3A9439B678AD438793ABBEB72B21C58981DAF3EDCE4BB93D95F4A1E943BBC
B3A012DE92FED4F232A3A7D60CE60B605151F9C7C18A5C653E5D6D15E5B49A63
73E7A339504D0ACC74B8B116EA88C3EBA2CC631AAB29F761E5F062966AD2FD28
7FFE52FA8A115DBE23E471094FFB3CBAFBDF11B7E9058313F2D069B2CE98A962
64645738F02A31E2F2AC11628724034ADBCEE012721EBF0A567893411F950410
B20754A7510D041FFA6144AC9CC46D846B82581F20BBD001D34D9764010824BE
61C30D05E5C5D100A24F1917F01799CF5BC4E50FCECFEA732CB50196825F0E08
8A1EC868C6D4357857EE2957E081A0E4372E31A8ABEF23C3F2EA0FEE57DE4D08
61C570175C41AA0C7A3A579ADF593F18B4AE3782D2552E4E0759C32E059EE741
2D8191E381731769F6648B3581CAF11DAE46471896666F18F02918B0860BDA3C
BD5DE777672447C23C62ACFC2611ED5239D6A266FDA6031EBC5A530C1A2FF7A6
B4380B9A4C877267854AD1F1677CB5433F28894ADF93D39EAB94541A8D232E08
22D082D0951A60F62B87DC028714EC74133A4D65F7D0D1296C0E189C4A42AA98
28E8AE7ECBB9FC8DFABCC6EEB1E9FB06227F90808EF31331CCC5D4C9A6182181
047902DC9FD0444FB94B60FC74F3B677758088CE6A159D940C5CF682335E756A
8BACF06AD7225D49B0002392C889B0FE2C71311D2596F4903D12FA20BA2FFE25
A0804B4BC282929BE31E0F46B34532CB5795A65218CFAE21F390792DA67775C7
B91A2BF4C16DE4F6551DAE3A5827F616BE9040EE6B1008DA2F99A01EF66D697A
6CD1A44E0A15D1F39EA8025E886A68A1E9C334327C7703EE721E497CA924AC90
7723106D913C5ED4BA4FC743CEA8D0F5172526107DA65775C0B1B77179D336C2
9B09B608D80B1A1E87CA1A84A833A00D980D919BFF56F6390E9D5B45E9935CF5
E69D003564462F750F7DCE02DC23CC215A0696B74D8BD3156A392A94F557655E
00BFAA035647568ED66157FACC585E411F7F428569C147DC43F6E4FDE693D0F3
9917BEFEDF61FB980B85515FF6424824E2D995B05CA1E5D3E8BD8D3281DB7CE4
E54923E84058FFC0A8A2C491327D0F87CE4C352B724167CEE224DABA3B95757E
4A419594BE4F92E78BA6D35D4C93D31ECC3134B24A45DC32445725BB044F09A3
AA8C31EFC0A2944ACE2F2CE054CF24DB350FB3C71115518C24BDC0F7E54250AF
9D3378D38480E1CB9029F31570C619A28F065CA4FED5665EDB96712ABEB33B9B
4232C00C1B0215F08D53F7E430887035AC25BEAF06942FD1B6C442253C887AB7
D694C1A6115C8990B4CAF1E81DD1FDDD6B03C00055BE956BE7FD8A4E1049AE69
EDA8593CBA8C4A41E046C689FBBF9F1B64E5856A7FB1C61EC815A56DE2A8ED33
41F370B8203D4E5B19C63AE9E6E0D26F4F3814B5AF48AD30EC9B8402C941FDD9
722FCAFC638FBB835F83DC77F93D367266FA7DFFFCB567EF82B1695AB4D94D09
B18AC041811027229DF431F5CB2BBF6ACCE9D500C8F075A74590641C1A607C56
D2B8624797BCD9C91C3177818691FBB4744EDB6056464A0B95B8D63F7C22309B
82D6126E2057BCC9FE5566D96B7A9B201A09B0D3252A5494C8CA2C8BA8A13C29
37EF2A882D61DA708C279F663D88A8E2999A0F3B6F98C49901A7631BF7708B67
54D0B4C52BF4BE0DA0439E6763A7C9D639AD4092E77B13D3510DAE1475C978AC
796F9B2AAD3BFF35C5A3E19B5E2BF704B3BBDF68CE48BA4FA2496D60E58888EA
28AE12D00E9F0816FAC190590A865BB58569A91BF0345D01230ABA361442006D
BA2C90EC2036BBAB79EBAFC3F217DBD5854C519235F9627A1C3C71D21ED38AEF
0BB40F3B86BB9F09A3F309473D8757AB7E638DC1C59A7F9BCD49DE4107A2E54F
422767FB94048987847205584309397F554744690ACFFDF5902FE5DB355930B8
71863217830DD7A563B0B3A4025ACE75B0E777B4414B62A13B50C54E0E6D47E9
D43BF769B9411B74E1069BF71BA873B4B8973EC9BA492A5DEA58D267872BB246
10AA67B143D0E2223FFB4991E583E629413CC894C3FA4869B72D19CE1A0CEC8C
0FF5E5A3EC1FCB7D3C4289813F0D249A11B55104BD60B2A89BEF44CC77CCDA9A
065B8B83B4F4253AA1D535290DCFAA4773452D110D2B3370F9E2FE5432B54A9E
644EB3BA9BFF62347F376839024CD5EF3C5DFD30F412DD5474B7933E6A1AB63B
4B12F2417C72D0543C26A263AEA53E5BAEBD67E23553A72E949DEC556BEB5D09
C4D7A89B14FE4EC68D0E3E9D65A64B285E53590F418EDA8175113CA375A29930
DDCF4C71ABB26CEB800C2C2B253AC1F53651C88A56ABE5A74F3B54CB4FFDDB92
60AD7272BA25EC2F6FB759AA6E1E7964FB55AD09F4EB25DE45FD01833947BD05
6266AA8ABB7DD792941C7A070FCF3A4636FBF8921C70298D42FE92F079DBA2AD
6149D9CF9EF7264DE6DFCD4429949B15EA90B596340713BD61926DDB2BB23BE8
F9DE38A31620A817420A245946E551463960A8C5C7295E3B3D6A59BCDF5E472A
40B7A2CDDAA43CD8AAFC411D037142579D11054A903E102DF0D0C7B5BB854DBA
F3F086AF991F7F5D5C730F8F9AF213F25786F3EC0E54530FF912F4876FDE16B6
A07D0DC4FC46EC6363BCB68B83ACC448B801EC43FDD2F8BE0E93D809FF81E38E
176AE17C67C85FEA58EC95435434C49A950AA955D8B20989C550AB1F1C31B7FF
99422E1F48FB7D6F327C6DBC4695A03903DB275B94CB39386E46579271870A25
21823E75C377E9D5B46655E8CD8F986372CF8BA846423E26582315A9D19E0BF5
305C32B2A0EAC3ECB275B1D8BE11A37ADF524944219D94EA2C5DBDA768828B6D
775DA8CDB09E0570E4ADDF462EFD8D3FA3F86B1DEECDFFB699AF6507257C1879
16FC615868C2D51F03CD57BA38D42995D9164B257441210084DC409B6EE4C119
0B2E17B0A8D5326DD0010E4A325D5F77BF935693BC90A00A28C7B5F74817DA39
F47A41E32F4F92AA04D30D810F7B1484EB53AD8CFC8CE8928B570314E0F713F8
AF127227190F9C16BB73D2A217FF801C391A29095DA5E4974D137A0CAA7DE702
E20DD4755B1D78739756A5E7EC3542B96AD6844199FFA2F5F2E9C64E2DA4FB2A
ED79869F745C59D235438251BC2E6D26112AAED20E06021D1AB896EE1F1DD2EB
437FBD4A25E42245C5A647493FCC9922E6DD7AF57D5D482921D1CBD6F0F02949
C27777144751C1E72F4EE2BC343D4AE7A8A8758123B54FB1A026144C643651EF
0907A376945E19A8FC7F98A034832A5820A481B0823F980F59623E0511593FEA
BDE6EFBCC0383242CBD4954027B075B21F10472059A480D6E5ED01C3B07461CE
9810251A5C5643EC7403130C2246E8616CEA25EAC7A0076731FEA8CC43BCE3BE
933FCE61067F5FD402E67E2B9DAD954AA77C5BC86BC5E4BCE2ED676D8D8EC7D0
ABC5C86D82180B9D5D7451C71B5149B6B67883578DE9909317928C0A92E3205E
F23015400A1763A6FBF67FDE3318AD2696685A1832FC31CF38589EBC7CA1C818
60D2B2211E04EFCCEA88D9A9082E82951EEB123924A267CB03C48889032F2892
4227E217FA28F87E01CBF27BF1EA60641A4238258CB7AA355908FE36D90F5CAD
FE992D03A33E47CA9AEBEFDA57793F39DC6A9E85D5B289F6B862B35DBCF82E43
5CD6A862F6FFAC36478C384C3BDB0148CB1FEDF55969C776E77917635B5A65EB
F2AD351D21CD3822D43289FE8EB0FED58182997097C7E9F4373553AE1CA92083
EDE3BBE6C3BC7009D15AB5FEC6A59E9FD1BCC7B2099CA15FEF083B9CBF7B890E
CDDDE6BA0AFF306C76500C945DC91BD533FF9A585CEEDEF79238C54E6168001E
26FEB29E523EE501BFA4F60B782B1499B07084C35A2434B4D29D3D8E2C8F945F
A9922443B68D07DF7EAA1F4CDEFFC438B597D8943E231B5216808A85F30EDC81
9DF5DD22F54A45335B4C2203887475F39D247F0E7347BACFEAF220ED82F9263A
6488E73C1910023E505FDEB143006C1A351D441AC57F9D52D2C6D63D78C75605
999885676BBBAD56074298E0BFDACBA1830BA58E87F436CC670EE8EB1870154D
72DDBBF3794F8CAAA3F1E11DE29752DD99EAC695838A19BB67A1FA3829B6E0BC
5301610A0351AAA749F456AE31ADD87D6ABADCDD1FB3CE81C3713F48780DF407
530CB284B2AC709F52EE7AD647DEF9FA4D2A867CCEF728F3D40CF34C28D21527
10160B3DAFB5FE16AFC9D36C6EC4021FC189005862082BEA60AC72B63AD27D72
FAF3C2D89DA2648FC4C65104A069212D87144E8533CD86A6D73DC7CD9DBA25CE
7DA53B000266F3871B24663C77723703315C5E4A89DFCDBAB384AE7EB2F455AE
AB191FED406F7F6EC9E5B8276EF5C4CBA041AC7E8BCEC7CAE840154BDCA3232F
15711ABD1E867A434E9787CA0A6D1F197597DA27ED2402CB2D84ED082E8D3A39
81E6EB270DCA4E7A90E2BEBD3CBB3A2BE3CAB926192D7292CC16845B6399A543
BCFD224BB52F21352732DB5154FA3442733066CDC3E186D8AA97CD801DFBE43A
116C86889BE198DA88CA978B8C40ACB67E8F7BA499DE68A6FF0DC72C3D00BA1A
B378B39610F15CA026F95ED8155CE3FFFFA2E2FEB352DBE14CEE1669F2387B70
55B91185FBBED764266215D518716EDA3DFC9E5DB6B148A553E75AE5E38E1CFC
6EF47B314D54CF24BC13856F4F7C976BB91D143DE32FF49BFFC87E17885A1893
BA1B8E441B08EFC04F7D103C1FFBB665194B3D0920473740C55FB1C50EBCF717
A2359B687FCEAD65616EE89A68F8D91AFACAA0B238EE4AF0279AF5BE5294C3DE
A7E1F5E6248C0210E7D40683F04B12A933C746ECB517CF94BBCC6E4CF49AC715
D8005AFECBDFB7A6B417DB8A28F8E9EAF39CEC1CA64DF37A5E66A76C26F721F8
A63B003A040A62F87DCF61B298F960D510BEFA453F118E59E7DE8CA3DD002EF0
127EAF733D5C61B5132348D280F84D159809CC71A3C6F7373BBFD8D6EF715D34
0016DEFF14AA5F960BF1BB9AC304A1823722843547BB4CA5EA4C41C6C2701C8F
7BDC810443F9DF34BA469A3260009B799871BAF8523C8763544DCD0B382D44C5
F75046AFF85F0B5A3188C2EE786CEEE5496A5AF4BCB0B429CAFC403FB983EFE3
61FD9F52ADFC38E07A0FD7BACBA530D2E4DAB2592AA9564843E7E2305047F060
C5FE4243FA8FDF1B5D4F61ACA7850A604FBC6D6970959752695C90F78961B4E2
C8CFA41082B1A37405AABCEE5BA3DC2B9EA76F486117B84728EC6D8AE6379CCB
402C2AA89078EC992C00D53151E9D82C65643F549A572A20F05107A41BE5AC57
8EDE92AE20B05E2D0C98151CC92D5389A675DFE39DF546A33A84A4C534337ADE
B17C34E09145B37CE1EB1D10D42CC8D6E6B127A3809F7202381FDB88D42084CD
0AEAEB8A8288CB56870EA2BE9D0B9DC8291021CA561E2BA388DA3494E433E0EE
5E69DA51D0AC505C9F71562D3E9750F23CF14D2C8ECF0692FBBCB4A92B48B4B0
AA2163A447D5FBE86D961AE4D4251149F11C4BC269E10B48E8C42DC2484EDE87
6540CB8A5EA2494148D09CC9D5014EB73C29368A3945AAA1BA4C17BF640D2A0D
414293480FD600A77D37471828C4645C5A4AC4729F4EA76FC946810B4968EB0A
719D8F3E61D2B740AE9A33E9F02982A13ED4B6ED0C6C4A93A9E9EC045D0CDADF
DC01ABAD0BD95692907C04F06F06F1BF6259C8E71099FB64B4FE263D06C5854B
070C8B864D8ACA6EBF440DE14DA34A2A548C9F1557C70A4D718F4F881707851A
6DCC39BD8791D806F5DE551CDF8612C7EE6707D554CD826CF352CA634FCFAFC7
232F32B3F0EE3D2577915BEB212005E06625FFC9F49383C9C64F51B6541F6AC6
12D2359547103898D05E52CE54B46835
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMSY7
%!PS-AdobeFont-1.0: CMSY7 003.002
%%Title: CMSY7
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMSY7.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMSY7 known{/CMSY7 findfont dup/UniqueID known{dup
/UniqueID get 5096648 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMSY7 def
/FontBBox {-15 -951 1251 782 }readonly def
/UniqueID 5096648 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY7.) readonly def
/FullName (CMSY7) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 48 /prime put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CD06DFE1BE899059C588357426D7A0
7B684C079A47D271426064AD18CB9750D8A986D1D67C1B2AEEF8CE785CC19C81
DE96489F740045C5E342F02DA1C9F9F3C167651E646F1A67CF379789E311EF91
511D0F605B045B279357D6FC8537C233E7AEE6A4FDBE73E75A39EB206D20A6F6
1021961B748D419EBEEB028B592124E174CA595C108E12725B9875544955CFFD
028B698EF742BC8C19F979E35B8E99CADDDDC89CC6C59733F2A24BC3AF36AD86
1319147A4A219ECB92D0D9F6228B51A97C29547000FCC8A4D9DAFF1B3EA76067
C5493B69F73B89C8B61804A34FCEC826343337CCDFFCE17BF343EA8034BF95AA
14C56862C2C052569AFB236E1F1795F05150C8F28DFEF6BF4BCBACB678D00036
30EE84FEB44B1A8438185EB45654E6853C1159B073E54292D135F0961A64E8A5
AAE49C4BA9C44156C123426212120F99F3E8B7425752A5FE384AAEF755A8464B
51F015F9E2967477D57B22627D75CEF8AAAF0AEBD504EB46D0289DFC8D86C972
F042BD88A90A53613DD93D8A7A8460E63D85F6C15C000C0AAEE4BD5130B6E668
8C9B3F3FFD804745DA1D5EC0AB85C96E1724FA67F9324C59275415182AB48D57
9722DCF602396AD4B5C075A5A89A5D005C9FE11273E5FBDDD1800F11BBDF6AEC
6711C5633A73AC5DF038BA521AC492E138F7FFC7C5438FFD32FEAA1128C66E83
0D3AA40665F05E62D7EF00B1B0596162C402A34B6BAE6300D43F3DFCC84860F5
C0F0F1CE28FC60642BBFE9BC9102E80146774CDC88F9C250DE762D24A3484BCD
1D26B6D9FE981CA5AAB2A4BEDC528115043DC18D7105735D7528C2C5DD89A812
75B5D7B2E5A586FBB0C061E708F92C1552F64A296490BD0F20243986A4707FF9
8AB3C917B8DB92F19DCA6B9D4A1DB57515E51DD85D5C9D2CAF7A036AA3F9E9B1
5B5E099CC05A9126AB274C17D75CB4FAF78052366D2F21EDAADF84B22A2D645A
3E65C4BC0F540B5D9609D88DD0E4CBEEF87C16447D43A5F98528FD45ADD10DE6
41AEC411FD6929308F0E4F48A8D9C9EE386E920D41C1CC98A52073011DF5BD28
5683F280B5CF7F27DC50930C81D344FF5A8A9258A207D2531AC21A735B14155B
C22C752DD22AA33C52D6D4D053B3E46FD4C9129068DFF52695A3A9184D04E8EC
93696A3FEC3AEB3814D9015EC14C22EC3ABD5070E8C28A3B42F5596D948212B4
AFB9978A0A361135C9E18CBDC98E0D1E8BDC17E25DDB3D52E86127E5AAECC55D
FEE61693190E378978EF1BBD4D1AF005D511C7607CCFA4BCBD3EC427CAD82809
B725B25AE8A03EE88F80A7732A571A2317E0B6A0D072EE8CE2EB9E033CDCC899
B64CF4FA1C708A885442062F08D3D8DAF44C066EE278714D1486EB709D327865
A483F62709E89D08291F044325208EBA758DD459481334F5D9AE3BB61B3020F2
A4538CFC2C94BE84C920BE80806FDCEE394230730E049333A7E16509207514FD
695B5E0AEA9E4A9737311AA0B33B15F6769FF865D1ACB63DC6201C3F1062A3FD
1B446C1857460745917A36289DD57C94FE6240F4A40FBDFC10E91B91B79029D9
9F1B9C74E8E5AA011A0ECBEC660230AD5929F01D0325D15FDC0040406F124021
02AE176F4C98BAC1706F03C2B5B40F325A50CA4683B2BB4605E68E72D0CBDC2D
96B3BBCDD01201B650A7E7744D58D1E36D81FBF72E0A875FF29B4C109A1950FC
9621B18D58806392EEE9841794DFD39E3C4E20D45384FE07F9D445F143B922D1
AB350AA6DFC51FCF767B141A392D6A8B633AACBCEC9F56A0CF40AB08020EE63E
08CC0BE01B40E86388A65F5869F2F4D022DD4B912031CB8CEDEDFC2473772569
5B28F66AB74CD7902A0061AA3547D13C7F0C6EEEA7B0BD316694A94E4D672520
EA044AB28D8D01076C486CE456EDA1811F7ACA75D27473080D27D3E681E35FC6
447046120C6CC4C17674F0F051570A79DCA74848F3F300B58B19018430D99858
CA5504084D6BB74CFDB635B6866974A9AF05DF201C69352B2663B0623E7828B9
5EC5FFA8D8F10A7C28000F8C679B180067D5481D6315BF1C4194EB171C8F3CE2
4CE319975B9E948D907F9F7EEAF07089844391555F329E331D52FF114668B8A4
80704B3C6AC0CCAA2F5D043CE44E65EDA89A0CA854CFDCB11D549B7FA72EDB90
D35353C34A771B1FAF96F83FCA5258AAB65384BAFFCE448690C1432A1F749C20
5817205185F973FA098BA856584753E75EBEBF387FC155202885F5B67117DD7E
70D1CD887183C5573B6FB607D4F6CC9F8B94B09B3F3AEC2EF1E6A320CF6D0112
63046321941D1FB3F2140B59370AA9387E24D579D389A166A10C989497FE9549
34E1AC2E546CC06C5308460DBEF3E1AEEB6CBB0FFDAC458E61DE3391480CF5CD
34A647D4DE15B81131B7D1F9EED4C6837A32E89B0EAAD6A05F5F67518655E5DB
224D4833CEC60D5DBBDB8A03FB1A9730589BB4F0FF56191D17E73B9562E0C356
B188882B36F9505F6F42EB2644FEE125C2A7D12227ABC8ADB924E88B0A9E8DC2
79762523B0B88DBBE6AC7968A46BD9E9F0C3F03F5F64724CA07782195F01F130
30DBE895C212E0EE20162D863F46A674D85232FA0DEE69A8DF019794AF6873AD
9CC2A5EEEF9393313CA519BF95C08ADF7A75B6F53EDCDC39851D20E58B97CA57
A7523717AA1821DEA94C8A9F8B82346B16D92D15AEDC16F0011A45A44B09DE47
08CBA46E8511D0C5CC83F952EEFA4ACFA7F3D7FA5E113EF6B70E5ABA6F1AD3B1
E4D3B15AC6D5C3BC70A3946F411A7D965D6FA9D7B6C6ECE19B2C29A2FF476251
EBF0CF3BF658A1D896323706172746F58B2DE49F8B7E431E20304A42694CCF73
11C4E9E96260CC442E2938A1E27EE6744C7CAB01634C8210CE40488B9CBD757C
4277B5E3E43C7560291D945F9128AF1F85924003418F96458ADDC5BB8EC431D5
AC9093D20DEA69B92454613BC1A82DAD4FBF8E56084494D9D2FFABD82A7C9847
171FE36B265B546F3072B0923840E6C6BB12CA53E05A99F0E8FD4F5109782746
7CAB9B35B68050230736AE624B7862D1244C7D9BE4D1CAAE21B123D1E8372377
F1FEF269A9A2EDF02CE0CC8BF92FD7EF09556987B8A3BF6D8C0A663DB6B9742B
E9AC61A449106AF1EA7ACAD40AC6F59427CC51865E6A90CF2AEED8D6037BA70E
4ADDAF622CDE877C98C3B2006B4721FC9BA18E30F0752BD4ACE36221F5CD1497
8FEDA5D643BE2EE007970A68E53D85975116E6CC09F0039A09EBAF0CA4B0EED6
A485CC0B69E526033FD1C1190BC5686739CE13D1AE8EBCABC01FCFF26141867C
44ED291196E546369129B9F759FDD7DC21BAF0A528FC34BA9FA8937813953644
C539F9DA4E55E83DB3D6DA309C562DA1330B157957B18F7618544AB738E25F16
F0517CD13C1F11BB8EA056BDC575D77CDC526EF497639DD89C2098660C5C45B2
D7CF715AC5E76847E0D3178360DAC1BAF6ACAEE72453B845B9F86621C166857B
029CEF5AFE29D1EDB4CA3AD7D008B7550A779E0066D7312DD6C7AFE1C0BFFF25
7B062B0DF30032EA2A2FE3CC46C96A3A0BA1888D1D2B05424A59ABE3EE928ED8
B67F507EFA78AE128F58B54634C7F534B3D0F4AFC23E38FB56EB39CFA425FD37
848545EAD03EDC5A9E796CEFB345F527615C785963F536972EBD9CFC4A6A4A07
5A31A508CA147FBB762ADD198CE36DF86730FCE2B643D1E7DF0BDE800DE7AF89
44A36B04193E44231E08919EE91A8B559646DC4DFAFF0AD891890A0A88FFA8EF
B066BCB7AFCA409C51889E7FEB33F19A3CB1268BD0EA74AF29C1401BABD16F87
ACF7DD65A8513DA9995C5092C36A774BC4260113360D29AF7ADF5D22B5B58E7E
A9BEFC33B9A91D2C397B27A81087376CB623318A8362C3FA9CBE3026675723C2
E711910DDB328E0EE3FCE219F44FE528B70E58B8E6CDB4AAB48237DD933D9639
E9D4F9EADAA8D46537D964D75C27F210B0C2473CB60D65F61BBD91ADE01576BF
77C49E31936138B0FBA066BE910DE1B1F0E4FFB5E81038E8656ABFF08DFD923E
6BA2AFEDCE6998BBF7045393C34811501586A4846E5B942C8E99D4C481D3AE60
2796ADBB5242D59F1116EBB828014BD903EF58B223DFD18BFBAAE4D348876B06
CAC10B7AF0DC270E6702A3F75D4DCEF872F2CDB9470AC9A1DC1ABCB55636D26F
9CB6BF27A0DAEB1F62AFEC12F55F78C9B59AC6DA9DB4B45444B0C582DB4DB8A4
B31EF4AFB77988E92FC0B257374B4408406490D9AFCC495316D6C08BEC9A76C7
12371E14417711EF802FB7151B3F6A2580C97527C9C3A0FAAB8D62FD992AA18F
EBEB36F7910186CD5F70A55DFE932757C299D9D2289796769A00A0C6ABD18F82
E0D4E95D6477E67B4C012DBBD098FE20E2F15C412DD2AD5471A65EACE05B3A1A
0C9C430BAEF4887F2CCE668116B87FFD9DAB4B9B3605CD26E6B12488058AFA30
8843791A95BB322DF5C47387F3EC72343855D6B23D72144EB5EB5157B8B238FD
6C71DDDA64C9539F66A7DD569FFF43DBE4A8F0608A3CBD354DD9BAB5E3C756DD
92C3C1B3E169D86A2230299432488BC04A87E08A80809F9968676DF9157B1C91
27C664ABCCBA9997FAD8966F766B325086899D1FE44581FE07C97688B3E15B0C
234A22646C32BB965B9BFD2CD34854D1488AAF021E169BF9CA9665CF040E25A8
16156C80A2F47397CD370AAEDA731E0D14FBEE1E51A17DB972D96DBCCE33F937
5CDBF1A650BF1D3536BA4CB7A1CACFD5CB457E2368A660A62AC26E64A631B2BA
6B08EBE42E02D9B1B2E95BF9F0A6B59C96A122968FD46A4D17BA3D018CCBA0F9
80BA3C1E6C683111AFF79303CF64F1D2CCBD7571C6E09DD9B27B8E101BE219F0
E075880A0E367885AC94143E777DAE455B990383100EADF786300602C2CE28F2
4F44662FDF03BD39A5181912D8F1243C36FF88882CFC4B34C1D4EBBC01D96A7D
9CE5303042D1B21042E4FEAA455F22A01333FCAD7E4AACA5D3A5386331985F6B
9B247EC6310BB07507321BEF3E4ECFC3B915AAA6E029B3999644C987640863B0
5DCF58CE479497AFAD1208FEFD1796E74467E9F7867C313A3412E6923F4C9144
C69EFA17965056DF043DB465BF2F1E191706D3AAB47E6AD5C9767E4A73B29F2D
E2E579D0262237568F82B360ADB6D0219B7535EFD02DD0688CDD23D84FC4F308
5D2D0010B1A9F4F0321A00C154672D21708B66B91ADCF98BAC7A2F94848E9A4E
86CC82EDD0399BD9F13E43359E71F80086B9B0C3B6D08831D4479ED83E7892C4
90C477BD1F06DFEBBF60F26516EECDEFE4787EEA8683754F2B257D0BAA607DBA
35EC6D1618C2FDF3881827F92D793ECF152D761F2423A96210F582DC9B90120F
26A33025414716A5E6F56D712E31BABE5047EC4855B767AC63D793995C9E074B
6E35C7E5255FBF4C3F17E7AD7B2A6C5F7459794FC94306B581536910F244BF5A
3158E821CE75F4B0565EBE985DF24DAA92F9C1D848EEC6B88E21FB6C51125872
1752F7352291960E5BD36F78AABBCF6DAA4D07AF56E4B6058AAB13D41BCDAA14
C0D63C6807FCD0E2B4B9CC892F224843173A75DC53A8F0FA396959C2E2CFE3F5
9B1C8B62797F34E7A0BFCF0787C73FEF98442234A617CF161829498035D30B29
ADFEAABD0B496E8A2E764D22DB7737F950FC5982F1C5F4FD414C1B0202F40FBA
62C81B8F0E836CD73D79366FD62388B437B81FC673442EE34BF27454F72A08F3
389E60CE28A050601A42FB4491C60DC02EC008E6B9DD2495522BBEC7293E2923
120584E88412DA7137397B41A28706B1CC6BB0C80709A2A4BA79822D245757A4
3EE454198942ED2316FAEB981F7615E642167620EBDDC5B271E273216EB119C6
4F2F0412F0BA6E3BA396217597575C6739194E1F839232FF088FDDFD3695A5CB
9A0E220389938596D8BDB183138E1F73F64512E4FAB5E1328F9B42364E3113B8
004BE2CA0B074EE271BBE0260D31CE555D535C16EBB528747EBAFFF253E659DA
3A377CBE0B296276AACF0294CF90FDAADB4EAD5E2F600E5B2A018DEFB86FF61C
84296480A425687CCE37D671472537E897AFD4B8C6A6175E1ADDF9AD24DFC5C3
A73E18AC2D9B28BDA2F17D51DB3521945850DAF0EE48B0FAC271544C1B4F3B2D
53BFC8DE32BA366FB1FEC0DD6C0B1FEA374CBE2B96F5B235A1D83A240DB442C7
1460980A3E5B96AE3D5784DE2C2DFFA671E0A856DB2FF4130E5905F3D5338856
C11A468D867D0C6EC585F1AD3E7164B8598BB59973B9A952FAE819F052A6554D
EDC342BCCB0525905D1D27ECB9EE43847B69AE116F494CB2DBBAFB2773F1A3E1
C75FBDF8D66FA5AB4005757D631A0D9424FCDA91A1D2AC6FCE7CC7A23E84C65B
3E92BC684F23467DCF8521E0E27CF1441C487EC6E3BCA0AB54BB137E83776009
833D772FD225E88A8BD992FD69819B3BA90BAAD1DDF16E4326190CC4BF9C30F2
AF7CA1FB38E6387D9745FC5E176B248B1581BF7A4CA2FCA8E423DF340EAE29AA
7E07A25FF838F67378F9A6A9A0B404E01E86E64FEF71DD3D540D4711AEB1974D
E2E0D485DAFFC74BA6B8E9AFDA245BC8997BB39BB6BD52B496A09C68F7A8E900
8DB3007643416040FCEC85B407EA0A946827771FBBEE49A3DA5542CC5173A31A
0280AB8E922C23C1BDD88D70627EF124633C318E7C9ACBC14AE216BFD41C0B6B
3A0161757913CA1F7B6626963C09936A52E73DD9B3D86DEEE73C0293A646FCF1
21D4C33DFF1671DA7A53E77E20233EDE51571549AACB7968602CD03EE67ACACA
B231661CA9DA2BEC5795A83DFAF675E9B052C8BDD51490F7874C91EF5ED2E0A6
BE9CBABB98A950F7E55DDA3823036437C11F614E27DA5BB8BC6D955FFE54B825
0201275C2C49A3908BEF1DB3D87792DDFFED23DE7FD9CFC284F6255C77E54A39
C2FDBCD28F2938E4CC135829AC1867CAA5705674062C9639FEEFBE49D6108091
7C58585B80464F7E69966D7933C7019BF336B88B9E0E7073A85EAF297B71B303
31EEE9121347A482D28CCE942AF53E94F88A97EF2F1860A92CE29A14495D67B7
D37E207D42F3891E0423F5BCFFCAAC057FEC683696ED6FEEFA65C8FB6F1312C5
24A1130192B4179F3B08DA1C951D988894E7FE7CFC28C56992A1CA82BF8BDBDA
E021F16E630FF67201BA4DF5F3F4D6AA65B8347FC1575C142C6C1868E8472BD2
CF191137AE1B36F32FD84DCAD50644AD55EBA2694C93BDF984A5C9E7C92B73A0
26769F00831537266FD2E711AB3F8AFC5F3FDA3C9E6439FFC48C3D1B5527FC56
1FEDE991E66E8465C0E395EAD0A22A2FDC001E449AB9C5E0EF187A1DE9B74696
BEB6A525DBF3A60DA2FBF1579150DEE1C5D1B6F55FF2708CE23289803CE123BD
C81E25DB96551A13AD713D5C7BFDD3F2E1D5C12463A195442B51909CC1724E50
A1F6F4EADB3B7355908F36F88521F333C4E7C70B094209D1F883B961DFAC32BC
8C5A2CAF77CA5E6AAB714CC0AF2B42FFF6F73301FC71AFFA9B33A2153F55C2DB
C1C111874DEC37CB746BEC9A3A9A37A2DD098CE7C66B0FE38460ACD77A47D53C
1550F857FFB733B5A8D02FB56790A09190B29CCB4F4A3058B1C82F0CC5E1B2EB
2F8E06F2DE531E1EB81326A8EF0F82843A4AC59D267EEE45730895752820BA93
A129C22A78C1AB28BCF67AD5DF372FECC9EE6719A02E499FD5CA866688E86089
7EE8E5912087E0C4588DE38428114785E0CFEDB1E2EE24CC067D107DFDF1E2BD
B1C4F9C6B740F3DEA0BD315581004E851ED5A9F66C4F9E95DE97D355DB06F482
A43B565F1255A85710B15A281E2F034B1C23FEE6CDF3A043780CB6AB18A016F1
9EAFE545CA5A5B5AAE2459D69D2151E99D029FB5C1649B9DA784BFDF7D177385
4D8B16B9922D149FFF6B4F99311D52BEC9A9FC098E7192180DBB38767DA9B9C6
E8CFC98615219EF3AD4A8157D14C72BA3F91C8B78381383E0BCA1A5319749E08
D67D1208C693A6640D1BD6B9285AC0D3110CBF8F7747AD12585141C3248D0BB5
BDE892F91A4B3291F21F30294693518E4629A3ADD7C8640E424FF615602C603E
1E14DCB3B17D34C090BEAD2A523E260A599522329B698729A635CFB15BE7E79E
6A34DAC7C3ED57340821A4E7A0C7F88F64BAA69BB80DFA8B659F4756878E3044
E1DB7EE4FE60074AF97818B3D36CF51110191B4E10655F52CC5D11F56517CFF9
04BA2676F4147DC8192C98C555B01CF3CE65912744C4B419499D3F6B356E8561
A9171BD894DD9FD3EFF11EE4830B1ACD0DF81BCF5D1D288DB0C09C934E3276B5
D231C95BBC9D2ABEE4F39C9AA60948803ABBA21F8768BCC0F612565C54AB722B
328C3B489822CEB0BBC8CC31A585E0DABAE1033FDEF1DEDE464D93255B987241
2694F11CB11FDF9C1E058D7D27AFAF8DC868E0B3173F58F0DEF25FF1EF199DF9
5C809F4776961879470BB5FA281D3A9F7949DDBB523E307ACE84554A
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMR10
%!PS-AdobeFont-1.0: CMR10 003.002
%%Title: CMR10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR10 known{/CMR10 findfont dup/UniqueID known{dup
/UniqueID get 5000793 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR10 def
/FontBBox {-40 -250 1009 750 }readonly def
/UniqueID 5000793 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR10.) readonly def
/FullName (CMR10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 1 /Delta put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DB9B8591E5F01442D8
569672CF86B91C3F79C5DDC97C190EE0082814A5B5A2A5E77C790F087E729079
24A5AC880DDED58334DD5E8DC6A0B2BD4F04B17334A74BF8FF5D88B7B678A04A
2255C050CB39A389106B0C672A1912AFA86A49EFD02E61E6509E50EE35E67944
8FC63D91C3D2794B49A0C2993832BC4CDC8F7BD7575AD61BCDF42E2E421AA93E
3FF9E4FAD980256D8B377043A07FC75D6169338028692CCA8CD1FE92FD60AD26
D57B7519B80A8F8DCE9CEE5CDF720AF268D3C14099498A843D76E3B6C0328F24
D36EFE7F5C4E5B5C612786200C8DE3A41EE5F1FFAF4097653CFCDC8F4FD32E0B
03EDB3E413283B9EFB0AC33B055617005BC9B0057FD68C52D1B0E67F0C571685
767F2AA85ADE4E0104A1C777733D5E318A22A9944336E5B98D965E50D31F357A
8B6EA5A0EA98E1B027CE68C2EDB149EDDD04ED74A1B3D206D471A0C11C11449B
DE190BBFEBC08C9E1B7513B43DA3134D6B11A2516E6E86B67F68C970A320D05E
94FEC57FB347606DF89989C33482BD09D011C55AA920319E7B26A205D3D0F004
22466F09C0482A164CFB27EF6ED2B040ECCC3DCAF345B5A73676F193D43123B7
72FD6CFC5E37930E61EBD5A6307E4DE70194E6384EC0D79DB6AD86D3B319A31C
8B0589D0FE28241D8ACE280D0530EE99C80723E560BB72AE9D53F4713181F491
344B06D3027BA4E9E94D4305BE1D817197C54C8FF56CD6964165F6448ECC8A8A
64B48B4F0FD69299A137589E2491A283509B21A3A5772F75B7602A9F60AE559B
07A58436D04222C73EAEA72DE9A5A441F88D27C11F4F91255EFE280E91A4ACAC
1E98A4E5E6C57B9AE86FD218C3CD8F24A4104156A80F13821384E529783C52C8
78B94AB3A0096090867ED32E8A30980E737922037F75F062BD83BF4F5929BC51
CC22AEE2DBBAAA001CFFBFF41D258424FAD888FFF1BEAB796A44E3126159E120
7E4025C676CF94888A1971AEF8B6764B3AF4A92D36FAF6FC56FD049710EE3782
BC2CD84FE2473F133BE03C1346B875463F126DCAB15C7A9BCC9A727D23611462
4E8D2BFD2466600285D79518712B8681ABCD69608E6AA9578F7BD771EC36E01A
5A17BC17E375020ECA59B43790ABEB9DF5F4FBBEF807E5699EFEAC563E1ACC5D
EFA336E75DE6D8248E9381BB110884FDC89C2F9A41EBBC9A8A1F98E6A41F68BE
EE30E25CA148C1EFF42DFF8C214A6537AB11F260B8C329A4947B5FC8DC9C5622
4DF7BF4FBFB00380D47BABB03BC30627AA74103E553F55278F538EDD8C1E64CE
0F1398CA0AB5A86630139B4A7E8FC02804CAFF3830114640AE50D2FDA3B561B5
C63AD7EE3347804CBB40FB1E77A6C89735DD870351C3A1811591AB493251B904
314F65791963C0412377C1D02362C5E9655F1C3D4803CD379A8EF24C48218C2E
DF1165840462BF37DDE1B8D5FF09FA2C3B261E2F1A65ECFBE5D4EAD43B52C029
EEB3948CB8A252CBAF545C8FA1C31E920E23A12DD7222CEF2D2A513BD758EA13
DA33BF5FBF1D734653EB83DA2D374A5B9A0CE316F24EE375D6DF6BDA49954C2E
DB25A88821193636119D469BA66E5DAA9C92520FD4F84426A4E54273FA469084
7517817A6EE3E21176D333825E88046F50B3CF6938AF9BA79A2F51398239EB91
1A2D07F7FCD948427FF62F40FF95E39FE1A1AA8451411563FD5388472251C155
69BDE9283B41900B21EB1190D06E6B13B7794FED020D2C1BDD205AE77B084BCE
EF628249398B496DE85B406FC2E1939EF00DFC84C07E26CF72EC401BAAE756E5
7F6673216E7560D1C2A723CB405EE5CA474A07F61B81F8836482F73DC9516D67
CE0CB770EAD755B6B356198B4B97EBB29C63456953270CCC8D5650C1D006E69D
38DE2DFEAB27DAD50A817F0D645D30AF5B75A7B53CBD3D2B8D87BD0A7E525AF3
22F7ADDFCE31716914C2318260C2E2B4664893921B68C5A93334A361D94A759C
0D7B146D6FD94F0442D672BDA0F6432E18F3C5DFA37ADA378D95B75F413C9ED1
BB5C606A3EC7DFB3F796F59B0478C13FD1900381EFE0BB5242D5B5D34D03AF1D
4BDC93EAF8020E26CA23C8B0E7DDEBBC6762A557067A4CE05A524188A8F02E2F
3625DA38DFCF381727887F5646A3995A8A38A5FB1E5D5EBB395FDD0B7C8E71AD
B48EEDB62AB2CE99D121435EFBBFCEEA69AE9ED8238B60CC7288DE33C766CDFE
15B767B4AE2E6CE0965E77272AC9F86023DA620548CFAC85BC751C44218A29C9
849F1C2DCBDFAD895B54E51A569952ED50F82DC8A19F367E7E44643854EFD6B3
FCAEB04E55E4661C82D31E2932611748480EF61FB2FBFB0CFB940BEA81AFCD84
4C6A6332D7A600170E38A8EAFCD4F93DC153C43175434C86BC747348FAC61B76
1FEC9027C1A193E55C80F1F20B5317AA0A05AAA36AE235F6E49F06E570FEE798
84857D7552EA92EF3EFAD52DE39C2F8F43C59E3A957B7B926FC95FC4B60186DF
7F3523EE2AB74E294C8C4BCD8B4975E84849E0FBDA6C0B0F24A636DFA578B122
CF97BC5089E21E9F5298D1C9F30CB8BAFF6A3A11BB4D9A0A5CF2B18D055C44CA
4FD4D8FE1AF3630907DE7E585AA811F9CD11FB2C8FC791851D651009FA5DF20B
3C33FD2FF848A9E3F5652BD294965A332DD3F246C91B0ADA34017FF2451D1394
F9C3C95AAC6EC8062BE98E8914D51DA6A164AD13938693D446044859D03A949D
F9AC5DF4A000CDA98BB516D762CB9F6D44B5268FD0C26E88BC4A760C0F75A140
DEBDECA4F511128B7D2805872160C55236F0A0FA7637FF0D4E94AC079CD3C8A7
D03A5A56F26B0438B577C46011A10532FEBCAD14FBD6032E224F45691A726886
56F305231EB2FCDF59C8BBFCB5DBD2D093A0E84D62AC93A2312CA69295E937C4
8DBA1802B85F54B5E7E6D6216A918F911FF705D3B5CF055F1D873B96283A0B53
59344D910CD396D883F6F7836BA65FAB4393A773A8F6BC298069E5BA38210EED
49C9D920F718E3FCE692527DC7CCE6963BF744F2C91BC5952564196D60574E86
87A0FAB21F2DB2BD5A51D7FBD8FC19946D24E5A228462C4772F978E650ADCE3B
8D66B9C21279C531CA1C3A8ECE3420BB65837287A7222CC3673A2A5F8BBFDB60
C719CD073EF9A23675198462C7C87B24CC92D6AEE5C25AC63855CC3281494342
D28F3D2FDE0C183486769A4FD5B0143193D31FCB2C2A14E487BBD96D0BADBB64
D1B56021C363A795BF10E2DB448261C363A54A4AC1182B470C457AA82DF3F5D1
F4B329806141EBD53CAE309319B94133D7EBDC2D0453A905ADD207364371E178
0A95C2686E3B34C4A978BFC0EE968C39ABA00889BC5149162C2B54483D44FD3B
5CFF41F611C7E03B94945F414560E874D7CF27FFD0630890D7D7EA66CBD15448
229059E1C436BB33D69552B5367AB5D53591C4678D0C704DD3EA23F5D9E8A7AC
17D003C19E333E726FFFA2961F33C70F429085F7BFE3E2510F59B78F58B19CB4
01B48E184BAD9020FECCE3AF52048A056981DAEA02AE78197E65855DDB170616
F54278395D9EA50DC83761AE759F9CDEF9E1948E7002414FC05286ED793E6662
3347F2A9AF8917493D7305B92CF93E8E9185F70015F5594084298A6C2F9FD3C0
689F262AC9FEDC9B89577ECDE92F08D3142209FBCE7B5C0A840CC767BCA56C20
4E4E545E2BE4D21C53855CEE4CD0AB35D1A604C0FFFF77DBAE4289752276559F
A05FEE65F45ECAF44E95E23FAB6052195C7948AF0B1126482D4E02D72BF8AB03
DE0F1A632F7672AD9DDE70EDC82AA993678A82BEAD0BC2649C4707FD8509810D
364B5C6FE0E10772E95288C622C2F06C634F4DF8C7FD1432BC9310D5F24FEE3F
7AB324863D6DABAA1576E70643CA79EF4D7DF4105093D66CEE0F3B87D2164A7F
26EA05F5C4645B22D3E1BFD2219657712C168FD90DE801FB0F32759E80DEC1E1
43CEEB19FED12D757205043FC98FEC62D6A8D8B97BC083B4A0E985AF7850D6FD
8716B9957C1C35A0675BC53DF672C425C79F43FDABAEE7D63F092CF271C9A9D7
C41F40C4189510987887942E60A412B3EEC84C9A6E1AC7D54D528F5604B72C08
94B7882621A5BF1F325B92FF96B80878CC550D1AE4D8196E41CB1251856609A5
C4D3BD05A922D0D45E039D9450DEF8490A3E924E41434194910BF60BA1B08BE1
B41824345627745541A4F1703E956328F6227D11C74946B38CFB096139979E56
4E723B889B44C6D78673868C89912F8B4F0B4B485F1587A637B630F92E6072D5
7F3B44EA6FD96BBD4FC28A6C1D90805E3BE3E42A7BC9C880762966C55BC04E01
204D083AE976FAE6F37C94F27E68F8C0F28D52B17F6C0FD7C9150701FD78F8CE
B8E8DC9260E3974005EB5CA728171F482D765016C94D4ADFE4A42EF42212BC56
7E4EEEE8B0D2A7856CD4E44F55C0BAB762F92CB8D64C17022D4BF3A47C12F5E6
279FC23101FEE93753653CE8CEDC3B75C9CCB29BF1D4554C6120DE8EE750FCBB
E38B5D915206974962E320362E59B3F21B3AB1875703191043D03284D4467346
CFF2F98CEB4845B73ED8E003E0DC94251B73E13A9B51A3F1430BCF6A21EB9B7A
65E17FA411F53BE6432F1506232B8159E008FA257F884A4A01AC53BE91754D78
BF14A5B0FBFB9C31BF4908355F8A762052968DF526D118708CCB0B7CB5BEE285
6DAB6CD2E3934178E60BECB11AAB5478623CF6C50C92F8BB5D1A583609028FA7
B8A53B791BDC9EF76A124F3F7641857E4BEA0837CB36176EC9A522EA7F41B8D3
63C37D1145367BD300F17B54522A834BBB74DE12BF9EB26ACE6F24A046D58F89
4D4B7DF74875F1A0C1C9D97BE0849593D7B398EB4B00BEBC8C8D1497B6EF831A
A35380FFB7F1AFA4D888AA52C9482E8B1755CC209905F98F40D95B44D4DCBCB6
67423D1BC2F3560FF0A8B4F0CAC352A4EE2C1D946E45AAEC8A6AD40303F3382C
DF0756BFA3B1ED64C169E56ED1C760F2FF0E24DC5C9F41306EF8D2628153D30A
5DCB0791126BEFD4947D7EF08301FE015F2B0008DFFCBF9F2D4D859FD43EC7D9
C5BE237E9BF6665B7B1BEBB362F0C0C3A8D86010B9C97FA741C97C2E0513386C
9C26C235B14DD2A58BFDAC7B5F63DB4DA6D5D37D0098175A9071590E1DF66A3D
B8173A047C29D7D35557F06132CC920B5460B8AFC11D23D09A4E45D089F5EB51
963FA1A6256E359D485107FD143B2BF21FDE9DA5744BC2615E86C31C89470CF0
D06C6397D9FCCB316EA9989430240759D2C4945D941F159FC02327F34B042BAB
B5C3A47C78E8C1A6FBCD396B1A51CC4B020B8AD401841EDABACECDB482D6EC5B
72D2BFEB4556720FADD49D07307C8B22ACB7E310CA4151A85C71EEF70E8D15DE
B3B00F26E0E166C14647A65ADA228A3D1C89025BE059306565DB1B1EFC37D358
8C1EB024254AFD049BA977BD4C2C605050E17940A89D0D4C5D963E792320F5DB
3706682E03D25D9E02487247819551465092CC22B6B56E93F3AB528038FEC3F0
668F866707A19B0463BE706EC729D2EE1653AAC7E29BD25BFB3241D4792F5152
ED415B4E7FA92C2EE5A22E27E8B75542C492E56D811C192E95542A6FE0BFE5A5
69273C2ABED4300D491B92D2AECDD278404CB84B1BB1BD7AFEC858215837D118
C0E928BE7E07CFEEB51A6D21375B772B8248C994564014015232A0DA4BEA1754
3274F407FED0837A236371F1A32056240F2015B1E7F4B2CA72C6B58610A66F13
407CFFBA5E0A2893C1F572D50F51286E9133B5A84239C9493B0574E77D281D01
11D00683354A000C9700EAFBC1FD104EA19DFCB87470190E7E2CE26E3A6FD0FF
2620B87B82AC8686B6206B530F17E9348BC7D04B948348802CE53A312443DB87
4DBBA5313A6A2A8DAB8A1CC9A594FF8C299281C0A261C8CB2226B732FBEEDE40
2C6ACC74A1A61379E2E1CD5548CD908268A32FA83D8504C442EA0E183ADBF7FF
9FD09C037AB03516ECCA93FF048235BD11A25DB07F164512A079C5392AC7F889
CE96AE5C8D9580BCAFCC087C35E76EED1A671E87C12E3045E15A687134736DF8
DA984772AFD189D68571A2ED7256F1E204230E41D3D9DD876F938951714A3973
0CA9310489F8E807C1C7A4E51AEA5BC030610A5D7263FF7E0F9FDE3E5E37A362
5B919000BD94D978583B942EB79CF2BEAC33FEBC9A67272EB10865BA8FB75FD7
9D280AB59F91B96C16C982DE848D76D8FA8620DFD7C80B7DEAE7264350D6FB3A
EF04794DA3305844A7CF718F6D1A4A3AFF6826173A076A1372ABFC54ED3AC6C2
09C9287FC830556CA694E21CA5342ECA7B10C90AFC4783D841D7B1E34FA3DB7A
2B706F3E21B0FBAB23E7257962FC3BC309CEA2C7239A9D6B44CC96825115ABD2
AF9A2566D2F3382C01569FBDB94C8D664A5DA0F7DC3DD140CA77C743D7BC1420
324ECF9E4780280EB119885E96A6C619CE3C0C8E1E264E2DEB137E5DC8149786
486D65667ECF47B1A1E20E9E6E4FC8323E0BC8E61BDD3BCDFC6575C69C03E31A
EFFC290472CBBD049DE3F840AEE37A2486034240F80E75D8A79E0762377DF660
52B12EAA16D678990B11A9BFBC03C1D4FCDA9FD4FFBB3E88352438102F10B7C5
9F04C013B6575B5E948FAB58EA691984A0E54E6B9F3F505FFFEF74D06FA1CDF3
4B8A95904C8A2763AA8AF5B71D00F5DE09DC1CDF87A08B6D181453063E14C12D
B7BB3775A6E2A901636273D9EEB833EA8CF20FD83AE899E28DADE10EEEC20BD7
BD93085A4B1AC80AC1AE8280C14767F1A487BD066007A0D050317BD081131A14
6EA0898ED59E46DA7B6254BDCCBC660686E2EDA0E77A705A653733BB5C5497D0
B130359F866CF293FB6EF0C2AC5BAA2DB0DED045E2DED3A2612D078333260359
16CF0CCB272D34767EA069E0F0B0D42327A18529D72E890EDA6195C2688438ED
E9ACDBEED41E81CA8EB5E43C2B09CE266EFCA03F2D7FF57F12B06F9E54FCC6A6
546676F6FFC5B8B7D3F0982B6FF0D21D949309F0C0B175CC1D0976F8C55C6AED
6E821C39041E22D91AB30922F2B2EC2746BC7DAB484991542FBC82D87B487507
559AB466F73EE23C2D3194DC5CE4C9AE66D3164613AC5CBB3DB501B64DA7C91B
C7ED2EE9027FC0906820B35D4F2CF66C4F9CE4A884B7C07155BCA884ECA5EB3A
ABB83F84DB1F5639599DC7D3F51241AB5D95C3BCB7AB1EC90B4BC989F74FB354
04B2D7366A34D335A47B8C00C05CB423482BF6C7970A95545424A08AFF9A035B
7F83F52B65A9799CE76E303B85664B624C65E9CA58184C7BE2BB9D9C86A4DE5A
8165EE3DA2E652B5022EE7893896BABD88931DE1D538F615787645DF5ACBBA0B
A8E5B899A37321AA7D4B283AC9234978C2DD81813A1EE5DB6EC170DAC1B6EF02
94892635B498765C07A38D2E9DB0B7581B11056C28278F89B0E60998379C07EB
C0EAEDC32AA69B8B836F92A61AFD35688315B2C3F860632FC13E4BDFB63214BC
41CC6859EAB3AC3034449213CAB99FA1D216563419CD6D6CE4E1B56F33E6C654
7AA9DCB5B05FC068DF02AC32408C8010AD004F6CCA9887830927F8CBCD49CDB5
18CAC1EAFF815FF2F6F527F936948201565003022C6C7390B4E3C2B219FB4F76
9F12BD25CA7B3B61D1A2F8DFEE795D04D5428B42FB66E0C254AF7B7A10CEF7FD
E0B5622DF6FC4BF52147208D9A91EB49B03BB40DE7F8FBFB566F251942C8FFB1
1DFA50465919400C21CE4724D12E4EB47AA5F392BA927329DBCA28A78FC1DF2E
6FF27F4E4E3F8971D7BCB5F3FBF8F30C214A26E5E32E0E8CBC71BF20AE573BBB
163DD66E89F2C4E2B1A1532AE81C060146F755A1ABA3F1365FEA30B403DE7B22
76F43EDDF7CB0C5D3E3F2B9043D33654BDE23221D16CABE4D559575AC8D01281
379FC2AD33242EDDECAABC38D94B5261D0C35A8D9CFBF0725623D7456CF1545B
38484A2C79F3839973B527E2599CB50E6337155704EA43AA2D5A99241E046D54
31C455DD2AACF063CE372B1E7FFADE5AF853E5A9C2CE1E4D36EAE88F511BDB5B
C68E93A19AFE06E527645D16D8380386EB40B6EAFB18E1F9CF43646B6E486EC5
5CFAA7C5DD585E444B1CD7074CA6A36F9FC00218C4A849FF6C79098A3944EC7B
7D46C4E5807398C0F3D07A38A1BCE323E161BCE20CA9A8149B16C0F0D0B0D0A8
DC6A54185FA0ED296A87C94EE719CF
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMMI10
%!PS-AdobeFont-1.0: CMMI10 003.002
%%Title: CMMI10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMMI10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMMI10 known{/CMMI10 findfont dup/UniqueID known{dup
/UniqueID get 5087385 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMMI10 def
/FontBBox {-32 -250 1048 750 }readonly def
/UniqueID 5087385 def
/PaintType 0 def
/FontInfo 10 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMMI10.) readonly def
/FullName (CMMI10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/ascent 750 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 25 /pi put
dup 32 /psi put
dup 65 /A put
dup 66 /B put
dup 67 /C put
dup 77 /M put
dup 79 /O put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 107 /k put
dup 109 /m put
dup 117 /u put
dup 118 /v put
dup 119 /w put
dup 120 /x put
dup 121 /y put
dup 122 /z put
dup 123 /dotlessi put
dup 124 /dotlessj put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3C05EF98F858322DCEA45E0874C5
45D25FE192539D9CDA4BAA46D9C431465E6ABF4E4271F89EDED7F37BE4B31FB4
7934F62D1F46E8671F6290D6FFF601D4937BF71C22D60FB800A15796421E3AA7
72C500501D8B10C0093F6467C553250F7C27B2C3D893772614A846374A85BC4E
BEC0B0A89C4C161C3956ECE25274B962C854E535F418279FE26D8F83E38C5C89
974E9A224B3CBEF90A9277AF10E0C7CAC8DC11C41DC18B814A7682E5F0248674
11453BC81C443407AF41AF8A831A85A700CFC65E2181BCBFBC7878DFBD546AC2
1EF6CC527FEEA044B7C8E686367E920F575AD585387358FFF41BCB212922791C
7B0BD3BED7C6D8F3D9D52D0F181CD4D164E75851D04F64309D810A0DEA1E257B
0D7633CEFE93FEF9D2FB7901453A46F8ACA007358D904E0189AE7B7221545085
EDD3D5A3CEACD6023861F13C8A345A68115425E94B8FDCCEC1255454EC3E7A37
404F6C00A3BCCF851B929D4FE66B6D8FD1C0C80130541609759F18EF07BCD133
78CBC4A0D8A796A2574260C6A952CA73D9EB5C28356F5C90D1A59DC788762BFF
A1B6F0614958D09751C0DB2309406F6B4489125B31C5DD365B2F140CB5E42CEE
88BE11C7176E6BBC90D24E40956279FBDC9D89A6C4A1F4D27EC57F496602FBC4
C854143903A53EF1188D117C49F8B6F2498B4698C25F2C5E8D8BD833206F88FC
BD5B495EB993A26B6055BD0BBA2B3DDFD462C39E022D4A1760C845EA448DED88
98C44BAAB85CD0423E00154C4741240EB3A2290B67144A4C80C88BE3D59AD760
E553DAC4E8BA00B06398B1D0DFE96FB89449D4AE18CE8B27AFE75D2B84EFDB44
143FD887F8FB364D000651912E40B0BAEDDA5AD57A3BC0E411E1AD908C77DCE3
981985F98E258A9BB3A1B845FC4A21BCC54559E51BC0E6C22F0C38540F8C9490
88A0E23EA504FA79F8960CC9D58611C519D3ACDC63FB2FBCAE6674357D7F2285
4BCC9F54D3DA421D744D3A341DA3B494BB526C0734E1A8FC71501745399F7683
FD17EC3044419A88C3979FD2ABA5B0130907B145A8462AAF0A9B511D2C8A7C7F
347FF6AC057E6512902BFD2918E2CD31DE615F5D643764E900B60287670AE18F
FDE15545D8BC69591A8CBBB275AFFC9B14BD68DF0AAB32268FB84844D4DBC7BB
C591C1AC5102C50A9C7BAAA848DA88B0519F0F5F0813BF055CF0E3C86F633A04
B779D2E8E656DB1E09A66A85FE21CA8BA5523F472A229E83F2C4E91ABA46C733
F3C7B5775B06C97782BC225C46385BEBDC61572458EFC5CF4190AB7A9C1C92DA
29F84BAACF552089195966E3AD9E57CC914D20B6962BE80429A16D4DF1ECAA66
36C4343FADF0B2B48F12E2EB8443C4AA29D00949255F3968617F98B8ABD4CC12
048B838EE243A21AC808BD295195E4AE9027005F52258BFCA915C8D9AED9A2C0
80814F79CF943FBE3594C530A22A92E11BE80FCEC1684C4F56712D5846B0749C
9B54A979B315222F209DEE72583B03093EC38F7C5B9F9BCB21DBE8EDDAE9BE8B
75ACE6B12A31083AC8348EC84D1D29D2297A266284B7E9734E207DAF59A25F4E
4AA38509E993C5394FED76E6A2F25462685C4C86C6E8CFC9863338EC1428BDFC
74616BB1BC8948B0ED4C87C15B4405F3A7796F9DB3798FFFE8BD0A94E834817B
D5E9812E308D0CC920470A6F2CD088FCB80462BF7CB3F039A7DF3DAF5B2B5355
E083A385CD2EAF0FC181E40E96DD7E9AB9EF5C7E6866A13B8A54718E950FE097
EF0951A357114F18CE9933D28B3A77AA71E3CE884661F13284BCED5D5FD1A86D
543E588FF473DC2CF9A4DC312500135F29C2D0174B32018C8DBD40EF9A232883
710A1F2AB2CD11312300ACDF789A9B7B93D2035D81D1C84984D92D78A53A00C6
EDA94B24BBAC1AD17774A4E07E6F74ABD90415965616AD540C8ECD8C3A44EE4F
7F4F6BB6238C5062D63FA59B7BF08BE93FAEA70A2AB08FBEAAF7DBF56B95FD93
03CA406543BA6C9527D0DF01F5108D31A51778A5EB1C93F27B72B46146A353A2
01CACBC829603B9989A87CF64528682CCBA0562A8165B185C58A5C6BB72F5E89
500ACCAAB8ECEFBB2640E99EAEEC4EA979AA793D013D61D8ACF8784FF8D9398F
F6A252A709324FB39509F0B3A4E725E82F53543383C6765BE556CC897C758208
AA3AD37B0406E4A79F8F0A6C1983FC73E71CD858C0DB66ED66D5D992978614EE
1EA91EBE191E082EBA1FC040AF19A2202575C2EBEB8058833E3520FA03D2F915
85C1ED337E457B9FEEB0C6EF2735EFDA6E0D05FA641BCF698AC6B97751E8306C
4DF00A39B8581FF53DB8F8525FDB196D85950906CCB59B8EF171349AA3B567B1
6A00819947A995FB383C3C1709C9A2C113B2E40BB832B7D4A0FBA0B16A2C455F
55809CC425C403E9668DC66BE45B71A81C332FD4DB279D22A2959962304A8F18
085893DAC61317D24A8F198FDAB95F3B86F0AFD35047B868A9A17037A2829A02
BAB042F75F349E197A7EED41984C2859754CAFD0251439921C248B463B516951
2E1322C80D73F9CBCAA63A585450275AC2492E4D3FB78E800F788254DB5E610D
CF788DF5C70FF99892BCDF16133E34B24B77C8F097F546B87C603DDB8998B66E
BACB68BA27462AF54AA405682EC96D701F0D474DECD5F95CA2102DF639EB169E
D518162C2BAE45FF698B6DE15FC6E7DE48C336C40A670FD26952A6BAB09115E1
991F0073419F2CC2A1C08BE91096936AA0C37E4ED3CCCEE235476074B8FF1125
6BDE3701F85532D8BB64CCC927CC335281C95EA689706F0AC717DC2CF680C754
E5EFD7FA4BB8880B2B727A964C876D4A223069D4E6001771F0E23EAD2A4BBC80
E76675297B2EF05F52BF4E71B3EE2BE3048CF088C79540113C66AE98B2FD3CB1
B0741A215FD070882C52765009D7D711DAA2508F19AE7DDA15229A856AC49BC3
4DDF40814FF96500E4B9B02D412E94623C5FDCC76C0FB8E42DF56A904FE49D65
1DA7C53901B2EA71AB658A464D3ABDE27D9DB8D9E0B48F64E61A2495AD5D8DAB
B5E72424AD017DF37964AF911BD7FA21A5EB4775DC8E95EF0C0EB856B00D89D7
8172A1DE8530767D317B8256103E53CFB877E10686A04F5A08F8DC58D843DEBA
FD5F40597588663D103689F6EB3EB14D06E18C8078F2538B43E712DF491FC5C6
AF639256C8C6134B64D560D8476DEA6329D995E46CC4BC78841C59E73648B47E
BFA7DE0846422F738454AE77E822A083405289247BD7C478BE4974F742CD6051
E99FBB1D1B3FBABFEE855174734EE45E87D0AADF32B1283B911162A9955847FD
38944D70584FAA6B1A7191C5C134B73F98EB632B69E2F0C0F94156787C34C8A3
7622A029D58F9626B74F8A8A1F3803E0BC20E0EADEB1E99B70F1BD9F980FB751
2A842843DE42EB142A84D5D3138629AE9EAF6F3479C423E8829C8816FA6EFA27
DCE5580E65AA9854B1C64163DC318420CD993C15BFD76A8BA1182860A6B03D6D
22B8CF43CFE6C8AB27C64842E239CAE707D3086BADDE1D7C94E3BC96319470D6
8D26915C575CFDD03271D6BB9DE86A0EB6EEA6E768B224A626C62A9AB48A6EDB
44F70BB5AF991CDF9736D65933E81CC57A78F623F33EC9AF535F2F25FA4EEC90
D50DB7E87F31E971A75A33A301CA6013EEC5A4E179D695B33DADF2C98364434A
42926776000B610E17524162253F6FA638D6581C18F99EA0BD1D2E24D2424ADF
C05010D08192485153DD03930C7BF45237593E484F9851E6D464FA10FECA5D9E
0C8CCC97DE029030900CDBB491C5CF226DBF903CFE7735D939C3FDF3A20B70CE
66579B28B99313FEE914E295388C7BC8E055A2E54EA3A8206D3C8F4F7C0BA5E6
E519419FD8CE215F7B8E9BEC604A9E3FE272A0328A24E31997C8A91E0946BCF1
6943A97CBED2AB9FC636B49828BBB8B89E0BBC2653796431224895ABA5DAC41E
1854BD9764E86147FD7624F736F40DE3B7582EDDFD15C2BDE3F22B5A54D7DF10
B87A1301CE85CFC061689A890A321412A13314AE96DCD3EDA75035FDD8F4AB9B
897A2C68263A68457032C469987970648BA2D88B1C5375DFEAA35A917B8A952E
EE670427942AEDB3CB599C5746180E392837D371E15D860620ABDB6AA7772C40
A5E346661673ACA530BE3D8E3FFB895E5DA3DC23B1B43C080C77F7E47847F0F3
F3AA5CA9E4BF75FC5EBD18D19F21A7DAA3B11CABC6E4070A15F7DBC8B05EB6AA
A02EF1B078EB66D61D6AFE41DA9B36FE7EC9EF94D1EA26282A9871E2CACB3126
2AD49C2D9B50A6E47D8F2CCAD50992D1B430979A45FD9E76182A19964BB2A1F6
51779A2B258DC1DF4C2F3074621286831F3848AC152DDD2BA561E6586ADA88D3
598A2CE2CD048F027CE0008B828BD915887D7785341E8305DF2346ADB76BE99F
87B02173BDC334E9221C8DF54114A6B24C1C5340299512FA6C8C51AB4C8778CE
178CEF531C6D1B5FF0A1BE8EFF767F959BD4C345C52699A29A17B2A230842BF6
4B011217D6D24EDAC3F6D53482786F1CA33169B90ECD499407D37CE9B70DDF78
7B7547B32952535BA9ACD1E244447AE3FCED3AF28717083CF9590A09780984D6
AF0743C82AE4FB3E2BB2856A4153A3967A023FFC35382D6C22D84A924900B6A6
3DDD400E6D2418DA6C27F2FA34C075C902B89EBAE658B3C9A18EEE449DA5A379
337DE95CB7AB3F0970CF1A5D8FAD8090E495570FDFB2FBBA79244780D8035547
C5A55BB21A2270F724BF5D442CDC5BB9F09BE0CAE59B1C2270F0BDACE698F2C5
DE8F66BFB9634904B161F5BA2B1950048300D69BABD312D58D89C4ED527AF7BA
7DA2478EDC2CDEE3473DD8A8ED9D891CD1FC21F23013228BB3281B71FCE959BD
6F8E9059D682A7FCC5265A0620992D4FA8D78377EB34CE3ECA070EE3707239BC
98907DB0120CE42ABA32CF97127E28382BDDFD685674279F588D4F951216C355
821361790F64C2CC720DE97E8ECB57326C43EE47367628E05769E106868B54F4
C33C9951908DF6FC4F5ED2C7787BD8FA591BBB3E9C6C1DA94CC5E38D9B20C886
7D237572FF46DD896A4D6163408EA6CEFAC398EE041EAE29D577E75326CA17A6
B072D47A7B13EC441CE6DAA042ECD02134CBFA6809A435050413817193DAEB16
A5882C8AEA44BCF36E74E9ECCDFE7E19FF5A5DD7A94E5AB4F8702C3DA7F42325
23C808670A0490F5B373DADE40814FF9650241D3D69C91FBC5ECE728F827D9BF
C928602E05477903449E079164CA39859C4BCA60C579F490AA455F82B5050BB3
969AFB478E0D4A257B3356EA3CD62051FCE6C6B1929CFF85BFDF166BEF658E10
3A55E007F38EBBB248B3F0B8ED1925106B499B762E45113AE1AC9DE09644C84B
9C08034B297314EE69BC32DB6E7D7FB9913CE5AC17E7335979E9DCCE2BAB3725
1976155551F9706A576FE0E3ADCCF72C87683291528ECB749CB0ED291966E239
B5E3630676BD409E08F85BC1AEC9A2D4135376284A96EA24431243BD6FE8B966
95F11A4BB53F392E0AEFEA623064FF8A7002367B0A515635CB2D2DDFB9B4A8D7
FE721754E81BBA548848A235B91AD4E4F7DB19CCE2F61D277FC00AB956EB93BE
44AB4970CA56BF59506C94ED160FB1E25D3DF2988A532BDB787BFB8539D22986
FDC378AC31444E63C4727FEE121A43751043849E6DCAC5B59D0FC703AAFBBFD4
E8B7C268F21615AD02CE9DABEFA27B5FE6A6441B619539CAB1F810F1263447AA
633F5DAF483752EF1A0421740E3A811D2D2898CBF53E7F686C9223FD7235F02D
6F90D2D48CC20AB87778DE3C6FB335E0F0EC20B5DC5B65223FE117526DE2C72F
FE839DF93CB2A7D66CD900CB325F891E311BEC932F703FB4FEFA29DB8B9C88DD
375EC71B3D58C7BC59ADA91971A3BDA1ADEA629CE6CC92BD542CDDFAA7706FB2
6CDDE2DF07E56D6741916AE8E8744339816F3E6C38062747AA9FDA2A2678A6B7
EFEA870AA3A4D71B25EE3013EAB1DBA34401B867C7A41AE51E0421D41D3BB83C
E120C8FEABA6E5DEC53A689C21426D4BBCB68CB37568761C360E6D4E3596FB7D
F4DEC7918E58C0293D12D6DDA7E9DCDAAD7C939F55CD1BC4A228B31E9A904156
DA6B40B08E6ACE674618B768DD681C772A3E55FE096CF949CF3B0460ABDCD891
D17B37B355B29AB5137899C036F31DA026244FA25FB798FBE5105BDA29F46538
D3D3AC1001A7BCECE64DE94FFE6C354166A0F97256137BDFA07F6E22A3D1D2F4
9588DBAE95E895BC5E64DDCBBAA8D0A22C229B42CB717FC711E7E9DF793DF80B
9F14754585A3C7E17F37B32924B9F9870DA8635E3E18BD1DCD81EDF01834D9C6
B33F23C956C2FCBFA47D84422F583459D827D1E120B97694D12F1F54D02379C0
D288F7104F3FFCF4F76E3494F4ACBD1BE3A15543CC680924C78A473F8E311ADF
8FE00A04C6C393DE61AD3EDA5BC031E2353076A2489391B52632387CA28A7B93
FBB065A6EF3658AE80B1ADA47E9B2539E73A71FA75645F85ED8ECC257FB4CF26
B6C912DE9D0F9899E70BECCB934AD32CF49A093371A9F73DE6255EBC39DE1E7F
00D0CBDABD4D0383977E694890E71FBE5C376BE5F3A80C28987417504F515C50
909F3D31178BB9B1D085BE514F71B910A9085BD6122DDC72A150BFE266920E49
5661BCB4BAB51D6DEFE32B616963DBD989FCDD1637B294CE4E288655FBEFA1BF
7F25BBF8CF17C2D5FD161A7C2CC9CC7490D9BF15A1D35B3BFA43ADE256E88BDA
BD490D92907C57BAC408A575EC84D6AEE070148C7C9A91C03B09FDBD792E8FF0
C0B886AAD2EDD86541E5E579359D40E3AC312ACD3D8FD49F71BD533DDF8859B1
BAF17F1884E331DD07CEEF93B71D492AEBAADF7A263450A7A72210CE630A0D37
BF024BDC09ACC882816B8C22C62AE38A3A8D0F6EBC2B1B2C0B8161A8B076DD5D
4B779C0788546BB4CF57332230D237856B00D79C28A7C01D11F44B7304F69075
94B97A745DA43D1BE561372CE611C345A843834E46AD9DDB16CABCD3FA33D6F1
F6B5C0497F5EE5400B305CDC16A7EC286AA4D45D0EEBB9DA06AC9C5294D68EC9
E4DC3CA2B92CE8FC0526184A86EDC7AB34D67E60AC12D9CA8FD300235EC968BA
92C6FBDA47572BC5600F25249F60AD287CBDAE980E747FCBE7EE5CD323E733F0
63553B494D3DDEB9CC1480B5C3BB79A28E419AA65B18CB297AB383419E890E2A
CE6F98C9900CCB4675280A10CF060B8D220DDA1BE55DFA65715EABCC1AFAA271
B1F8732341613E17B231231A0D24D4D7FC198AE04D89A99C4536217769C6FBD9
5EE24A6302F97438F7C0E311C878F674B4477A5ADA3952CDE4055AC408B8174E
86F8FB797646DFFFE0ECA25D1BAB9A9F71F3926D3D85AA63E7A8C931D71E79E0
AF1EAC26FADE468F4FF7F3861D14C10E3BE1F9EAFD6D3A544E8108D5DAB5B180
3950C74818BC8AF4758A108F462EF1826647A49667F5E482038C54716856D9BC
35F29922846D2148F92F943E951D7438C73D6A60459A8003174036C64E1629CD
155D47FD04B03C023AD67CD5A70C98AB556EEAB8C48169706E5B352F6505D580
AC945171BFE62E81F8F500438AC3B64D857BA5BC54C2C4BBB237F8FA51296255
E66A92A61FE13FDE781D393557EB72CEBAD86511035F775FAC39A0479CCD400F
226709118F887F47CC2ECC8F79816D4A945B2845F50AFD62D8C9A9BBF4739496
9E644BC9F7B04803B7EE75A09EAE94365F6F374B4FCEB0B506C76297564B9B6B
8B812BC3A33929AA94692572B010E6210AEAA312BDFC88BF302244AB9D587A9B
919823FD01DE12438D960944D1977800FEB49E638C32E5B188B1CA033E0C37EE
A142F746367888AA119535F0CCAF7EAA461B790EB089D2D6962E28A398439BB7
9C9943654D7A2D765B46BC0DD1F915327F369162E1BA1BA83110B93F442905E0
523BFF5E279508A98568CD5CFD18FABBE9D17265A9042537872831BF5F1F340A
8D3E6DEA1D9675E87B3425FAA0172DBEFD7C28E30906B9FBA65517C9B58FB6BD
E0D474E69BB90B0D130A32C4130974A1C961CF064A5BE8EC1056858553FFCF7C
0D78627BDE04E5D0B9F6F72F92B61A915DFF7AFE7DC3807891D039AECEAC3F50
0A09579E661D3DC3022206061E0250B09A05CF198DF82D4F28FCD3671E815A6D
94820D0C87AB1DCEC251605D9490BC465D8A62C95B7352250D76D9FF1D3D5A32
9690780A5B56F9BA2083B29AAEA996FA95246D55AE88B0D3F6F307959251AFD9
82650287B5A98758C8FF3A60C40CBE3445ECB497F3E04C98DD52DCDB2F632D5E
FB5654C417A12EEEF2DB5F0CC54A379DA75BB9DEAB9FD9F256C1B832D55382E1
22A7DFDC37044BF0CC2CBCC4405D8A3495F4886001D615E1737FD9877EA3EB51
823C2FA1940BD8BD802C34BD648B41E268B825129BB13543961334C69DDD8407
97E868B79C83752682CB506FC1C801F63AE7B3B8D7EFD23C54232AA97FA8B2ED
EF2AE0382B4ECC8B24CFC62F698F8BBC90215BEAA8446BE6D261E30DCBEE8CE7
6BF8D0E51BE2597E8086F27D4C58573A21B571A6C3A8785CC183F33421C6C21F
549ED33B0E43C0A90A23BBF8B4DC168A19486FB441756086EF036C2DD39433DB
221E97FF0142AE5891F32651FF481AEE87FBAB6D9C6C10115B4FA53B078C765E
A4F3BAA3E5537FA5AA8829BAAF5D4B3B7C7BA544456BADB0218E6C9954301318
434ECBE8BA27BBDDC2F41FB320B3043CB8183D3E3BA7943BAC574DC57BDFF590
E9597CDF70F0E731014AEAD7936D9AB2ACDD7248997D90B097F4F1AB5399DEE8
922C7D90B45729FB17D366EE0C8575FD3F997CC7F53F9EFAF081DAC01F64D322
32636C3E4CB4E303BFEB77AE97FBD9C464BB2EA97FBD2CA3AA9FC93F8B84C3E5
ABDEBB442810CB391FC310E16903C855EEE29C757F7E5535025F3AE3D5439D2C
C454CDC43C8094A9A211BB1496FC8E719A4AC66206ADCE621528DB201E6F9669
7A40163094721EE69667B39BDE042D74355863C3324E05DDA851BBC78CDBCB7C
A52D1B163CA20D5FDE17AD00ADE82F2D35C98933EDA81C9B9087C3ED350FE9F6
2A1B2B9BB6E376F8A387B3D0C2A717732B815F50C1AF45EE6F504426E1267E25
204406765615F5AD80F0C97CACB173358CE57F488CF749F8CF7E5CA789359ECA
A4255E9651C13A64E27D76E1964476F5C253577B3D8608FDC82F9869845A333A
746446DF8F4D433B85059F58CB025CAB37FF9DC894BFF01FB5C81D72066173CD
EFC8B8A2467295A864F39C080976A766811DDD48FD1B77FB25FBE9B768FC8A94
A4849C9EBB93EEB6DF306DE0C8AF2483166B89B963596254181AA3807FBAF210
6B783C6853318CDE6B43148022CF0F3DF8668E8415115BA0024258731473318D
287BF87B2B64E2D5BE6B373BE2A1FA2352D93F210104C9B42ED9820F3EBAEC34
9020EEE1C180B27F05B59F6C2F0AEBB2533436E5E4F9985CCA61BBE63BCB98E4
A5F1ABDE9B05D9586794D59E1471FA1DF9B03AF5125A5E377A0B53A0FD97DBBC
9B9BD93BCDFFDA510A73B02BA0F1070F8CEAB52099D1FE6071E6A21E67783893
1815B213B0FA06AAC7723D82C3D4C941DD1A493A88B3E803B0400BC1CF374E7E
F57A6E6B91C9BB208B33D93B2BF45DA527FCC9E9CE77D6E462737C21668E90C1
3C581557A4A222016A550BD5CFDA5CB18E60D3DB86BEA9CAD7A981B9100B50A3
55746D943E4C6EFA136DE22FEDF7D03961929C8D4604B02565F288639D01FCC2
3602754E3A7BF774D2467F4326A07CE63D0694FFA0F1A8CABD1AFF161EC40821
1E611129E813DF7F533FEA74C1FDF8119F4B16273B1ACAE4F33BB229B3426A3E
81C2F417F87F1999987911A5B11300B30526D1515269E7421AA0F101BA284DB1
65B1FB5F757F0EA930E0DA0F52C4155A9B0779B2231FC6FBB52630E01F7758CC
8614F657F527BFAB52D5D774DD96EB7EF143820E06551201F74BE3B0E60B9186
A0E3DCB17CAB081755604CB8BDD1E58194EAEC18B47D017705A1384603589E9E
775D6E3F1DF1219F680729D8A75390A1468352542DBB7FFC29B73F279A286757
9588A3D396AE171853420F2E64E4B5ACDAEA73CF6F7FCE6F826E05BC6335693F
D5103767DDF6403F33DF136355B6FD4E90E8DAFA0E99F838C53EC3E2D5130D78
491F5DA45AABB03780B9DCE28585E0C3CD0A3E0C9F9CFED81304A202B478AA01
BE7F04CFFF47694805076375DB947AA2B840A4FF7BB76C607B17F61460256AF8
EF11343F5EFB5C47C0D74C53E6626B0B877C894BBD6E8DE4B271872AEBF4D26C
6B6B95C58DF9ECFA3F9A5972FC1948D3743CB669A00904FEC777B200163B9A64
71429EAAC187F843D0C582CB9FE1064C228A58C08549B744091DCC2003CAF77A
D35F4840725BF33D1806C94796A3FA24B19A5E97A7FE9EBDD0BB72EFE9E77B1B
66E926FB6BFE5E473AEE54169AE3013CAF775330343D2621307BCA3FEF7135F4
72A8294879E1A81056AF097FFA1FCF54DA79A1267629153BFD2D2B163A54D165
C0558009E90749DD8C11BDE0913308C2E081BFC9872C537F798B974BF5BB06F6
FDF3D90D232B56CF4A4975CB3BA278328A2A06BB31CA1D37E09E62D75ADAC18C
5ADEAECB8F062D69882AEC807CF83D1145E8A62A98E388BB35E646A39FEDFEB1
5831765CD962C7C65FC75DE29B429E447B116998D16B9D98F1B0F31A511BB232
692DFD2E9C79B981A46E43822A21952C374A73E8A4F27DC31CE8D604A04AA141
727A8477805DC15A3E670FFA7DAE4C99AEB48D14CBB79B844580BBAA07DA28E2
0A594FA8E8A1251C9CA0EB07B7B8288AB4E7A1D9F7A0B47341C6A644438EEF77
10E1D2B17CE37DD26C6AACCAC062397EB2245500E2AC57D3ABEBAF8E25C3B2B7
DFB3E5C96079D0B5ED292DE18F485837F2DAF724A6CB68B4EC99ED28D2B4A7B6
341D4914A2FDF68F6CDBFB47BE43205D84672EF0699FADAFC3B590720AEABD9A
0ECE6000CB3221BCEA842ED9A0AC71601A29B2A09331A8448C999A9BD139673E
6A81EDD7E9388E82565218729EB44B22B1C39FA20E1682FE435D0A73685D2C1A
A5CB97924CFFB3A9D65AB813F2115CC0D8DDF83929F156FE9625C46684A9BD08
FC8A8E18CBBCFACFFA0C4416A3BC9E35E9E406E427EE883EAD1EC7040A2393BE
415D00714978E352F4D3BE1772B0D5FC379E208F7988F2931D723041092BE7D8
665FD0A5986165C44F298B8041C20E51F600300207C80FC31F12D836B658C02F
21C52EEDF16A879EB21F408292789868AF0C325343DFFFAB104B02FFDED00FAE
3EFB2BA97E73348F2A4E72A259C732679EA130EB7F19D2A85827CEBC41D6F4AA
1F08A9B44B3DB5ACE95006C4ECE1B24A919BE1FA278AD38DF842A0D5D9AAC892
A12A6AF017F65F043533D185BE87A5B58BB2DE224959092AC7CE9C73C8D7DCC5
18A8AA4726CF2A1EB4CA302C74110D8A2B2FC177AB8275065F68EA56F7451E90
B3A7B01560B72DD0B53D08BD8B3E5981D1BC8FC9337FE7FD2BDE9AD0EA0DA9F4
52A18AE83C5857F626339CFC986846D15506C2EB80BEA35048E4C646089900C3
FBC3C1DA152B23FCAA40F9D28825A964F9D9842097BA8D3BAB84CF70A1694738
862B7A2BA021FF50B915214008801FE0F8A84CE4BE92183E1C2704C2B95FA4DB
0322B4FD667F85693D2B1919DCA12BF3A6A721F3D72030571ABCE023E2E3602B
A65610033D306A3BA476F19977F2B7C330E59C58605910A523F1C44FC16FFF1A
95051290EC5F3FE3774DD66EB7845C00C02F31B42B0A9AED7C392E18BFD14553
64BA278AE9466FF1428A1E433DB6FA3CB89E7757DEEF08D7C6A910141866EF6D
469465B4AF1D5D7E609F728D61D6B13F56E82DC93C6EDFEAEC05382C3A4F036E
F0B54497DDA3566ED1C79215F8E1F683DE5DEF3159288B3C421041C55A9158F2
9E667363391297D495B59415DFAE25239285620580FD03AA4AF62CBA505F6B38
105845E0D545EE1C04CB2CB5B234E918DE7EF14866CF8EC0894BFAD6622027F9
E0F7B3FCA3A9F37E7CCD0C2CC94B95B76DAE49CB8B1EA2FD2C2D5F84A9ABB8A5
2EE7E6BAA332BB692BB2FF0A167300F03A3CBF9D64369BC1EAF1E96815AE9853
D8D2B1224DDA4C80F2B4EB6E89C6636DDE19040D875A4E1F4747F81AD1E589ED
C1FF4E1DD2B33F2D192611140B9971DBE4F017F3B91CF25EC412E46DFBB27517
A4D0F234BE7A523020DA774012E84BBECEB47AE6D0292CA8C2E21A1695297B1F
0BBD992C59FDFB41BFD4A99485FEF789CB16B6881B79D0D719F6604D8A90CDE9
60ED4D6317AB20EA45120C41A0FC827CCBB7AE058FC854B944DC58C4FAC388C4
28AEFE819CFD955309627A16ECEE370BFA489822F35F7E8BCAD43C7C02068A4E
532FCF882E0A3F806A2D65E9D3A96405D815CA35B7EFF8A256218D9148391C26
6368163FC05CE6CBC8D068FED4DE4AE872A3A17945ED57E1B1FDE1C88D6543C2
6F03BFDC9FE78AFA6607B0CFEFDB4A2E23067C32D36E1F438A33269DB1213746
0663B1C36CF634963D8CC64702221DFA9860B0296084F84E3EB66EF4E5893359
A67A25C1D28726373F2A95948339704D8E85A9BC5453B802C4294CEBC11DEB67
3FE579CCEB8D7AC4769F892AA4CA3BF0F7B30613E53CC63E390EC2746FA038AD
FAD712A9E5E5C5FB0DEA49D576F4E5D7C14E01A41A3E660313F148D28C7C9461
948C47B8E008F3BC052197BCF46E7EA97E2041E5D05BB7F973AFE45211854B3C
A413702DEEF821111E54BA0FFC46DB2A2A552BE126AC01E4A1DE6D2EA917B6BB
5C188CD758CD0C2195777B38CA1F713ACC291BF8F45D27422E8E079D39AA8E9C
D9BFC4BC0C92C6DE7F7B4F6A9C61995EEA61F9D0B27C5FA4772FD786A35642EB
E459683887FDE64AB76C268B9447E35245A3B2285437D4FF6795F1233D2DCEB5
38EF3F6E8EF35E99D1153AF83908297A962130FF12BFED4C36FBA92AEB147F8E
84D532AD189ABF01EF864F8B2D464E99AC79B5961F205B5CCEC73E64E029E5D5
B83330A4235B9CEC4E5F4FF6940333410A9AB7BE7E87A579FA0D05AE7FAC5D24
C69935F9E62328063D179EF732146940E258D305651C78483882F0A431E1209B
5FB9D26F90745FE2144C4FE726D34FE8850DE7CE116B4BD55CAC73BCDF7DFBEC
6AFE24BB1DE92E74BE763B5A9C65A24CA167DE545D33AE6089BE0E3F757A6286
CB9A3D2A7C3FE3BFCCB2A6A029F12786F0DF3418F9A68195C6D560E6E1B944E2
F40571D3492A5D9EB05E055263496ABC0E6DDCB3EC37C043E84A1BEA363A429F
501213F4A0227A73A1D119D0E8EEA22F43C5D18BF7A58BFF481D6A6FBBA09C67
F6B8AD6C9364F0A7A40CE957BEAAC2EDE297431D6333D2E2EA97324C2A70822A
4261D75490E442F480E6BD5976E8DCBF21AF6791F469C4296EE044BF851754FC
C03C84E7165DB5805D6514CF042F01FBED69161F3DFD3F941652391C607FCD25
5089F4964B418F24B0400079FBD9BEC5EE2014D9922FC96423EB4FAA2BCAE4BA
93AD10EC48FDB9270029D4C26195B60556657B9CA25F8CD566DAA4E7B6F3C16B
7623498643EAB7E9D56946A7D53CF63ED37E8A52A0CC432B9536499E296BC686
CD5945BFD987A2AD0865B9ACF88394902035604F13CC380C4772CDF788264412
68F9909F989246B2A8B407C1D0A061E6EB1615A65FA4A587C7CAFE0459DEDCF3
E9EE4B7151395AC8DCEFD2C2F5DF75C92E54BB420436AFDBF8695C9D81EE02AF
911AED4F770A99B15947C97DD14C37D824C7D679ABF16E64856372C2D1074401
EAD94452A3778D1F91AAA0A4EFD8602D3E791D4B38789252B33249315FCA090E
9DEB927E633D744984689692AC09241B323A8B555F02EDF8F016C3B670EAAB47
B5B4F2296B3D9B41C83AFA462089A35FDC94AE4B7FF3732D378610CEB4C7EB5B
682A232C2CBD03E3B43F6197EC4386AFBEA7C8868CE29857AC764A193FE3D89F
F6E187DB23AEBE6556FD04154F5873BD0DBBF1981C984FA8D6E4875191381EB5
3F1E5D2CD38C7BA76057FC36C6E4E18209755883E2CC34D88A3EAB92DBB47C10
FAD0FC3B2DDBBC4A20F1BDB88001D79164CC94F39B2A044E713CEEA89BAA7FD6
0F0EF028558E7E411280B7C8632EBDA4197FD5F9FA87A197E4EC7A9CF1EEB9B1
91363196BE989D0176CADA6D5A65F97D155A51A6E09BE920FCB3426BBF22C7BB
BB4345EE3F7BB46427050603F118FF2281C92BF81357E9F5E3A14E9D0509887D
EC1EDD13D48CE2545EBA1731318D818E8595D04254273B43EB382EBB6C31463F
E330202D64F17F064E28528E353618155517C2EAB4F81FBE0EC480921FFB08CE
8DC8866D2782010EFBE3F05EF44F2EEE1AA6DD711DCA361EBF3DC12BF3845C25
0C434E37CD60156BEA761B1188BA23A866CAFB152457271AF11B92BC09ACC800
9A15109B708F7061D91BB1A6A8E4ECA9965A37BC453911714099AEF22162D679
DF43218C0EDBFAD87385C06E46F90F7E423AF6B20DAF130347475EF7F17EE57C
2E0489F6C8B20BC15FE734F15DF9C25DE6252422A4B2244161CDCCFE741A01D0
7418D4D854ACB438748ADF1C03072092C637BD873617B7649DB7900611631F7E
C078B227CBCF79C173261413CF39D5BE966580BD1D0AF3B9E6D872226FD02F48
2FC4735526F5F6B17638A4AE74155BF1F68DF51928
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 39158274 55380987 1000 600 600
(/Users/fred/depotsGithub/G3DM64/./MonCoursG3D_M64.dvi)
@start /Fa 94[33 127[46 33[{}2 45.8281 /Fourier-Math-Symbols
rf /Fb 144[31 111[{ TeXBase1Encoding ReEncodeFont }1
50.1859 /NewCenturySchlbk-Bold rf /Fc 57[49 49 197[{}2
68.7422 /Fourier-Math-Symbols rf /Fd 133[32 35 35 12[39
6[42 31 39 40 97[{ TeXBase1Encoding ReEncodeFont }8 69.4894
/NewCenturySchlbk-Italic rf /Fe 93[51 162[{}1 70.9837
/Fourier-Math-Letters rf /Ff 67[44 188[{}1 67.2477
/Fourier-Math-Letters-Italic rf /Fg 22[35 115[42 27 2[39
1[35 42 1[22 2[22 4[40 2[39 16[46 54 31[19 5[23 23 14
39[{ TeXBase1Encoding ReEncodeFont }16 69.4889 /NewCenturySchlbk-Roman
rf /Fh 22[34 115[47 27 34 34 43 44 39 47 69 3[26 3[34
47 2[44 28[60 68[{ TeXBase1Encoding ReEncodeFont }15
77.2099 /NewCenturySchlbk-Italic rf /Fi 183[47 51 40
44 47 47 47 47 14[36 50[{ TeXBase1Encoding ReEncodeFont }9
65.3798 /Helvetica-Bold rf /Fj 167[35 7[35 2[44 32 6[35
69[{ TeXBase1Encoding ReEncodeFont }5 52.3038 /Helvetica-Bold
rf /Fk 173[51 82[{}1 76.3801 /Fourier-Math-BlackBoard
rf /Fl 203[33 33 33 33 33 48[{ TeXBase1Encoding ReEncodeFont }5
58.6795 /NewCenturySchlbk-Roman rf /Fm 133[21 23 23 12[26
15 15 38[33 33 65[{ TeXBase1Encoding ReEncodeFont }8
46.3263 /NewCenturySchlbk-Italic rf /Fo 66[47 6[34 34
31 31 2[42 25 12[30 30 47[76 50[63 1[63 1[63 1[63 56[{}14
76.3801 /Fourier-Math-Extension rf /Fp 133[29 31 31 12[34
19 21 37[45 45 43 65[{ TeXBase1Encoding ReEncodeFont }9
61.7684 /NewCenturySchlbk-Italic rf /Fq 129[40 126[{}1
63.0966 /Fourier-Math-Letters rf /Fs 167[39 4[39 3[45
42 48 5[45 36 39 1[42 42 42 65[{ TeXBase1Encoding ReEncodeFont }11
58.1154 /Helvetica-Bold rf /Ft 222[83 32[65{}2 83.022
/CMSY10 rf /Fu 239[65 3[55 12[{}2 83.022 /stmary10 rf
/Fv 206[33 49[{}1 58.1154 /CMR7 rf /Fw 58[42 148[17 48[{}2
58.049 /Fourier-Math-Symbols rf /Fx 54[45 51[37 32[24
11[38 6[34 12[41 39 45 1[41 48 50 58 41 2[25 1[48 41
45 48 45 1[45 10[34 1[34 2[34 49[{ TeXBase1Encoding ReEncodeFont }23
61.7679 /NewCenturySchlbk-Roman rf /Fy 207[19 48[{}1
58.1154 /CMSY7 rf /Fz 254[69 1[{}1 83.022 /CMR10 rf /FA
131[32 27 39 41 47 59 40 48 7[73 1[43 6[43 36 36 44 17[63
1[81 9[59 63 62 32[54 6[47 25[{}21 83.022 /CMMI10 rf
/FB 130[25 1[25 123[{ TeXBase1Encoding ReEncodeFont }2
76.3802 /NewCenturySchlbk-Roman rf /FC 57[55 55 7[55
8[55 1[38 14[55 21 55 35[59 12[64 5[21 13[55 28[59 3[57
1[42 2[0 3[45 5[76 2[76 76 6[76 33[{}21 76.3802 /Fourier-Math-Symbols
rf /FD 133[27 29 29 19[36 22[55 8[46 42 42 41 65[{
 TeXBase1Encoding ReEncodeFont }9 58.6799 /NewCenturySchlbk-Italic
rf /FF 133[36 39 39 60 40 47 27 5[47 2[43 24 26 4[47
34 43 44 13[51 1[60 51 60 1[73 3[31 64 60 51 56 60 56
56 54 65[{ TeXBase1Encoding ReEncodeFont }29 77.2105
/NewCenturySchlbk-Italic rf /FG 209[21 1[21 44[{
 TeXBase1Encoding ReEncodeFont }2 77.2105 /NewCenturySchlbk-Roman
rf /FH 93[56 35[50 126[{}2 78.8708 /Fourier-Math-Letters
rf /FI 60[59 1[52 4[49 2[48 48 8[49 52 49[25 124[{}8
74.7197 /Fourier-Math-Letters-Italic rf /FJ 22[53 53
7[57 22[70 79[57 57 1[57 63 39 46 48 60 62 57 63 89 33
2[34 63 57 36 53 62 52 1[57 10[70 2[62 2[70 8[77 1[70
77 72 1[70 9[53 1[53 53 53 53 53 2[26 6[22 39[{
 TeXBase1Encoding ReEncodeFont }41 92.6518 /NewCenturySchlbk-Bold
rf /FK 22[64 31[84 80[68 2[76 47 56 58 72 74 68 76 107
39 2[41 1[68 1[64 74 62 1[68 10[84 3[91 12[84 13[64 64
64 64 64 64 64 2[31 6[27 39[{ TeXBase1Encoding ReEncodeFont }31
111.182 /NewCenturySchlbk-Bold rf /FL 54[117 116[111
103 125 1[117 128 128 151 111 2[68 1[128 1[117 128 120
1[117 65[{ TeXBase1Encoding ReEncodeFont }15 153.678
/NewCenturySchlbk-Bold rf /FM 139[68 1[83 1[107 6[59
110 2[92 3[98 29[125 16[92 50[{ TeXBase1Encoding ReEncodeFont }9
160.133 /NewCenturySchlbk-Bold rf /FN 6[47 10[24 3[39
39 39 34 6[43 22[56 13[33 15[33 20[43 28[41 41 1[41 47
30 36 34 43 44 39 47 69 24 1[23 24 47 41 26 39 44 34
43 43 3[26 1[26 4[56 63 51 49 56 60 51 60 1[73 51 1[43
31 64 60 51 56 60 56 56 56 1[34 3[21 21 43 43 43 43 43
43 43 43 43 43 1[21 26 21 2[26 26 16 5[23 30[47 2[{
 TeXBase1Encoding ReEncodeFont }77 77.2099 /NewCenturySchlbk-Roman
rf /FO 54[47 116[45 41 50 1[47 51 51 61 45 2[27 1[51
1[47 51 48 1[47 65[{ TeXBase1Encoding ReEncodeFont }15
61.7679 /NewCenturySchlbk-Bold rf /FP 21[44 44 44 110[47
47 1[47 53 33 39 40 50 51 47 53 74 27 2[29 53 47 1[44
51 43 50 47 10[59 64 1[51 2[59 1[64 76 3[34 3[59 64 60
1[59 7[44 44 44 44 44 44 44 44 44 44 1[21 26 3[30 30
19 36[53 2[{ TeXBase1Encoding ReEncodeFont }51 77.2099
/NewCenturySchlbk-Bold rf /FQ 23[110 115[82 96 100 4[185
68 2[71 3[110 128 1[124 117 12[139 44[46 39[{
 TeXBase1Encoding ReEncodeFont }13 192.098 /NewCenturySchlbk-Bold
rf /FR 170[60 2[54 3[60 8[54 1[54 1[54 65[{
 TeXBase1Encoding ReEncodeFont }6 74.1214 /NewCenturySchlbk-Roman
rf /FS 137[50 3[41 2[46 57 82 7[46 2[52 21[62 5[62 17[52
1[52 52 52 1[26 46[{ TeXBase1Encoding ReEncodeFont }14
92.6518 /NewCenturySchlbk-Roman rf /FT 22[67 111[72 3[82
52 62 59 74 77 67 82 119 42 2[42 3[67 77 59 1[74 12[89
6[126 4[111 104 5[96 10[74 1[74 12[27 39[{
 TeXBase1Encoding ReEncodeFont }25 133.419 /NewCenturySchlbk-Roman
rf(cmmi10)cvn 9.96265 /FA 1 fstore(cmr10)cvn 9.96265
/Fz 1 fstore(cmsy7)cvn 6.97385 /Fy 1 fstore(cmr7)cvn
6.97385 /Fv 1 fstore(cmsy10)cvn 9.96265 /Ft 1 fstore
end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100 -372
a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 100 -372
a 0 TeXcolorgray Black 0 TeXcolorgray 109 -121 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 109
-121 a 109 -121 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 109 -121 a 109 -121 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 109 -121 a 109
-121 a
SDict begin [/Count -7/Dest (chapter.2) cvn/Title (g\351om\351trie dans l'espace)
/OUT pdfmark end
 109 -121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.1) cvn/Title (Rappels) /OUT
pdfmark end
 109 -121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.2) cvn/Title (Vecteur de l'espace)
/OUT pdfmark end
 109
-121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.3) cvn/Title (Rep\351rage dans l'espace)
/OUT pdfmark end
 109 -121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.4) cvn/Title (Repr\351sentation param\351trique)
/OUT pdfmark end
 109 -121 a 109
-121 a
SDict begin [/Count -0/Dest (section.2.5) cvn/Title (\311quations cart\351siennes de l'espace)
/OUT pdfmark end
 109 -121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.6) cvn/Title (Exercices r\351solus)
/OUT pdfmark end
 109 -121 a 109 -121 a
SDict begin [/Count -0/Dest (section.2.7) cvn/Title (Exercices) /OUT
pdfmark end
 109
-121 a 109 -121 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 109 -121 a 109 -121 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 109 -121 a 109
-121 a
SDict begin H.S end
 109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 109
-121 a 0 TeXcolorgray 0 TeXcolorgray 907 2090 a FT(G\351om\351trie)36
b(analytique)g(dans)g(l'espace)1714 2273 y(MA)n(TH64)1676
2621 y FS(F)-12 b(.)28 b(L)t FR(A)t(N)t(C)t(E)t(R)t(E)t(A)r(U)1608
2853 y FS(14)d(novembre)h(2012)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray 0 TeXcolorgray -128 -121
a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121 a
SDict begin [/View [/XYZ H.V]/Dest (chapter*.1) cvn /DEST pdfmark end
 -128
-121 a 747 x FQ(T)-14 b(able)56 b(des)f(mati\350res)-128
1135 y
SDict begin H.S end
 -128 1135 a FP(2)74 b FO(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t(I)t
(E)25 b(D)t(A)t(N)t(S)i(L)m FP(')t FO(E)t(S)t(P)o(A)t(C)t(E)1061
1135 y
SDict begin 12 H.L end
 1061 1135 a 1061 1135 a
SDict begin [/Subtype /Link/Dest (chapter.2) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
[1 0 0] H.B /ANN pdfmark end
 1061 1135 a 2547 w FP(3)-12
1235 y
SDict begin H.S end
 -12 1235 a FN(2.1)71 b(Rappels)452 1235 y
SDict begin 12 H.L end
 452
1235 a 452 1235 a
SDict begin [/Subtype /Link/Dest (section.2.1) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 452 1235 a 19 w FN(.)37 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)p 0 TeXcolorgray
102 w(3)p 0 TeXcolorgray -12 1334 a
SDict begin H.S end
 -12 1334 a FN(2.2)71
b(V)-6 b(ecteur)21 b(de)h(l'espace)840 1334 y
SDict begin 12 H.L end
 840 1334
a 840 1334 a
SDict begin [/Subtype /Link/Dest (section.2.2) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 840 1334 a 37 w FN(.)37 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)p 0 TeXcolorgray 102 w(6)p 0 TeXcolorgray -12
1434 a
SDict begin H.S end
 -12 1434 a FN(2.3)71 b(Rep\351rage)21 b(dans)g(l'espace)988
1434 y
SDict begin 12 H.L end
 988 1434 a 988 1434 a
SDict begin [/Subtype /Link/Dest (section.2.3) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 988 1434 a 63 w FN(.)37
b(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)g(.)g(.)g(.)g(.)g(.)p 0 TeXcolorgray 102 w(8)p
0 TeXcolorgray -12 1533 a
SDict begin H.S end
 -12 1533 a FN(2.4)71 b(Repr\351sentation)20
b(param\351trique)1222 1533 y
SDict begin 12 H.L end
 1222 1533 a 1222 1533 a
SDict begin [/Subtype /Link/Dest (section.2.4) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end

1222 1533 a 61 w FN(.)37 b(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)p 0 TeXcolorgray
102 w(9)p 0 TeXcolorgray -12 1633 a
SDict begin H.S end
 -12 1633 a FN(2.5)71
b(\311quations)21 b(cart\351siennes)g(de)g(l'espace)1400
1633 y
SDict begin 12 H.L end
 1400 1633 a 1400 1633 a
SDict begin [/Subtype /Link/Dest (section.2.5) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 1400 1633 a 56 w FN(.)37
b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
p 0 TeXcolorgray 59 w(10)p 0 TeXcolorgray -12 1733 a
SDict begin H.S end

-12 1733 a FN(2.6)71 b(Exercices)22 b(r\351solus)780
1733 y
SDict begin 12 H.L end
 780 1733 a 780 1733 a
SDict begin [/Subtype /Link/Dest (section.2.6) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 780 1733 a 39 w FN(.)37
b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)p 0 TeXcolorgray
59 w(13)p 0 TeXcolorgray -12 1832 a
SDict begin H.S end
 -12 1832 a FN(2.7)71
b(Exercices)503 1832 y
SDict begin 12 H.L end
 503 1832 a 503 1832 a
SDict begin [/Subtype /Link/Dest (section.2.7) cvn/H /I/Border [0 0
1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
 503 1832
a 26 w FN(.)37 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
g(.)g(.)p 0 TeXcolorgray 59 w(16)p 0 TeXcolorgray 340
3194 a @beginspecial -1 @llx -15 @lly 72 @urx 57 @ury
730 @rwi @setspecial
%%BeginDocument: geospace.1
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -1 -15 72 57 
%%HiResBoundingBox: -0.25 -14.42323 71.11613 56.9429 
%%Creator: MetaPost 0.901
%%CreationDate: 2007.11.11:1705
%%Pages: 1
%%BeginProlog
%%EndProlog
%%Page: 1 1
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
 0 0.5 dtransform truncate idtransform setlinewidth pop [] 0 setdash
 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
56.6929 0 lineto
56.6929 56.6929 lineto
0 56.6929 lineto
0 0 lineto stroke
 [3 3 ] 0 setdash
newpath 70.86613 42.51967 moveto
14.17323 42.51967 lineto
0 56.6929 lineto stroke
 [] 0 setdash
newpath 56.6929 56.6929 moveto
70.86613 42.51967 lineto
70.86613 -14.17323 lineto
56.6929 0 lineto stroke
newpath 0 0 moveto
14.17323 -14.17323 lineto
70.86613 -14.17323 lineto stroke
 0.5 0 dtransform exch truncate exch idtransform pop setlinewidth
 [3 3 ] 0 setdash
newpath 14.17323 -14.17323 moveto
14.17323 42.51967 lineto stroke
grestore
showpage
%%EOF

%%EndDocument
 @endspecial 1076 w @beginspecial -1 @llx -1 @lly 77
@urx 72 @ury 780 @rwi @setspecial
%%BeginDocument: geospace.2
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -1 -1 77 72 
%%HiResBoundingBox: -0.25 -0.25 76.78532 71.11613 
%%Creator: MetaPost 0.901
%%CreationDate: 2007.11.11:1705
%%Pages: 1
%%BeginProlog
%%EndProlog
%%Page: 1 1
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
 0 0.5 dtransform truncate idtransform setlinewidth pop [] 0 setdash
 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
56.6929 0 lineto
56.6929 56.6929 lineto
0 56.6929 lineto
0 0 lineto stroke
newpath 56.6929 0 moveto
76.53532 14.17323 lineto
76.53532 70.86613 lineto
19.84242 70.86613 lineto
0 56.6929 lineto stroke
newpath 56.6929 56.6929 moveto
76.53532 70.86613 lineto stroke
 [3 3 ] 0 setdash
newpath 0 0 moveto
19.84242 14.17323 lineto
76.53532 14.17323 lineto stroke
 0.5 0 dtransform exch truncate exch idtransform pop setlinewidth
newpath 19.84242 14.17323 moveto
19.84242 70.86613 lineto stroke
grestore
grestore
showpage
%%EOF

%%EndDocument
 @endspecial 1118 w @beginspecial -21 @llx -1 @lly 57
@urx 72 @ury 780 @rwi @setspecial
%%BeginDocument: geospace.3
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -21 -1 57 72 
%%HiResBoundingBox: -20.09242 -0.25 56.9429 71.11613 
%%Creator: MetaPost 0.901
%%CreationDate: 2007.11.11:1705
%%Pages: 1
%%BeginProlog
%%EndProlog
%%Page: 1 1
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
gsave newpath -28.34645 -28.34645 moveto
-28.34645 141.73225 lineto
141.73225 141.73225 lineto
141.73225 -28.34645 lineto
 closepath clip
 0 0.5 dtransform truncate idtransform setlinewidth pop [] 0 setdash
 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
56.6929 0 lineto
56.6929 56.6929 lineto
0 56.6929 lineto
0 0 lineto
-19.84242 14.17323 lineto
-19.84242 70.86613 lineto
0 56.6929 lineto stroke
newpath 56.6929 56.6929 moveto
36.85048 70.86613 lineto
-19.84242 70.86613 lineto stroke
 [3 3 ] 0 setdash
newpath 56.6929 0 moveto
36.85048 14.17323 lineto
36.85048 70.86613 lineto stroke
newpath -19.84242 14.17323 moveto
36.85048 14.17323 lineto stroke
grestore
grestore
grestore
showpage
%%EOF

%%EndDocument
 @endspecial -128 5186 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 -128 5186 a -106 5186 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 170.71646 a add def
/d 0.0 a add neg def /h 227.62195 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 -106
5186 a -472 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 113.81097 0.0 113.81097
113.81097 56.90549 113.81097 0.0 56.90549 0.0 0.0   /Lineto /lineto
load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3
lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll
/y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1
add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 113.81097 0.0 170.71646
56.90549 170.71646 170.71646 113.81097 113.81097   /Lineto /lineto
load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3
lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll
/y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1
add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 113.81097 113.81097 56.90549
113.81097 28.45274 142.26372 56.90549 170.71646 170.71646 170.71646
  /Lineto /lineto load def 1  setlinejoin false NArray n 2 eq { 0 0
/n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.75
 setgray  1. .setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 56.90549 113.81097 0.0
56.90549 28.45274 142.26372   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
1311 5186 a
currentpoint initclip moveto
 1311 5186 a -128 5186 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 -128 5186 a 1118
5186 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 1118 5186 a 1139 5186 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 214.5335 a add def
/d 0.0 a add neg def /h 298.7538 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1139 5186 a -236 x @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 85.9274 0.0 199.73837 113.24179
199.73837 255.50551 142.83289 198.60002 142.83289 255.50551 114.38014
227.05276 114.38014 84.78905 85.9274 56.3363 85.9274 27.88356   /Lineto
/lineto load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def
} if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2
mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1
y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n
n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12
x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11 sub
Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add
def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add y11
Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.75
 setgray  1. .setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 85.9274 56.3363 114.38014
84.78905 114.38014 227.05276 85.9274 227.05276 85.9274 198.60002 0.56917
198.60002 0.56917 170.14728 85.9274 170.14728 85.9274 84.78905 57.47466
56.3363 57.47466 0.0 85.9274 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 85.9274 198.60002 85.9274
227.05276 29.02191 227.05276 0.56917 198.60002   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 114.38014 227.05276 142.83289
255.50551 114.38014 255.50551 85.9274 227.05276   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 142.83289 198.60002 142.83289
226.48402 171.28563 255.50551 199.73837 255.50551   /Lineto /lineto
load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3
lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll
/y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1
add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 85.35823 56.90549 56.90549 56.90549
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 113.81097 85.35823 85.35823 85.35823
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2920 5186 a
currentpoint initclip moveto
 2920 5186 a 1118
5186 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 1118 5186 a 2545 5186 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 2545 5186 a 2567 5186
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 256.07469 a add def
/d 0.0 a add neg def /h 256.07469 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2567 5186 a -472 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 85.35823 85.35823 56.90549
56.90549 56.90549 85.35823 85.35823 113.81097 142.26372 113.81097 142.26372
85.35823 199.1692 85.35823 199.1692 170.71646 227.62195 170.71646 227.62195
0.0 85.35823 0.0   /Lineto /lineto load def 1  setlinejoin false NArray
n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt
{ CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1
x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div
def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 0.0 85.35823 56.90549 85.35823
56.90549 56.90549 0.0 56.90549   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 56.90549 85.35823 85.35823
113.81097 142.26372 113.81097 170.71646 142.26372 56.90549 142.26372
0.0 85.35823   /Lineto /lineto load def 1  setlinejoin false NArray
n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt
{ CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1
x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div
def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 142.26372 113.81097 142.26372
85.35823 199.1692 85.35823 199.1692 113.81097 170.71646 113.81097 170.71646
142.26372   /Lineto /lineto load def 1  setlinejoin false NArray n
2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt {
CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1
def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def
x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 227.62195 170.71646 199.1692
170.71646 227.62195 199.1692 256.07469 199.1692 256.07469 28.45274
227.62195 0.0   /Lineto /lineto load def 1  setlinejoin false NArray
n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt
{ CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1
x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div
def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 170.71646 113.81097 142.26372 85.35823
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 256.07469 199.1692 227.62195 170.71646
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
4693 5186 a
currentpoint initclip moveto
 4693 5186 a 2545 5186 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 2545 5186 a 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 3 3
TeXDict begin 3 2 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.3) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 109 -237 3780 2 v 0 TeXcolorgray
109 -121 a
SDict begin H.S end
 109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121
a
SDict begin [/View [/XYZ H.V]/Dest (chapter.2) cvn /DEST pdfmark end
 109 -121 a 706 x FM(Chapitre)45 b(2)114 1000 y FL(G)10
b(\311)g(O)g(M)g(\311)g(T)g(R)g(I)g(E)60 b(D)10 b(A)g(N)g(S)62
b(L)-7 b FQ(')10 b FL(E)g(S)g(P)o(A)g(C)g(E)109 1334
y
SDict begin H.S end
 109 1334 a 109 1334 a
SDict begin 12 H.A end
 109 1334 a 109 1334 a
SDict begin [/View [/XYZ H.V]/Dest (section.2.1) cvn /DEST pdfmark
end
 109 1334
a 0.93 0.26 0 TeXcolorrgb 147 x FK(2.1)110 b(Rappels)p
0 TeXcolorgray 109 1587 a
SDict begin H.S end
 109 1587 a 109 1587 a
SDict begin 12 H.A end
 109 1587
a 109 1587 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.1.1) cvn /DEST pdfmark
end
 109 1587 a 0.932 0.464 0 TeXcolorrgb 93
x FJ(2.1.1)92 b(G\351n\351ralit\351s)p 0 TeXcolorgray
0.094 0.455 0.804 TeXcolorrgb 109 1833 a
SDict begin H.S end
 109 1833 a 109
1833 a
SDict begin 12 H.A end
 109 1833 a 109 1833 a
SDict begin [/View [/XYZ H.V]/Dest (section*.2) cvn /DEST pdfmark end
 109 1833 a FP(Axiomes)22
b(d'incidence)p 0 TeXcolorgray 109 1987 a FN(Les)f(axiomes)f
(d'incidence)j(de)e(la)h(g\351om\351trie)e(dans)h(l'espace)g(sont)g
(des)g(axiomes)g(qui)g(fournissent)g(des)g(relations)g(entre)109
2086 y(les)g(points)n(,)h(les)f(droites)h(et)f(les)g(plans)h(de)f
(cette)g(g\351om\351trie)o(.)109 2110 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 2110 a 109
2110 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 2110 a 0 TeXcolorgray 0 TeXcolorgray 166 2250
a FN(\226)p 0 TeXcolorgray 42 w(P)m(ar)29 b(deux)f(points)h(distincts)
35 b FF(A)c FN(et)e FF(B)g FN(de)f(l'espace)g(il)h(passe)e(une)h(et)g
(une)g(seule)g(droite)o(.)g(Cette)f(droite)h(peut)h(\352tre)251
2350 y(not\351e)20 b FH(\242)p FN(,)k FF(d)619 2364 y
FD(A)t(B)735 2350 y FN(ou)d(encore)g(\()6 b FF(A)t(B)r
FN(\).)p 0 TeXcolorgray 166 2450 a(\226)p 0 TeXcolorgray
42 w(\311tant)29 b(donn\351s)f(deux)i(points)35 b FF(A)e
FN(et)c FF(B)r FN(,)g(il)h(existe)g FF(C)h FN(tel)e(que)35
b FF(A)s FN(,)c FF(B)f FN(et)g FF(C)i FN(ne)d(soient)f(pas)h
(align\351s)n(.)i(P)m(ar)e(ces)g(trois)251 2549 y(points)n(,)22
b(il)g(passe)f(un)h(et)f(un)h(seul)f(plan.)h(Ce)f(plan)i(peut)e
(\352tre)g(not\351)g FI(\274)p FN(,)h FI(\303)p FN(,)g
FI(\274)2555 2563 y FD(A)t(B)r(C)2692 2549 y FN(,)g FI(\303)2798
2563 y FD(A)t(B)r(C)2958 2549 y FN(ou)f(encore)g(\()6
b FF(A)t(B)s(C)s FN(\).)p 0 TeXcolorgray 166 2649 a(\226)p
0 TeXcolorgray 42 w(Si)30 b FF(A)e FN(et)d FF(B)g FN(sont)f(deux)h
(points)f(d'un)h(plan)g FI(\274)p FN(,)g(tous)f(les)g(points)g(de)g(la)
h(droite)h FF(d)2715 2663 y FD(A)t(B)2833 2649 y FN(appartiennent)g(au)
e(plan)h FI(\274)p FN(.)g(La)251 2749 y(droite)e FF(d)537
2763 y FD(A)t(B)653 2749 y FN(est)d(inc)o(luse)j(dans)f
FI(\274)f FN(\()r FF(d)1394 2763 y FD(A)t(B)1501 2749
y FC(\275)15 b FI(\274)p FN(\))p 0 TeXcolorgray 138 2143
3747 4 v 138 2789 4 648 v 3881 2789 V 138 2791 3747 4
v 3883 2824 35 651 v 171 2824 3747 35 v 109 2110 a
tx@Dict begin  PutEnd  end
 109
2110 a 109 2110 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 2110 a 109 2110 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 2110 a 0
TeXcolorgray 163 2220 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
43.80782 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial
FP(Axiomes)p 0 TeXcolorgray 109 2110 a
tx@Dict begin  PutEnd  end
 109 2110 a 0.094 0.455 0.804
TeXcolorrgb 109 3146 a
SDict begin H.S end
 109 3146 a 109 3146 a
SDict begin 12 H.A end
 109 3146
a 109 3146 a
SDict begin [/View [/XYZ H.V]/Dest (section*.3) cvn /DEST pdfmark end
 109 3146 a FP(Cons\351quence)p 0 TeXcolorgray
109 3299 a FN(Un)21 b(plan)h(peut)g(\352tre)f(d\351termin\351)g(par)h
(l'une)g(des)f(conditions)h(suivantes)f(:)158 3766 y
@beginspecial -1 @llx -1 @lly 143 @urx 58 @ury 1296 @rwi
@setspecial
%%BeginDocument: EspaceFigures.14
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
52.9569 45.51968 moveto
(A) cmmi10 9.96265 fshow
 0 3 dtransform truncate idtransform setlinewidth pop
newpath 56.6929 42.51968 moveto 0 0 rlineto stroke
24.31815 17.17323 moveto
(B) cmmi10 9.96265 fshow
newpath 28.34645 14.17323 moveto 0 0 rlineto stroke
81.1228 31.34645 moveto
(C) cmmi10 9.96265 fshow
newpath 85.03935 28.34645 moveto 0 0 rlineto stroke
showpage
%%EOF

%%EndDocument
 @endspecial 1180 w @beginspecial -1 @llx -1 @lly 143
@urx 58 @ury 1296 @rwi @setspecial
%%BeginDocument: EspaceFigures.15
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 22.67725 28.34645 moveto
113.3858 42.51968 lineto stroke
newpath 28.34645 45.35449 moveto
102.0474 11.33841 lineto stroke
116.3858 39.11578 moveto
(\001) cmr10 9.96265 fshow
105.0474 7.59355 moveto
(\001) cmr10 9.96265 fshow
113.3496 11.20895 moveto
(0) cmsy7 6.97385 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 1180 w @beginspecial -1 @llx -1 @lly 143
@urx 58 @ury 1296 @rwi @setspecial
%%BeginDocument: EspaceFigures.16
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
52.9569 45.51968 moveto
(A) cmmi10 9.96265 fshow
 0 3 dtransform truncate idtransform setlinewidth pop
newpath 56.6929 42.51968 moveto 0 0 rlineto stroke
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 14.17323 moveto
85.03935 28.34645 lineto stroke
80.88824 31.34645 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 270 3866 a(Trois)h(points)g(non)f(align\351s)362
b(Deux)22 b(droites)g(s\351cantes)393 b(Une)21 b(droite)g(et)h(un)f
(point)109 4012 y
SDict begin H.S end
 109 4012 a 109 4012 a
SDict begin 12 H.A end
 109 4012 a 109
4012 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.1.2) cvn /DEST pdfmark
end
 109 4012 a 0.932 0.464 0 TeXcolorrgb 75 x FJ(2.1.2)92
b(P)-5 b(ositions)29 b(relatives)e(de)f(droites)h(et)h(plans)p
0 TeXcolorgray 0.094 0.455 0.804 TeXcolorrgb 109 4240
a
SDict begin H.S end
 109 4240 a 109 4240 a
SDict begin 12 H.A end
 109 4240 a 109 4240 a
SDict begin [/View [/XYZ H.V]/Dest (section*.4) cvn /DEST pdfmark end
 109 4240
a FP(Deux)23 b(droites)p 0 TeXcolorgray 109 4394 a FN(On)e
(consid\350re)h(deux)g(droites)f(de)h(l'espace)o(.)109
4418 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 4418 a 109 4418 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 4418 a 0 TeXcolorgray
0 TeXcolorgray 166 4558 a FN(\226)p 0 TeXcolorgray 42
w(s'il)e(existe)g(un)g(plan)h(contenant)f(ces)g(deux)h(droites)f(on)f
(dit)i(qu'elles)f(sont)f(coplanaires)n(.)j(Elles)d(sont)h(alors)g
(s\351cantes)251 4658 y(ou)h(parall\350les)n(.)p 0 TeXcolorgray
166 4757 a(\226)p 0 TeXcolorgray 42 w(s'il)g(n'existe)g(pas)h(de)f
(plan)h(contenant)g(ces)f(deux)h(droites)f(on)h(dit)g(qu'elles)f(sont)g
(non)g(coplanaires)n(.)p 0 TeXcolorgray 138 4451 3747
4 v 138 4800 4 351 v 3881 4800 V 138 4802 3747 4 v 3883
4835 35 355 v 171 4835 3747 35 v 109 4418 a
tx@Dict begin  PutEnd  end
 109 4418
a 109 4418 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 4418 a 109 4418 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 4418 a 0 TeXcolorgray
163 4528 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p
0 TeXcolorgray 109 4418 a
tx@Dict begin  PutEnd  end
 109 4418 a 1218 x @beginspecial
-1 @llx -1 @lly 143 @urx 58 @ury 1152 @rwi @setspecial
%%BeginDocument: EspaceFigures.15
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 22.67725 28.34645 moveto
113.3858 42.51968 lineto stroke
newpath 28.34645 45.35449 moveto
102.0474 11.33841 lineto stroke
116.3858 39.11578 moveto
(\001) cmr10 9.96265 fshow
105.0474 7.59355 moveto
(\001) cmr10 9.96265 fshow
113.3496 11.20895 moveto
(0) cmsy7 6.97385 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 1358 w @beginspecial -1 @llx -1 @lly 143
@urx 58 @ury 1152 @rwi @setspecial
%%BeginDocument: EspaceFigures.17
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 36.85048 moveto
85.03935 51.0237 lineto stroke
newpath 42.51968 5.6692 moveto
99.21259 19.84242 lineto stroke
88.03935 47.6198 moveto
(\001) cmr10 9.96265 fshow
102.21259 16.09756 moveto
(\001) cmr10 9.96265 fshow
110.51479 19.71297 moveto
(0) cmsy7 6.97385 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 2825 5929 a @beginspecial -1 @llx -47 @lly
143 @urx 100 @ury 1152 @rwi @setspecial
%%BeginDocument: EspaceFigures.18
%!PS
%%BoundingBox: -1 -47 143 100 
%%HiResBoundingBox: -0.99626 -46.26453 142.72852 99.46165 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 14.17323 14.17323 moveto
113.3858 28.34645 lineto stroke
109.2347 31.34645 moveto
(\001) cmr10 9.96265 fshow
59.6929 39.11578 moveto
(A) cmmi10 9.96265 fshow
 0 3 dtransform truncate idtransform setlinewidth pop
newpath 56.6929 42.51968 moveto 0 0 rlineto stroke
 0 0.49814 dtransform truncate idtransform setlinewidth pop
 [3 3 ] 0 setdash
newpath 56.6929 42.51968 moveto
48.1892 0 lineto stroke
 [] 0 setdash
newpath 48.1892 0 moveto
39.68529 -42.51967 lineto stroke
newpath 56.6929 42.51968 moveto
68.03131 99.21259 lineto stroke
42.68529 -46.26453 moveto
(\001) cmr10 9.96265 fshow
50.98749 -42.64912 moveto
(0) cmsy7 6.97385 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 4 4
TeXDict begin 4 3 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.4) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(4)3431 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray 0.094 0.455 0.804
TeXcolorrgb -128 -38 a
SDict begin H.S end
 -128 -38 a -128 -38 a
SDict begin 12 H.A end
 -128 -38
a -128 -38 a
SDict begin [/View [/XYZ H.V]/Dest (section*.5) cvn /DEST pdfmark end
 -128 -38 a FP(Une)23 b(droite)g(et)f(un)g(plan)p
0 TeXcolorgray -128 115 a FN(On)g(consid\350re)g(une)f(droite)h(et)f
(un)h(plan)g(de)f(l'espace)o(.)-128 140 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 140 a
-128 140 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 140 a 0 TeXcolorgray 0 TeXcolorgray -70
295 a FN(\226)p 0 TeXcolorgray 41 w(s'ils)h(n'ont)f(aucun)h(point)g
(commun,)g(la)f(droite)h(est)f(strictement)g(parall\350le)h(au)g(plan.)
p 0 TeXcolorgray -70 395 a(\226)p 0 TeXcolorgray 41 w(s'ils)g(ont)f(un)
h(unique)g(point)g(commun,)f(la)h(droite)f(et)h(le)f(plan)h(sont)f
(s\351cants)n(.)p 0 TeXcolorgray -70 494 a(\226)p 0 TeXcolorgray
41 w(s'ils)h(ont)f(plus)h(d'un)g(point)g(commun,)f(la)h(droite)g(est)f
(inc)o(luse)h(dans)g(le)f(plan.)p 0 TeXcolorgray -98
172 3747 4 v -98 537 4 367 v 3645 537 V -98 539 3747
4 v 3646 572 35 370 v -65 572 3747 35 v -128 140 a
tx@Dict begin  PutEnd  end
 -128
140 a -128 140 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 140 a -128 140 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 140 a 0 TeXcolorgray
-73 249 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(Propri\351t\351)p
0 TeXcolorgray -128 140 a
tx@Dict begin  PutEnd  end
 -128 140 a 1430 x @beginspecial
-1 @llx -1 @lly 143 @urx 86 @ury 1310 @rwi @setspecial
%%BeginDocument: EspaceFigures.30
%!PS
%%BoundingBox: -1 -1 143 86 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 85.28842 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 70.86613 moveto
113.3858 85.03935 lineto stroke
24.19534 73.86613 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 1207 1793 a @beginspecial -1 @llx -46 @lly
143 @urx 100 @ury 1310 @rwi @setspecial
%%BeginDocument: EspaceFigures.32
%!PS
%%BoundingBox: -1 -46 143 100 
%%HiResBoundingBox: -0.99626 -45.92357 142.72852 99.46165 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
59.6929 39.11578 moveto
(A) cmmi10 9.96265 fshow
 0 3 dtransform truncate idtransform setlinewidth pop
newpath 56.6929 42.51968 moveto 0 0 rlineto stroke
 0 0.49814 dtransform truncate idtransform setlinewidth pop
 [3 3 ] 0 setdash
newpath 56.6929 42.51968 moveto
48.1892 0 lineto stroke
 [] 0 setdash
newpath 48.1892 0 moveto
39.68529 -42.51967 lineto stroke
newpath 56.6929 42.51968 moveto
68.03131 99.21259 lineto stroke
42.68529 -45.92357 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 2542 1463 a @beginspecial -1 @llx -1 @lly
143 @urx 58 @ury 1310 @rwi @setspecial
%%BeginDocument: EspaceFigures.31
%!PS
%%BoundingBox: -1 -1 143 58 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 14.17323 moveto
113.3858 28.34645 lineto stroke
24.19534 17.17323 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 0.094 0.455 0.804 TeXcolorrgb -128 1974
a
SDict begin H.S end
 -128 1974 a -128 1974 a
SDict begin 12 H.A end
 -128 1974 a -128 1974 a
SDict begin [/View [/XYZ H.V]/Dest (section*.6) cvn /DEST pdfmark end
 -128
1974 a FP(Deux)i(plans)p 0 TeXcolorgray -128 2127 a FN(On)f
(consid\350re)g(deux)g(plans)g(de)f(l'espace)o(.)-128
2223 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 2223 a -128 2223 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 2223 a 0 TeXcolorgray
0 TeXcolorgray -70 2379 a FN(\226)p 0 TeXcolorgray 41
w(s'ils)h(n'ont)f(aucun)h(point)g(commun,)g(les)f(plans)h(sont)f
(parall\350les)n(.)p 0 TeXcolorgray -70 2478 a(\226)p
0 TeXcolorgray 41 w(s'ils)h(ont)f(au)h(moins)f(un)h(point)g(commun)f
(mais)h(sont)f(distincts)n(,)i(les)e(plans)h(sont)f(s\351cants)g(et)h
(leur)g(intersection)f(est)14 2578 y(une)h(droite)o(.)p
0 TeXcolorgray -70 2677 a(\226)p 0 TeXcolorgray 41 w(s'ils)g(ont)f
(trois)h(points)f(commun)g(non)h(align\351s)n(,)g(les)f(plans)h(sont)f
(confondus)n(.)p 0 TeXcolorgray -98 2256 3747 4 v -98
2720 4 466 v 3645 2720 V -98 2722 3747 4 v 3646 2755
35 470 v -65 2755 3747 35 v -128 2223 a
tx@Dict begin  PutEnd  end
 -128 2223 a -128
2223 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 2223 a -128 2223 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 2223 a 0 TeXcolorgray
-73 2333 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(Propri\351t\351)p
0 TeXcolorgray -128 2223 a
tx@Dict begin  PutEnd  end
 -128 2223 a 0 TeXcolorgray
0 TeXcolorgray 323 3938 a @beginspecial -1 @llx -72 @lly
143 @urx 58 @ury 1310 @rwi @setspecial
%%BeginDocument: EspaceFigures.33
%!PS
%%BoundingBox: -1 -72 143 58 
%%HiResBoundingBox: -0.99626 -71.8624 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 0 -70.86613 moveto
28.34645 -14.17323 lineto stroke
newpath 28.34645 -14.17323 moveto
141.73225 -14.17323 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 -70.86613 moveto
113.3858 -70.86613 lineto stroke
newpath 113.3858 -70.86613 moveto
141.73225 -14.17323 lineto stroke
4.93481 -66.82895 moveto
(\040) cmmi10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 2020 3881 a @beginspecial -1 @llx -29 @lly
143 @urx 86 @ury 1310 @rwi @setspecial
%%BeginDocument: EspaceFigures.13
%!PS
%%BoundingBox: -1 -29 143 86 
%%HiResBoundingBox: -0.99626 -28.59552 142.72852 85.28844 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 56.6929 0 moveto
85.03935 56.6929 lineto stroke
newpath 42.51965 28.34647 moveto
70.86613 -28.34645 lineto stroke
newpath 42.51965 28.34647 moveto
70.8661 85.03937 lineto stroke
newpath 70.8661 85.03937 moveto
85.03935 56.6929 lineto stroke
newpath 85.03935 56.6929 moveto
141.73225 56.6929 lineto stroke
 [3 3 ] 0 setdash
newpath 85.03935 56.6929 moveto
99.21259 28.34645 lineto stroke
newpath 56.6929 56.69292 moveto
85.03935 56.6929 lineto stroke
 [] 0 setdash
newpath 28.34645 56.6929 moveto
56.6929 56.69292 lineto stroke
 [3 3 ] 0 setdash
newpath 85.03937 0 moveto
99.21259 28.34645 lineto stroke
 [] 0 setdash
newpath 70.86613 -28.34645 moveto
85.03937 0 lineto stroke
45.51965 25.8558 moveto
(\040) cmmi10 9.96265 fshow
73.86613 24.94255 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial -128 4187 a
SDict begin H.S end
 -128 4187 a -128 4187 a
SDict begin 12 H.A end
 -128
4187 a -128 4187 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.1.3) cvn /DEST pdfmark
end
 -128 4187 a 0.932 0.464 0 TeXcolorrgb
76 x FJ(2.1.3)93 b(P)-5 b(arall\351lisme)p 0 TeXcolorgray
0.094 0.455 0.804 TeXcolorrgb -128 4416 a
SDict begin H.S end
 -128 4416 a
-128 4416 a
SDict begin 12 H.A end
 -128 4416 a -128 4416 a
SDict begin [/View [/XYZ H.V]/Dest (section*.7) cvn /DEST pdfmark end
 -128 4416 a FP(Une)23
b(droite)g(et)f(un)g(plan)p 0 TeXcolorgray -128 4494
a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4494 a -128 4494 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 4494 a 0 TeXcolorgray
-70 4656 a FN(Si)f(une)h(droite)f FH(\242)h FN(est)f(parall\350le)h
(\340)f(une)h(droite)i FF(d)1453 4626 y Fw(0)1496 4656
y FN(alors)e(la)f(droite)h FH(\242)g FN(est)e(parall\350le)j(\340)e
(tout)g(plan)h(contenant)i FF(d)3395 4626 y Fw(0)3417
4656 y FN(.)p 0 TeXcolorgray -98 4527 3747 4 v -98 4699
4 174 v 3645 4699 V -98 4701 3747 4 v 3646 4734 35 177
v -65 4734 3747 35 v -128 4494 a
tx@Dict begin  PutEnd  end
 -128 4494 a -128 4494
a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4494 a -128 4494 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 4494 a 0 TeXcolorgray
-73 4604 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(Propri\351t\351)p
0 TeXcolorgray -128 4494 a
tx@Dict begin  PutEnd  end
 -128 4494 a 0 TeXcolorgray
0 TeXcolorgray 1162 5656 a @beginspecial -1 @llx -1 @lly
143 @urx 86 @ury 1440 @rwi @setspecial
%%BeginDocument: EspaceFigures.23
%!PS
%%BoundingBox: -1 -1 143 86 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 85.28842 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 14.17323 moveto
113.3858 28.34645 lineto stroke
24.3562 17.17323 moveto
(d) cmmi10 9.96265 fshow
29.5416 20.78864 moveto
(0) cmsy7 6.97385 fshow
newpath 28.34645 70.86613 moveto
113.3858 85.03935 lineto stroke
24.19534 73.86613 moveto
(\001) cmr10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 5 5
TeXDict begin 5 4 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.5) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2726
b FN(5)p 109 -238 3780 2 v 0 TeXcolorgray 0.094 0.455 0.804
TeXcolorrgb 109 -38 a
SDict begin H.S end
 109 -38 a 109 -38 a
SDict begin 12 H.A end
 109 -38 a 109
-38 a
SDict begin [/View [/XYZ H.V]/Dest (section*.8) cvn /DEST pdfmark end
 109 -38 a FP(Deux)23 b(plans)p 0 TeXcolorgray 109
40 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 40 a 109 40 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 40 a 0 TeXcolorgray 166 196
a FN(Si)e(deux)g(droites)g(s\351cantes)e(d'un)j(plan)f
FI(\274)f FN(sont)h(respectivement)f(parall\350les)h(\340)g(deux)g
(droites)f(s\351cantes)g(d'un)h(plan)h FI(\303)p FN(,)166
296 y(alors)g(les)f(plans)h FI(\274)f FN(et)g FI(\303)g
FN(sont)g(parall\350les)n(.)p 0 TeXcolorgray 138 73 3747
4 v 138 340 4 269 v 3881 340 V 138 342 3747 4 v 3883
375 35 273 v 171 375 3747 35 v 109 40 a
tx@Dict begin  PutEnd  end
 109 40 a 109
40 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 40 a 109 40 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 40 a 0 TeXcolorgray 163 150
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(Propri\351t\351)p
0 TeXcolorgray 109 40 a
tx@Dict begin  PutEnd  end
 109 40 a 0 TeXcolorgray 0 TeXcolorgray
1518 1410 a @beginspecial -1 @llx -72 @lly 143 @urx 58
@ury 1152 @rwi @setspecial
%%BeginDocument: EspaceFigures.22
%!PS
%%BoundingBox: -1 -72 143 58 
%%HiResBoundingBox: -0.99626 -71.8624 142.72852 57.68916 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8100000000e00a0000f0280ff
%*Font: cmr10 9.96265 9.96265 01:8
%*Font: cmsy7 6.97385 6.97385 30:8
%*Font: cmr7 6.97385 6.97385 31:8
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 56.6929 lineto stroke
newpath 28.34645 56.6929 moveto
141.73225 56.6929 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 56.6929 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 22.67725 28.34645 moveto
113.3858 42.51968 lineto stroke
newpath 28.34645 45.35449 moveto
102.0474 11.33841 lineto stroke
116.3858 39.11578 moveto
(\001) cmr10 9.96265 fshow
105.0474 7.59355 moveto
(\001) cmr10 9.96265 fshow
113.3496 11.20895 moveto
(0) cmsy7 6.97385 fshow
newpath 0 -70.86613 moveto
28.34645 -14.17323 lineto stroke
newpath 28.34645 -14.17323 moveto
141.73225 -14.17323 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 -70.86613 moveto
113.3858 -70.86613 lineto stroke
newpath 113.3858 -70.86613 moveto
141.73225 -14.17323 lineto stroke
4.93481 -66.82895 moveto
(\040) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 22.67725 -42.51968 moveto
113.3858 -28.34645 lineto stroke
newpath 28.34645 -25.51163 moveto
102.0474 -59.52773 lineto stroke
116.3858 -31.00314 moveto
(\001) cmr10 9.96265 fshow
124.688 -32.49754 moveto
(1) cmr7 6.97385 fshow
105.0474 -62.03618 moveto
(\001) cmr10 9.96265 fshow
113.3496 -58.42078 moveto
(0) cmsy7 6.97385 fshow
113.3496 -64.50897 moveto
(1) cmr7 6.97385 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 109 1653 a
SDict begin H.S end
 109 1653 a 109 1653 a
SDict begin 12 H.A end
 109 1653
a 109 1653 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.1.4) cvn /DEST pdfmark
end
 109 1653 a 0.932 0.464 0 TeXcolorrgb 116
x FJ(2.1.4)92 b(A)27 b(retenir)p 0 TeXcolorgray 109 1922
a Fu(\020)98 b FN(Deux)22 b(droites)f(de)g(l'espace)g(sont)g(soit)h
(coplanaires)n(,)g(soit)f(non)h(coplanaires)n(.)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 861 2154 a FP(Coplanaires)h(\(dans)f(un)g
(m\352me)i(plan\))p 0 TeXcolorgray 2959 2184 4 100 v
904 w(Non)f(coplanaires)p 109 2187 3804 4 v 299 2257
a FH(\242)e FN(et)h FH(\242)523 2227 y Fw(0)565 2257
y FN(s\351cantes)831 b FH(\242)22 b FN(et)f FH(\242)1924
2227 y Fw(0)1967 2257 y FN(parall\350les)p 2959 2287
4 100 v 158 2978 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 102.4299 a add def
/d 0.0 a add neg def /h 83.22412 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 158 2978 a 265 2499 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.67911 -42.67911 64.01866
-32.00932 64.01866 10.66977 21.33955 10.66977 0.0 0.0 42.67911 0.0
42.67911 -42.67911 0.0 -42.67911 0.0 0.0    /Lineto /lineto load def
1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 42.67911
0.0    /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 74.68843 10.66977 0.0 10.66977    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 265 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 265
2499 a 265 2499 a
tx@Dict begin { 0.0 8.53569 } PutCoor PutBegin  end
 265 2499 a 237 2458 a FH(\242)265 2499
y
tx@Dict begin  PutEnd  end
 265 2499 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -0.5 def /x1 4 def /dx x1 x sub
199 div def /F@pstplot (x/6)  tx@AlgToPs begin AlgToPs end cvx def
/xy { x 21.33955 mul F@pstplot 21.33955 mul } def  /ps@Exit false def
xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 21.33955 mul gt
{ moveto }{ dup -1.e30 21.33955 mul lt { moveto }{ L } ifelse } ifelse
 } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy  dup 1.e30
21.33955 mul gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto }{
L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 265
2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 265 2499 a 265 2499 a
tx@Dict begin { -2.13408 -4.26784 } PutCoor PutBegin  end
 265 2499 a 226 2458 a FH(\242)282
2428 y Fw(0)265 2499 y
tx@Dict begin  PutEnd  end
 265 2499 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /Symbol 0. [1.8 0.0 0.0 1.8 -0.495 -0.4788] FontDot /Dot
{ moveto gsave 1.  1.  scale <B4> show grestore } bind def  64.01866
10.66977 Dot end


@endspecial 265 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 265 2499 a 265 2499 a
tx@Dict begin { 64.01866 10.66977 } PutCoor PutBegin  end
 265 2499
a 239 2458 a FF(A)265 2499 y
tx@Dict begin  PutEnd  end
 265 2499 a 1009 2978 a
currentpoint initclip moveto
 1009
2978 a 1108 2978 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 102.4299 a add def
/d 0.0 a add neg def /h 83.22412 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1108 2978 a 1215 2499 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.67911 -42.67911 64.01866
-32.00932 64.01866 10.66977 21.33955 10.66977 0.0 0.0 42.67911 0.0
42.67911 -42.67911 0.0 -42.67911 0.0 0.0    /Lineto /lineto load def
1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 42.67911
0.0    /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 78.95628 10.66977 0.0 10.66977    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1215 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 1215
2499 a 1215 2499 a
tx@Dict begin { 0.0 8.53569 } PutCoor PutBegin  end
 1215 2499 a 1187 2458 a FH(\242)1215
2499 y
tx@Dict begin  PutEnd  end
 1215 2499 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 68.2865 0.0 -10.66977 0.0    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1215 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 1215 2499 a 1215 2499 a
tx@Dict begin { -6.40192 -2.13408 } PutCoor PutBegin  end
 1215 2499 a 1176
2458 a FH(\242)1232 2428 y Fw(0)1215 2499 y
tx@Dict begin  PutEnd  end
 1215 2499
a 1959 2978 a
currentpoint initclip moveto
 1959 2978 a 2059 2978 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 102.4299 a add def
/d 0.0 a add neg def /h 83.22412 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2059 2978 a 2165
2499 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.67911 -42.67911 64.01866
-32.00932 64.01866 10.66977 21.33955 10.66977 0.0 0.0 42.67911 0.0
42.67911 -42.67911 0.0 -42.67911 0.0 0.0    /Lineto /lineto load def
1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 42.67911
0.0    /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 68.2865 0.1068 -10.66977 0.1068   
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2165 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 2165 2499 a 2165 2499 a
tx@Dict begin { -6.40192 -2.13408 } PutCoor PutBegin  end
 2165 2499 a 2137
2458 a FH(\242)2165 2499 y
tx@Dict begin  PutEnd  end
 2165 2499 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 68.2865 -0.1068 -10.66977 -0.1068 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2165 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 2165 2499 a 2165
2499 a
tx@Dict begin { 64.01866 2.13408 } PutCoor PutBegin  end
 2165 2499 a 2126 2604 a FH(\242)2182 2574 y Fw(0)2165
2499 y
tx@Dict begin  PutEnd  end
 2165 2499 a 2909 2978 a
currentpoint initclip moveto
 2909 2978 a 2959 3008
4 721 v 3012 2978 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 102.4299 a add def
/d 0.0 a add neg def /h 83.22412 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 3012 2978 a 3118 2499 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.67911 -42.67911 64.01866
-32.00932 64.01866 10.66977 21.33955 10.66977 0.0 0.0 42.67911 0.0
42.67911 -42.67911 0.0 -42.67911 0.0 0.0    /Lineto /lineto load def
1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 42.67911
0.0    /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 68.2865 0.0 -10.66977 0.0    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 3118 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 3118
2499 a 3118 2499 a
tx@Dict begin { -6.40192 -2.13408 } PutCoor PutBegin  end
 3118 2499 a 3090 2458 a FH(\242)3118
2499 y
tx@Dict begin  PutEnd  end
 3118 2499 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -0.5 def /x1 4 def /dx x1 x sub
199 div def /F@pstplot (0.5*x-3)  tx@AlgToPs begin AlgToPs end cvx
def /xy { x 21.33955 mul F@pstplot 21.33955 mul } def  /ps@Exit false
def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 21.33955 mul
gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto }{ L } ifelse }
ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy  dup
1.e30 21.33955 mul gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto
}{ L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
3118 2499 a
tx@Dict begin  gsave STV CP T /ps@refangle -45  def grestore  end
 3118 2499 a 3118 2499 a
tx@Dict begin { 44.81319 -42.67911 } PutCoor PutBegin  end
 3118 2499 a 3011
2592 a FH(\242)3067 2562 y Fw(0)3118 2499 y
tx@Dict begin  PutEnd  end
 3118 2499
a 3862 2978 a
currentpoint initclip moveto
 3862 2978 a 158 3077 a FH(\242)h FN(et)f
FH(\242)382 3047 y Fw(0)425 3077 y FN(ont)g(un)h(point)158
3177 y(d'intersection)28 b FF(A)s FN(.)1108 3077 y FH(\242)22
b FN(et)f FH(\242)1332 3047 y Fw(0)1375 3077 y FN(sont)1108
3177 y(strictement)1108 3277 y(parall\350les)n(.)2059
3077 y FH(\242)g FN(et)g FH(\242)2282 3047 y Fw(0)2325
3077 y FN(sont)2059 3177 y(confondues)n(.)p 2959 3109
4 102 v 3012 3077 a(Aucun)h(plan)g(ne)3012 3177 y(contient)g(\340)f(la)
h(fois)e FH(\242)3012 3277 y FN(et)h FH(\242)3158 3246
y Fw(0)3179 3277 y FN(.)p 2959 3208 4 100 v 2959 3308
V 380 3378 a FH(\242)10 b FC(\\)g FH(\242)567 3348 y
Fw(0)603 3378 y FC(\306)15 b FB({)6 b FF(A)s FB(})573
b FH(\242)10 b FC(\\)g FH(\242)1546 3348 y Fw(0)1582
3378 y FC(\306)k(;)521 b FH(\242)10 b FC(\\)g FH(\242)2416
3348 y Fw(0)2452 3378 y FC(\306)k FH(\242)h FC(\306)f
FH(\242)2717 3348 y Fw(0)p 2959 3408 V 3262 3378 a FH(\242)c
FC(\\)g FH(\242)3449 3348 y Fw(0)3486 3378 y FC(\306)k(;)109
3527 y Fu(\020)98 b FN(Une)21 b(droite)h(et)f(un)h(plan)g(de)f
(l'espace)g(sont)g(soit)g(s\351cants)n(,)h(soit)f(parall\350les)n(.)p
0 TeXcolorgray 0 TeXcolorgray 661 3675 a FP(S\351cants)p
1407 3705 V 1420 w(P)l(arall\350les)p 226 3708 3545 4
v 1407 3808 4 100 v 1407 3907 V 276 4373 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 130.17139 a add def
/d 0.0 a add neg def /h 74.68843 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 276 4373 a
382 4249 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 42.67911 21.33955 106.69777
21.33955 64.01866 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.7348 0.8695 1  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 42.67911 32.00932 53.34888
37.34421 74.68843 37.34421 74.68843 16.00465 64.01866 10.66977 42.67911
10.66977   /Lineto /lineto load def 1  setlinejoin false NArray n 2
eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 53.34888 37.34421 53.34888
16.00465 42.67911 10.66977    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 16.00465 53.34888
16.00465    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 74.68843
16.00465 74.68843 37.34421 53.34888 37.34421 42.67911 32.00932 64.01866
32.00932 64.01866 10.66977 42.67911 10.66977 42.67911 32.00932    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 37.34421 64.01866
32.00932    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x 2.5 def /x1 3.866 def /dx x1 x sub
199 div def /F@pstplot (-x+4.25)  tx@AlgToPs begin AlgToPs end cvx
def /xy { x 21.33955 mul F@pstplot 21.33955 mul } def  /ps@Exit false
def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 21.33955 mul
gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto }{ L } ifelse }
ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy  dup
1.e30 21.33955 mul gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto
}{ L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  3.0 0 0 add  DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x 1.5 def /x1 2.5 def /dx x1 x sub
199 div def /F@pstplot (-x+4.25)  tx@AlgToPs begin AlgToPs end cvx
def /xy { x 21.33955 mul F@pstplot 21.33955 mul } def  /ps@Exit false
def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 21.33955 mul
gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto }{ L } ifelse }
ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy  dup
1.e30 21.33955 mul gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto
}{ L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x 3.866 def /x1 4.75 def /dx x1 x
sub 199 div def /F@pstplot (-x+4.25)  tx@AlgToPs begin AlgToPs end
cvx def /xy { x 21.33955 mul F@pstplot 21.33955 mul } def  /ps@Exit
false def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 21.33955
mul gt { moveto }{ dup -1.e30 21.33955 mul lt { moveto }{ L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 21.33955 mul gt { moveto }{ dup -1.e30 21.33955 mul lt {
moveto }{ L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /Symbol 0. [1.8 0.0 0.0 1.8 -0.495 -0.4788] FontDot /Dot
{ moveto gsave 1.  1.  scale <B4> show grestore } bind def  74.68843
16.00465 Dot end
 
@endspecial 382 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 0  def grestore  end
 382
4249 a 382 4249 a
tx@Dict begin { 74.68843 16.00465 } PutCoor PutBegin  end
 382 4249 a 430 4277 a FF(A)382 4249
y
tx@Dict begin  PutEnd  end
 382 4249 a 382 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 382 4249 a 382 4249 a
tx@Dict begin { 98.16206 -8.53569 } PutCoor PutBegin  end
 382 4249
a 354 4207 a FH(\242)382 4249 y
tx@Dict begin  PutEnd  end
 382 4249 a 382 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end

382 4249 a 382 4249 a
tx@Dict begin { 98.16206 21.33955 } PutCoor PutBegin  end
 382 4249 a 358 4207 a FI(\274)382
4249 y
tx@Dict begin  PutEnd  end
 382 4249 a 1357 4373 a
currentpoint initclip moveto
 1357 4373 a 1407 4403 4
650 v 1460 4373 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 130.17139 a add def
/d 0.0 a add neg def /h 74.68843 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1460 4373 a 1566 4249 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 42.67911 21.33955 106.69777
21.33955 64.01866 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.7348 0.8695 1  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 42.67911 32.00932 53.34888
37.34421 74.68843 37.34421 74.68843 16.00465 64.01866 10.66977 42.67911
10.66977   /Lineto /lineto load def 1  setlinejoin false NArray n 2
eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 53.34888 37.34421 53.34888
16.00465 42.67911 10.66977    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 16.00465 53.34888
16.00465    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 74.68843
16.00465 74.68843 37.34421 53.34888 37.34421 42.67911 32.00932 64.01866
32.00932 64.01866 10.66977 42.67911 10.66977 42.67911 32.00932    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 37.34421 64.01866
32.00932    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 96.02798 37.34421 0.0 37.34421    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1566 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 180  def grestore  end
 1566 4249 a 1566
4249 a
tx@Dict begin { 0.0 37.34421 } PutCoor PutBegin  end
 1566 4249 a 1468 4276 a FH(\242)1566 4249 y
tx@Dict begin  PutEnd  end
 1566
4249 a 1566 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 1566 4249 a 1566 4249 a
tx@Dict begin { 98.16206 21.33955 } PutCoor PutBegin  end
 1566 4249
a 1542 4207 a FI(\274)1566 4249 y
tx@Dict begin  PutEnd  end
 1566 4249 a 2540 4373
a
currentpoint initclip moveto
 2540 4373 a 2640 4373 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 130.17139 a add def
/d 0.0 a add neg def /h 74.68843 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2640 4373 a 2746 4249 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 42.67911 21.33955 106.69777
21.33955 64.01866 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.7348 0.8695 1  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 42.67911 32.00932 53.34888
37.34421 74.68843 37.34421 74.68843 16.00465 64.01866 10.66977 42.67911
10.66977   /Lineto /lineto load def 1  setlinejoin false NArray n 2
eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 53.34888 37.34421 53.34888
16.00465 42.67911 10.66977    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 16.00465 53.34888
16.00465    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.01866 10.66977 74.68843
16.00465 74.68843 37.34421 53.34888 37.34421 42.67911 32.00932 64.01866
32.00932 64.01866 10.66977 42.67911 10.66977 42.67911 32.00932    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 74.68843 37.34421 64.01866
32.00932    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 96.02798 10.66977 0.0 10.66977    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 2746 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 180  def grestore  end
 2746 4249 a 2746
4249 a
tx@Dict begin { 0.0 10.66977 } PutCoor PutBegin  end
 2746 4249 a 2649 4276 a FH(\242)2746 4249 y
tx@Dict begin  PutEnd  end
 2746
4249 a 2746 4249 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 2746 4249 a 2746 4249 a
tx@Dict begin { 98.16206 21.33955 } PutCoor PutBegin  end
 2746 4249
a 2722 4207 a FI(\274)2746 4249 y
tx@Dict begin  PutEnd  end
 2746 4249 a 3721 4373
a
currentpoint initclip moveto
 3721 4373 a 276 4473 a FH(\242)f FN(et)g FI(\274)f
FN(ont)h(un)g(point)h(d'inter)m(-)276 4572 y(section)27
b FF(A)s FN(.)p 1407 4602 4 200 v 1460 4473 a FH(\242)19
b FN(et)g FI(\274)f FN(sont)h(strictement)g(pa-)1460
4572 y(rall\350les)n(.)2640 4522 y FH(\242)j FN(est)f(contenue)g(dans)g
FI(\274)627 4672 y FH(\242)10 b FC(\\)g FI(\274)15 b
FC(\306)f FB({)6 b FF(A)s FB(})p 1407 4702 4 100 v 836
w FH(\242)k FC(\\)g FI(\274)k FC(\306)g(;)861 b FH(\242)10
b FC(\\)g FI(\274)k FC(\306)g FH(\242)109 4859 y Fu(\020)98
b FN(Deux)22 b(plans)g(de)f(l'espace)g(sont)g(soit)g(s\351cants)n(,)h
(soit)f(parall\350les)n(.)p 0 TeXcolorgray 0 TeXcolorgray
586 5007 a FP(S\351cants)p 1317 5037 V 1481 w(P)l(arall\350les)p
165 5040 3667 4 v 1317 5140 4 100 v 1317 5240 V 215 5643
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 126.75615 a add def
/d 0.0 a add neg def /h 67.2191 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 215 5643 a 311 5532 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 38.41092 19.20546 96.0273
19.20546 57.61638 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.5  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 57.61638 76.82184 0.0 76.82184
38.41092 19.20546 96.0273 19.20546   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 67.2191 33.60954 76.82184
19.20546 67.2191 14.40408 48.01364 14.40408 48.01364 33.60954   /Lineto
/lineto load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def
} if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2
mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1
y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n
n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12
x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11 sub
Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add
def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add y11
Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 67.2191 33.60954 48.01364 33.60954
48.01364 14.40408 67.2191 14.40408 67.2191 33.60954 76.82184 19.20546
67.2191 14.40408    /Lineto /lineto load def 1  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 67.2191 33.60954 76.82184 38.41092
76.82184 19.20546 57.61638 19.20546 48.01364 33.60954 57.61638 38.41092
57.61638 19.20546 48.01364 14.40408    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  3.0 0 0 add  DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 76.82184 38.41092 57.61638 38.41092
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 57.61638 19.20546 48.01364 19.20546
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 38.41092 19.20546 19.20546 19.20546
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 311 5532 a
tx@Dict begin  gsave STV CP T /ps@refangle 180  def grestore  end
 311
5532 a 311 5532 a
tx@Dict begin { 19.20546 19.20546 } PutCoor PutBegin  end
 311 5532 a 213 5559 a FH(\242)311 5532
y
tx@Dict begin  PutEnd  end
 311 5532 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 105.63002 19.20546 96.0273 19.20546
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 311
5532 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 311 5532 a 311 5532 a
tx@Dict begin { 0.0 0.0 } PutCoor PutBegin  end
 311 5532 a 287 5489 a FI(\274)311
5532 y
tx@Dict begin  PutEnd  end
 311 5532 a 311 5532 a
tx@Dict begin  gsave STV CP T /ps@refangle -45  def grestore  end
 311 5532 a 311 5532 a
tx@Dict begin { 19.20546 48.01364 } PutCoor PutBegin  end
 311
5532 a 211 5624 a FI(\274)260 5594 y Fw(0)311 5532 y
tx@Dict begin  PutEnd  end

311 5532 a 1267 5643 a
currentpoint initclip moveto
 1267 5643 a 1317 5673 4 588 v
1370 5643 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 126.75615 a add def
/d 0.0 a add neg def /h 67.2191 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1370 5643 a 1466 5532 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 38.41092 19.20546 96.0273
19.20546 57.61638 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.5  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 38.41092 48.01364 96.0273
48.01364 57.61638 28.80818 0.0 28.80818   /Lineto /lineto load def
1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n {
pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED
/x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2
div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.75  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 38.41092 38.41092 57.61638
38.41092 48.01364 33.60954 28.80818 33.60954   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 1  setgray  1. .setopacityalpha
 fill  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 28.80818 24.00682 57.61638
24.00682 57.61638 9.60272 48.01364 4.80136 28.80818 4.80136   /Lineto
/lineto load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def
} if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2
mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1
y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n
n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12
x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11 sub
Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add
def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add y11
Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 28.80818 4.80136 38.41092 9.60272 38.41092
38.41092    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine
 grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 57.61638 9.60272 38.41092 9.60272 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 28.80818 28.80818 28.80818 33.60954
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 48.01364 28.80818 48.01364 33.60954
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 57.61638 28.80818 57.61638 38.41092
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 48.01364 28.80818 48.01364 4.80136
28.80818 4.80136 28.80818 28.80818    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 57.61638 28.80818 57.61638 9.60272
48.01364 4.80136    /Lineto /lineto load def 1  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 28.80818 33.60954 38.41092 38.41092
57.61638 38.41092 48.01364 33.60954 28.80818 33.60954    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1466 5532 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 1466 5532 a 1466
5532 a
tx@Dict begin { 0.0 0.0 } PutCoor PutBegin  end
 1466 5532 a 1442 5489 a FI(\274)1466 5532 y
tx@Dict begin  PutEnd  end
 1466
5532 a 1466 5532 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 1466 5532 a 1466 5532 a
tx@Dict begin { 0.0 28.80818 } PutCoor PutBegin  end
 1466 5532
a 1431 5489 a FI(\274)1480 5459 y Fw(0)1466 5532 y
tx@Dict begin  PutEnd  end
 1466
5532 a 2423 5643 a
currentpoint initclip moveto
 2423 5643 a 2522 5643 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 151.72299 a add def
/d 0.0 a add neg def /h 67.2191 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2522 5643
a 2745 5532 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 38.41092 24.00682 120.03412
24.00682 62.41774 -4.80136 -19.20546 -4.80136   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.5  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 38.41092 19.20546 96.0273
19.20546 57.61638 0.0 0.0 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.75  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  [ 38.41092 28.80818 48.01364
33.60954 67.2191 33.60954 67.2191 14.40408 57.61638 9.60272 38.41092
9.60272   /Lineto /lineto load def 1  setlinejoin false NArray n 2
eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 1  setgray
 1. .setopacityalpha  fill  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 48.01364 33.60954 48.01364
14.40408 38.41092 9.60272    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 67.2191 14.40408 48.01364 14.40408
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0.5  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 57.61638 9.60272 67.2191 14.40408
67.2191 33.60954 48.01364 33.60954 38.41092 28.80818 57.61638 28.80818
57.61638 9.60272 38.41092 9.60272 38.41092 28.80818    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0.5  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 67.2191 33.60954 57.61638 28.80818
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0.5  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
2745 5532 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 2745 5532 a 2745 5532 a
tx@Dict begin { 115.23276 24.00682 } PutCoor PutBegin  end
 2745 5532 a 2721
5489 a FI(\274)2745 5532 y
tx@Dict begin  PutEnd  end
 2745 5532 a 2745 5532 a
tx@Dict begin { 76.82184 14.40408 } PutCoor PutBegin  end
 2745
5532 a 2710 5563 a FI(\274)2759 5533 y Fw(0)2745 5532
y
tx@Dict begin  PutEnd  end
 2745 5532 a 3782 5643 a
currentpoint initclip moveto
 3782 5643 a 215 5743 a FI(\274)i
FN(et)g FI(\274)428 5713 y Fw(0)473 5743 y FN(ont)g(une)h(droite)g
(d'in-)215 5842 y(tersection)d FH(\242)p FN(.)p 1317
5872 4 200 v 1370 5743 a FI(\274)49 b FN(et)f FI(\274)1634
5713 y Fw(0)1703 5743 y FN(sont)g(strictement)1370 5842
y(parall\350les)n(.)2522 5792 y FI(\274)21 b FN(et)h
FI(\274)2732 5763 y Fw(0)2774 5792 y FN(sont)f(confondus)574
5942 y FI(\274)10 b FC(\\)g FI(\274)747 5912 y Fw(0)783
5942 y FC(\306)k FH(\242)p 1317 5972 4 100 v 821 w FI(\274)c
FC(\\)g FI(\274)1902 5912 y Fw(0)1937 5942 y FC(\306)15
b(;)848 b FI(\274)10 b FC(\\)g FI(\274)3085 5912 y Fw(0)3121
5942 y FC(\306)k FI(\274)g FC(\306)g FI(\274)3371 5912
y Fw(0)p 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 6 6
TeXDict begin 6 5 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.6) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(6)3431 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 -121 a -128 -121 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 -121 a 0 TeXcolorgray
0 TeXcolorgray -70 34 a FN(\226)p 0 TeXcolorgray 41 w(Contrairement)17
b(au)f(plan,)i(deux)f(droites)g(de)f(l'espace)h(n'a)o(yant)g(pas)g(de)f
(point)h(en)g(commun)f(ne)g(sont)g(pas)h(forc\351ment)14
134 y(parall\350les)n(.)p 0 TeXcolorgray -70 234 a(\226)p
0 TeXcolorgray 41 w(Des)22 b(droites)g(strictement)g(parall\350les)h
(sont)f(des)g(droites)g FP(coplanaires)i(et)f(qui)f(n'ont)h(aucun)f
(point)i(en)f(com-)14 333 y(mun)p FN(.)p 0 TeXcolorgray
-70 433 a(\226)p 0 TeXcolorgray 41 w(On)f(peut)g(d\351\002nir)g(un)g
(plan)g(de)g(plusieurs)g(mani\350res)e(:)p 0 TeXcolorgray
19 532 a FC(\262)p 0 TeXcolorgray 42 w FN(par)i(la)g(donn\351e)f(de)g
(trois)g(points)13 b(;)p 0 TeXcolorgray 19 632 a FC(\262)p
0 TeXcolorgray 42 w FN(par)22 b(la)g(donn\351)f(de)g(deux)h(droites)g
(s\351cantes)12 b(;)p 0 TeXcolorgray 19 732 a FC(\262)p
0 TeXcolorgray 42 w FN(par)22 b(la)g(donn\351e)f(de)g(deux)h(droites)f
(strictement)h(parall\350les)13 b(;)p 0 TeXcolorgray
19 831 a FC(\262)p 0 TeXcolorgray 42 w FN(par)22 b(la)g(donn\351e)f
(d'une)g(droite)h(et)f(d'un)h(point)g(n'appartenant)g(par)g(\340)f
(cette)g(droite)o(.)p 0 TeXcolorgray -98 -88 3747 4 v
-98 874 4 965 v 3645 874 V -98 876 3747 4 v 3646 909
35 968 v -65 909 3747 35 v -128 -121 a
tx@Dict begin  PutEnd  end
 -128 -121 a -128
-121 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 -121 a -128 -121 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 -121 a 0 TeXcolorgray
-73 -11 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(Propri\351t\351)p
0 TeXcolorgray -128 -121 a
tx@Dict begin  PutEnd  end
 -128 -121 a 1236 x FN(Une)h(droite)f
FH(\242)h FN(et)f(un)h(plan)g FI(\274)f FN(sont)g(parall\350les)h
(s'ils)f(ne)h(sont)f(pas)g(s\351cants)n(.)h(On)f(note)g(alors)h
FH(\242)10 b Fu(\014)g FI(\274)22 b FN(ou)f FI(\274)10
b Fu(\014)g FH(\242)p FN(.)-128 1214 y(Deux)22 b(plans)g
FI(\274)f FN(et)g FI(\274)506 1184 y Fw(0)549 1214 y
FN(sont)g(parall\350les)h(lorsqu'ils)f(ne)h(sont)f(pas)g(s\351cants)n
(.)h(On)f(note)g FI(\274)10 b Fu(\014)g FI(\274)2646
1184 y Fw(0)2668 1214 y FN(.)-128 1293 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 1293 a
-128 1293 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 1293 a 0 TeXcolorgray 0 TeXcolorgray
-70 1433 a FN(\226)p 0 TeXcolorgray 41 w(P)m(our)23 b(d\351montrer)e
(que)h(trois)g(points)g(sont)f(align\351s)n(,)i(il)g(suf\002t)f(de)g
(montrer)f(que)h(les)f(trois)h(points)g(appartiennent)h(\340)14
1533 y(deux)i(plans)f(s\351cants)f(:)h(comme)e(l'intersection)i(de)g
(deux)g(plans)g(s\351cants)f(est)g(une)h(droite)o(,)g(cela)g(implique)g
(que)f(les)14 1632 y(points)f(sont)f(tous)g(les)g(trois)h(sur)f(cette)g
(droite)o(.)p 0 TeXcolorgray -70 1732 a(\226)p 0 TeXcolorgray
41 w(P)m(our)28 b(trouver)g(la)g(droite)f(d'intersection)h(de)f(deux)h
(plans)n(,)g(il)g(suf\002t)f(de)g(trouver)h(deux)g(points)f(distincts)h
(qui)g(ap-)14 1831 y(partiennent)23 b(aux)g(deux)g(plans)f(:)h(la)g
(droite)f(d'intersection)g(est)g(alors)g(celle)g(qui)h(passe)f(par)g
(ces)g(deux)h(points)n(.)g(Ces)14 1931 y(points)c(sont)f(en)g
(g\351n\351ral)h(des)f(points)g(d'intersection)h(de)f(droites)g
(s\351cantes)n(,)g(l'une)h(contenue)f(dans)g(l'un)h(des)f(plans)n(,)14
2031 y(l'autre)k(dans)g(l'autre)f(plan.)p 0 TeXcolorgray
-98 1326 3747 4 v -98 2073 4 750 v 3645 2073 V -98 2075
3747 4 v 3646 2108 35 753 v -65 2108 3747 35 v -128 1293
a
tx@Dict begin  PutEnd  end
 -128 1293 a -128 1293 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 1293 a -128 1293 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128
1293 a 0 TeXcolorgray -73 1403 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
45.01675 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(M\351thode)p 0 TeXcolorgray -128 1293
a
tx@Dict begin  PutEnd  end
 -128 1293 a -128 2340 a
SDict begin H.S end
 -128 2340 a -128 2340 a
SDict begin 12 H.A end
 -128
2340 a -128 2340 a
SDict begin [/View [/XYZ H.V]/Dest (section.2.2) cvn /DEST pdfmark
end
 -128 2340 a 0.93 0.26 0 TeXcolorrgb
149 x FK(2.2)111 b(V)-8 b(ecteur)32 b(de)g(l'espace)p
0 TeXcolorgray -128 2671 a FN(Les)22 b(d\351\002nitions)g(et)f
(op\351rations)g(sur)h(les)f(vecteurs)g(du)h(plan)g(se)f
(g\351n\351ralisent)h(dans)g(l'espace)-128 2695 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128
2695 a -128 2695 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 2695 a 0 TeXcolorgray 0 TeXcolorgray
-70 2863 a FN(\226)p 0 TeXcolorgray 41 w(P)m(our)h(tout)e(point)h
FF(O)i FN(de)d(l'espace)g(et)g(tout)h(vecteur)1606 2826
y FC(\241)-57 b(!)1615 2863 y FF(u)18 b FN(,)k(il)g(existe)f(un)h
(unique)g(point)28 b FF(A)d FN(tel)c(que)1671 2937 y
FC(\241)-26 b(\241)g(!)1671 2993 y FF(O)8 b(A)26 b FC(\306)1889
2956 y(\241)-58 b(!)1898 2993 y FF(u)p 0 TeXcolorgray
-70 3111 a FN(\226)p 0 TeXcolorgray 41 w(P)m(our)23 b(tous)e(points)27
b FF(A)s FN(,)d FF(B)r FN(,)e FF(C)i FN(et)f FF(D)j FN(de)21
b(l'espace)o(,)1010 3185 y FC(\241)-29 b(\241)h(!)1016
3241 y FF(A)t(B)23 b FC(\306)1223 3185 y(\241)-27 b(\241)h(!)1224
3241 y FF(C)5 b(D)25 b FC(\()-12 b(\))15 b FN(ABCD)21
b(est)g(un)g(parall\351logramme)p 0 TeXcolorgray -70
3371 a(\226)p 0 TeXcolorgray 41 w(P)m(our)i(tous)e(points)27
b FF(A)s FN(,)d FF(B)e FN(et)h FF(C)h FN(de)d(l'espace)o(,)1397
3315 y FC(\241)-28 b(\241)f(!)1403 3371 y FF(A)t(B)20
b FC(\305)1602 3315 y(\241)-30 b(\241)f(!)1603 3371 y
FF(B)s(C)24 b FC(\306)1811 3315 y(\241)-27 b(\241)f(!)1817
3371 y FF(A)t(C)33 b FN(\(relation)21 b(de)h(Chasles\))p
0 TeXcolorgray -70 3471 a(\226)p 0 TeXcolorgray 41 w(La)29
b(d\351\002nition)g(du)g(produit)g(d'un)g(vecteur)g(par)g(un)g(r\351el)
f(ainsi)g(que)g(les)g(r\350gles)h(de)f(calcul)i(sont)e(les)g(m\352mes)e
(que)14 3571 y(celles)c(du)g(plan.)p 0 TeXcolorgray -98
2728 3747 4 v -98 3613 4 887 v 3645 3613 V -98 3615 3747
4 v 3646 3648 35 891 v -65 3648 3747 35 v -128 2695 a
tx@Dict begin  PutEnd  end

-128 2695 a -128 2695 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 2695 a -128 2695 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128
2695 a 0 TeXcolorgray -73 2805 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(Propri\351t\351)p 0 TeXcolorgray -128
2695 a
tx@Dict begin  PutEnd  end
 -128 2695 a -128 3871 a
SDict begin H.S end
 -128 3871 a -128 3871
a
SDict begin 12 H.A end
 -128 3871 a -128 3871 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.2.1) cvn /DEST pdfmark
end
 -128 3871 a 0.932 0.464 0 TeXcolorrgb
116 x FJ(2.2.1)93 b(V)-7 b(ecteurs)28 b(colin\351aires)p
0 TeXcolorgray -128 4050 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4050 a -128 4050 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128
4050 a 0 TeXcolorgray -70 4193 a FN(Dire)21 b(que)g(deux)g(vecteurs)g
(non)g(nuls)16 b FH(~)-43 b FF(u)23 b FN(et)12 b FH(~)-40
b FF(v)22 b FN(sont)e(colin\351aires)h(signi\002e)o(,)h(qu'ils)f(ont)f
(la)h(m\352me)e(direction,)k(c'est-\340-dire)-70 4292
y(qu'il)f(existe)f(un)h(r\351el)f FI(\270)h FN(tel)g(que)16
b FH(~)-43 b FF(u)16 b FC(\306)e FI(\270)c FC(\242)r
FH(~)-40 b FF(v)r FN(.)p 0 TeXcolorgray -98 4083 3747
4 v -98 4335 4 255 v 3645 4335 V -98 4337 3747 4 v 3646
4370 35 258 v -65 4370 3747 35 v -128 4050 a
tx@Dict begin  PutEnd  end
 -128 4050
a -128 4050 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4050 a -128 4050 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 4050 a 0 TeXcolorgray
-73 4160 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p
0 TeXcolorgray -128 4050 a
tx@Dict begin  PutEnd  end
 -128 4050 a 526 x FN(P)m(ar)23
b(convention,)f(le)g(vecteur)f(nul)949 4559 y FH(~)961
4576 y FN(0)g(est)g(colin\351aire)h(\340)f(tout)g(vecteur)-8
b(.)p 0.094 0.455 0.804 TeXcolorrgb -128 4792 a
SDict begin H.S end
 -128
4792 a -128 4792 a
SDict begin 12 H.A end
 -128 4792 a -128 4792 a
SDict begin [/View [/XYZ H.V]/Dest (section*.9) cvn /DEST pdfmark end
 -128 4792
a FP(Interpr\351tation)24 b(g\351om\351trique)p 0 TeXcolorgray
0 TeXcolorgray -128 4958 a FN(\226)p 0 TeXcolorgray 42
w(Trois)e(points)27 b FF(A)s FN(,)d FF(B)f FN(et)f FF(C)i
FN(sont)d(align\351s)h(si,)g(et)f(seulement)f(si,)i(les)g(vecteurs)2339
4902 y FC(\241)-32 b(\241)g(!)2345 4958 y FF(A)t(B)23
b FN(et)2573 4902 y FC(\241)-32 b(\241)h(!)2579 4958
y FF(A)t(C)24 b FN(sont)d(colin\351aires)n(.)p 0 TeXcolorgray
-128 5071 a(\226)p 0 TeXcolorgray 42 w(Les)g(droites)j
FF(d)427 5085 y FD(A)t(B)542 5071 y FN(et)f FF(d)684
5085 y FD(C)t(D)805 5071 y FN(sont)e(parall\350les)h(si,)g(et)f
(seulement)g(si,)h(les)f(vecteurs)2478 5014 y FC(\241)-32
b(\241)g(!)2484 5071 y FF(A)t(B)24 b FN(et)2712 5014
y FC(\241)-31 b(\241)h(!)2713 5071 y FF(C)5 b(D)25 b
FN(sont)c(colin\351aires)n(.)p 0.094 0.455 0.804 TeXcolorrgb
0 TeXcolorgray 0.094 0.455 0.804 TeXcolorrgb eop end
%%Page: 7 7
TeXDict begin 7 6 bop 0.094 0.455 0.804 TeXcolorrgb 0
0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100 -372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a
100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.7) cvn /DEST pdfmark end
 100 -372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t
(\311)t(T)t(R)t(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t
Fx(E)t(S)t(P)q(A)t(C)t(E)2726 b FN(7)p 109 -238 3780
2 v 0.094 0.455 0.804 TeXcolorrgb 109 -38 a
SDict begin H.S end
 109 -38 a
109 -38 a
SDict begin 12 H.A end
 109 -38 a 109 -38 a
SDict begin [/View [/XYZ H.V]/Dest (section*.10) cvn /DEST pdfmark
end
 109 -38 a FP(Caract\351risation)21
b(vectorielle)j(d'une)e(droite)p 0 TeXcolorgray 109 25
a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 25 a 109 25 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 25 a 0 TeXcolorgray 0 TeXcolorgray
166 212 a FN(\226)p 0 TeXcolorgray 42 w(Soit)32 b FF(A)d
FN(un)e(point)g(de)f(l'espace)g(et)1344 175 y FC(\241)-56
b(!)1354 212 y FF(u)44 b FN(un)27 b(vecteur)-8 b(.)27
b(L)-8 b('ensemble)26 b(des)g(points)j FF(M)i FN(de)26
b(l'espace)g(tels)g(que)3509 156 y FC(\241)-17 b(\241)f(!)3515
212 y FF(A)6 b(M)39 b FN(et)3782 175 y FC(\241)-57 b(!)3791
212 y FF(u)251 312 y FN(sont)21 b(colin\351aires)g(est)g(la)h(droite)g
(passant)f(par)28 b FF(A)d FN(et)c(de)g(vecteur)h(directeur)2631
275 y FC(\241)-57 b(!)2640 312 y FF(u)18 b FN(.)1566
386 y FC(\241)-18 b(\241)h(!)1572 442 y FF(A)6 b(M)27
b FC(\306)14 b FI(\270)c FC(\242)1890 405 y(\241)-57
b(!)1900 442 y FF(u)40 b FN(o\371)21 b FI(\270)h FN(est)e(un)i(r\351el)
p 0 TeXcolorgray 166 560 a(\226)p 0 TeXcolorgray 42 w(Soient)27
b FF(A)d FN(et)f FF(B)f FN(deux)g(points)g(de)f(l'espace)o(.)251
672 y(La)h(droite)h FF(d)653 686 y FD(A)t(B)768 672 y
FN(est)e(l'ensemble)f(des)i(points)i FF(M)i FN(tels)21
b(que)2075 616 y FC(\241)-18 b(\241)h(!)2081 672 y FF(A)6
b(M)34 b FN(et)2338 616 y FC(\241)-29 b(\241)h(!)2344
672 y FF(A)t(B)31 b FN(sont)21 b(colin\351aires)n(.)p
0 TeXcolorgray 138 58 3747 4 v 138 715 4 659 v 3881 715
V 138 717 3747 4 v 3883 749 35 663 v 171 749 3747 35
v 109 25 a
tx@Dict begin  PutEnd  end
 109 25 a 109 25 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 25 a 109 25 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 25
a 0 TeXcolorgray 163 135 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(Propri\351t\351)p 0 TeXcolorgray 109
25 a
tx@Dict begin  PutEnd  end
 109 25 a 109 972 a
SDict begin H.S end
 109 972 a 109 972 a
SDict begin 12 H.A end
 109 972 a
109 972 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.2.2) cvn /DEST pdfmark
end
 109 972 a 0.932 0.464 0 TeXcolorrgb 116 x FJ(2.2.2)92
b(V)-7 b(ecteurs)29 b(coplanaires)p 0 TeXcolorgray 109
1170 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 1170 a 109 1170 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 1170 a 0 TeXcolorgray
161 1313 a FH(~)-43 b FF(u)s FN(,)14 b FH(~)-41 b FF(v)23
b FN(et)i FH(~)-52 b FF(w)22 b FN(sont)f(trois)g(vecteurs)h(de)f
(l'espace)g(tels)g(que)c FH(~)-43 b FF(u)23 b FN(et)14
b FH(~)-41 b FF(v)22 b FN(ne)g(sont)f(pas)g(colin\351aires)n(.)166
1413 y(Les)h(vecteurs)16 b FH(~)-43 b FF(u)s FN(,)14
b FH(~)-41 b FF(v)22 b FN(et)k FH(~)-52 b FF(w)22 b FN(sont)f
(coplanaires)h(si,)g(et)f(seulement)f(si,)i(il)g(existe)f(deux)h
(r\351els)f FI(\270)h FN(et)f FI(\271)h FN(tels)f(que)g(:)1810
1530 y FH(~)-53 b FF(w)15 b FC(\306)f FI(\270)-5 b FH(~)-43
b FF(u)13 b FC(\305)d FI(\271)-8 b FH(~)-40 b FF(v)p
0 TeXcolorgray 138 1203 3747 4 v 138 1575 4 374 v 3881
1575 V 138 1577 3747 4 v 3883 1610 35 377 v 171 1610
3747 35 v 109 1170 a
tx@Dict begin  PutEnd  end
 109 1170 a 109 1170 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 1170 a
109 1170 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 1170 a 0 TeXcolorgray 163 1280 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p 0 TeXcolorgray
109 1170 a
tx@Dict begin  PutEnd  end
 109 1170 a 0 TeXcolorgray 0 TeXcolorgray 1398
2415 a @beginspecial -1 @llx -1 @lly 143 @urx 72 @ury
1440 @rwi @setspecial
%%BeginDocument: EspaceFigures.3
%!PS
%%BoundingBox: -1 -1 143 72 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 71.8624 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8000000000e00a000000000f8
%*Font: cmsy10 9.96265 9.96265 00:800000004
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 70.86613 lineto stroke
newpath 28.34645 70.86613 moveto
141.73225 70.86613 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 70.86613 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 28.34645 28.34645 moveto
93.54294 38.83463 lineto stroke
newpath 90.13728 36.73625 moveto
93.54294 38.83463 lineto
89.65102 39.75908 lineto
 closepath
gsave fill grestore stroke
newpath 28.34645 28.34645 moveto
68.03131 18.42525 lineto stroke
newpath 64.07513 17.83652 moveto
68.03131 18.42525 lineto
64.81763 20.80646 lineto
 closepath
gsave fill grestore stroke
newpath 28.34645 28.34645 moveto
53.85808 48.75583 lineto stroke
newpath 51.92859 45.25186 moveto
53.85808 48.75583 lineto
50.01602 47.64258 lineto
 closepath
gsave fill grestore stroke
15.90486 20.66455 moveto
(O) cmmi10 9.96265 fshow
96.54294 35.43073 moveto
(C) cmmi10 9.96265 fshow
64.2953 8.61745 moveto
(A) cmmi10 9.96265 fshow
49.82977 51.75583 moveto
(B) cmmi10 9.96265 fshow
43.20741 16.73085 moveto
(\000) cmsy10 9.96265 fshow
43.20761 16.73085 moveto
(!) cmsy10 9.96265 fshow
44.83911 12.44135 moveto
(u) cmmi10 9.96265 fshow
28.13936 38.86838 moveto
(\000) cmsy10 9.96265 fshow
28.13956 38.86838 moveto
(!) cmsy10 9.96265 fshow
30.02936 34.57887 moveto
(v) cmmi10 9.96265 fshow
55.96323 40.88004 moveto
(\000) cmsy10 9.96265 fshow
55.96342 40.88004 moveto
(!) cmsy10 9.96265 fshow
56.74623 36.59053 moveto
(w) cmmi10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 0.094 0.455 0.804 TeXcolorrgb 109 2631 a
SDict begin H.S end

109 2631 a 109 2631 a
SDict begin 12 H.A end
 109 2631 a 109 2631 a
SDict begin [/View [/XYZ H.V]/Dest (section*.11) cvn /DEST pdfmark
end
 109 2631
a FP(Cons\351quence)p 0 TeXcolorgray 109 2785 a FN(P)m(our)31
b(d\351montrer)f(qu'un)h(point)i FF(D)h FN(appartient)e(\340)e(un)h
(plan)g FI(\274)g FN(d\351\002ni)g(par)g(trois)f(points)h(non)f
(align\351s)38 b FF(A)s FN(,)32 b FF(B)g FN(et)f FF(C)i
FN(on)109 2897 y(montre)20 b(que)i(les)f(vecteurs)979
2841 y FC(\241)-32 b(\241)g(!)985 2897 y FF(A)t(B)r FN(,)1144
2841 y FC(\241)h(\241)f(!)1150 2897 y FF(A)t(C)25 b FN(et)1379
2841 y FC(\241)-28 b(\241)f(!)1385 2897 y FF(A)5 b(D)26
b FN(sont)21 b(coplanaires)n(.)p 0.094 0.455 0.804 TeXcolorrgb
109 3113 a
SDict begin H.S end
 109 3113 a 109 3113 a
SDict begin 12 H.A end
 109 3113 a 109 3113
a
SDict begin [/View [/XYZ H.V]/Dest (section*.12) cvn /DEST pdfmark
end
 109 3113 a FP(Caract\351risation)g(vectorielle)j(d'un)e(plan)p
0 TeXcolorgray 109 3192 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 3192 a 109 3192 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 3192
a 0 TeXcolorgray 0 TeXcolorgray 166 3348 a FN(\226)p
0 TeXcolorgray 42 w(Soient)27 b FF(A)s FN(,)c FF(B)g
FN(et)f FF(C)i FN(trois)d(points)h(non)g(align\351s)g(de)f(l'espace)o
(.)251 3460 y(Le)g(plan)h FI(\274)595 3474 y FD(A)t(B)r(C)755
3460 y FN(est)f(l'ensemble)f(des)h(points)k FF(M)h FN(du)21
b(plan)i(tels)e(que)2354 3403 y FC(\241)-17 b(\241)f(!)2360
3460 y FF(A)6 b(M)27 b FC(\306)17 b FF(x)2632 3403 y
FC(\241)-29 b(\241)h(!)2638 3460 y FF(A)t(B)19 b FC(\305)e
FF(y)2882 3403 y FC(\241)-27 b(\241)f(!)2888 3460 y FF(A)t(C)12
b FN(.)p 0 TeXcolorgray 166 3560 a(\226)p 0 TeXcolorgray
42 w(Soit)27 b FF(A)e FN(un)d(point)f(de)h(l'espace)f(et)1311
3523 y FC(\241)-57 b(!)1321 3560 y FF(u)39 b FN(et)1497
3523 y FC(\241)-57 b(!)1511 3560 y FF(v)42 b FN(deux)22
b(vecteurs)g(non)f(colin\351aires)n(.)251 3672 y(L)-8
b('ensemble)23 b(des)g(points)k FF(M)h FN(de)c(l'espace)g(tels)f(que)
1870 3616 y FC(\241)-18 b(\241)h(!)1876 3672 y FF(A)6
b(M)28 b FC(\306)19 b FF(x)2151 3635 y FC(\241)-57 b(!)2161
3672 y FF(u)28 b FC(\305)18 b FF(y)2348 3635 y FC(\241)-57
b(!)2363 3672 y FF(v)44 b FN(o\371)26 b FF(x)f FN(et)30
b FF(y)24 b FN(sont)g(des)f(r\351els)g(est)h(un)g(plan)g(que)251
3772 y(l'on)d(note)g(\()6 b FF(A)s FN(;)692 3735 y FC(\241)-57
b(!)702 3772 y FF(u)18 b FG(,)788 3735 y FC(\241)-57
b(!)802 3772 y FF(v)21 b FN(\).)p 0 TeXcolorgray 138
3225 3747 4 v 138 3813 4 590 v 3881 3813 V 138 3815 3747
4 v 3883 3848 35 594 v 171 3848 3747 35 v 109 3192 a
tx@Dict begin  PutEnd  end

109 3192 a 109 3192 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 3192 a 109 3192 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 3192
a 0 TeXcolorgray 163 3302 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(Propri\351t\351)p 0 TeXcolorgray 109
3192 a
tx@Dict begin  PutEnd  end
 109 3192 a 0 TeXcolorgray 0 TeXcolorgray 560 4641
a @beginspecial -1 @llx -1 @lly 143 @urx 72 @ury 1411
@rwi @setspecial
%%BeginDocument: EspaceFigures.1
%!PS
%%BoundingBox: -1 -1 143 72 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 71.8624 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8000000000e00800000000018
%*Font: cmsy10 9.96265 9.96265 00:800000004
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 70.86613 lineto stroke
newpath 28.34645 70.86613 moveto
141.73225 70.86613 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 70.86613 lineto stroke
2.09999 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 17.00804 31.18105 moveto
96.37776 11.33864 lineto stroke
newpath 22.67725 23.81107 moveto
62.3621 55.55908 lineto stroke
newpath 28.34645 28.34645 moveto
93.54294 38.83463 lineto stroke
newpath 90.13728 36.73625 moveto
93.54294 38.83463 lineto
89.65102 39.75908 lineto
 closepath
gsave fill grestore stroke
 [3 3 ] 0 setdash
newpath 93.54294 38.83463 moveto
68.03131 18.42525 lineto stroke
newpath 93.54294 38.83463 moveto
53.85808 48.75583 lineto stroke
 [] 0 setdash
newpath 28.34645 28.34645 moveto
45.35449 24.09444 lineto stroke
newpath 41.398 23.50566 moveto
45.35449 24.09444 lineto
42.14055 26.47585 lineto
 closepath
gsave fill grestore stroke
newpath 28.34645 28.34645 moveto
42.51968 39.68507 lineto stroke
newpath 40.5902 36.1811 moveto
42.51968 39.68507 lineto
38.67763 38.57182 lineto
 closepath
gsave fill grestore stroke
16.10686 20.66455 moveto
(A) cmmi10 9.96265 fshow
41.32619 14.28664 moveto
(B) cmmi10 9.96265 fshow
31.68658 36.28117 moveto
(C) cmmi10 9.96265 fshow
96.54294 35.43073 moveto
(M) cmmi10 9.96265 fshow
65.18436 11.13574 moveto
(x) cmmi10 9.96265 fshow
45.61618 47.57967 moveto
(y) cmmi10 9.96265 fshow
78.68488 20.28532 moveto
(y) cmmi10 9.96265 fshow
83.92677 27.09312 moveto
(\000) cmsy10 9.96265 fshow
87.09628 27.09312 moveto
(\000) cmsy10 9.96265 fshow
90.26558 27.09312 moveto
(!) cmsy10 9.96265 fshow
83.92677 20.28532 moveto
(AC) cmmi10 9.96265 fshow
74.49669 43.81883 moveto
(x) cmmi10 9.96265 fshow
80.19058 50.62663 moveto
(\000) cmsy10 9.96265 fshow
83.47179 50.62663 moveto
(\000) cmsy10 9.96265 fshow
86.75288 50.62663 moveto
(!) cmsy10 9.96265 fshow
80.19058 43.81883 moveto
(AB) cmmi10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 1696 w @beginspecial -1 @llx -1 @lly 143
@urx 72 @ury 1411 @rwi @setspecial
%%BeginDocument: EspaceFigures.2
%!PS
%%BoundingBox: -1 -1 143 72 
%%HiResBoundingBox: -0.99626 -0.99626 142.72852 71.8624 
%%Creator: MetaPost 1.504
%%CreationDate: 2012.11.02:1038
%%Pages: 1
%*Font: cmmi10 9.96265 9.96265 19:8000000000e008000000000d8
%*Font: cmsy10 9.96265 9.96265 00:800000004
%%BeginProlog
%%EndProlog
%%Page: 1 1
 0 0 0 setrgbcolor 0 0.5 dtransform truncate idtransform setlinewidth pop
 [] 0 setdash 1 setlinecap 1 setlinejoin 10 setmiterlimit
newpath 0 0 moveto
28.34645 70.86613 lineto stroke
newpath 28.34645 70.86613 moveto
141.73225 70.86613 lineto stroke
 0 1.99252 dtransform truncate idtransform setlinewidth pop
newpath 0 0 moveto
113.3858 0 lineto stroke
newpath 113.3858 0 moveto
141.73225 70.86613 lineto stroke
4.93481 2.09999 moveto
(\031) cmmi10 9.96265 fshow
 0 0.49814 dtransform truncate idtransform setlinewidth pop
newpath 17.00804 31.18105 moveto
96.37776 11.33864 lineto stroke
newpath 22.67725 23.81107 moveto
62.3621 55.55908 lineto stroke
newpath 28.34645 28.34645 moveto
93.54294 38.83463 lineto stroke
newpath 90.13728 36.73625 moveto
93.54294 38.83463 lineto
89.65102 39.75908 lineto
 closepath
gsave fill grestore stroke
 [3 3 ] 0 setdash
newpath 93.54294 38.83463 moveto
68.03131 18.42525 lineto stroke
newpath 93.54294 38.83463 moveto
53.85808 48.75583 lineto stroke
 [] 0 setdash
newpath 28.34645 28.34645 moveto
56.6929 21.25984 lineto stroke
newpath 52.73636 20.67107 moveto
56.6929 21.25984 lineto
53.47891 23.64128 lineto
 closepath
gsave fill grestore stroke
newpath 28.34645 28.34645 moveto
48.18887 44.22046 lineto stroke
newpath 46.25949 40.71669 moveto
48.18887 44.22046 lineto
44.34705 43.10725 lineto
 closepath
gsave fill grestore stroke
16.10686 20.66455 moveto
(A) cmmi10 9.96265 fshow
96.54294 35.43073 moveto
(M) cmmi10 9.96265 fshow
37.53821 18.14815 moveto
(\000) cmsy10 9.96265 fshow
37.5384 18.14815 moveto
(!) cmsy10 9.96265 fshow
39.1699 13.85864 moveto
(u) cmmi10 9.96265 fshow
25.30475 36.6007 moveto
(\000) cmsy10 9.96265 fshow
25.30495 36.6007 moveto
(!) cmsy10 9.96265 fshow
27.19475 32.31119 moveto
(v) cmmi10 9.96265 fshow
showpage
%%EOF

%%EndDocument
 @endspecial 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 8 8
TeXDict begin 8 7 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.8) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(8)3431 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (section.2.3) cvn /DEST pdfmark
end
 -128 -121 a 0.93 0.26 0 TeXcolorrgb 83 x FK(2.3)111
b(Rep\351rage)31 b(dans)h(l'espace)p 0 TeXcolorgray -128
68 a
SDict begin H.S end
 -128 68 a -128 68 a
SDict begin 12 H.A end
 -128 68 a -128 68 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.3.1) cvn /DEST pdfmark
end
 -128 68
a 0.932 0.464 0 TeXcolorrgb 93 x FJ(2.3.1)93 b(Coordonn\351es)27
b(d'un)h(point)p 0 TeXcolorgray 510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510
1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 510 1235
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 510
1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 510 1235 a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510 1235 a 510 1235
a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 510 1235 a 492 1252 a FF(x)510 1235 y
tx@Dict begin  PutEnd  end
 510 1235 a 510
1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 510 1235 a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510
1235 a 510 1235 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 510 1235 a 494 1245 a FF(y)510 1235
y
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 510 1235
a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510 1235 a 510 1235 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 510 1235 a 493 1252
a FF(z)510 1235 y
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510
1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 510 1235 a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510 1235 a 510 1235
a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235
a 510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 510 1235 a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510 1235 a 510 1235
a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235
a 510 1235 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 510 1235 a 510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 510 1235 a 510 1235
a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.545 0.45 0.332  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 0  0  0  } def /P2 { 4 0 0 } def /P3 { 0 7 0 }
def /SphericalCoor false def /xUnit { 17.07182  mul } def /yUnit {
17.07182  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 0.8 SLW 0.545 0.45 0.332  setrgbcolor  1.
.setopacityalpha   0  setlinecap [  3.0  4.0 ] 2 DashLine  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.545 0.45 0.332  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 0  0  0  } def /P2 { 0 0 5 } def /P3 { 4 0 0 }
def /SphericalCoor false def /xUnit { 17.07182  mul } def /yUnit {
17.07182  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 0.8 SLW 0.545 0.45 0.332  setrgbcolor  1.
.setopacityalpha   0  setlinecap [  3.0  4.0 ] 2 DashLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.545 0.45 0.332  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 0 4 add 0 0 add 0 0 add } def /P2 { 0 0 5 } def
/P3 { 0 7 0 } def /SphericalCoor false def /xUnit { 17.07182  mul }
def /yUnit { 17.07182  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 0.8 SLW 0.545 0.45 0.332  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.545 0.45 0.332  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 0 0 add 0 0 add 0 5 add } def /P2 { 4 0 0 } def
/P3 { 0 7 0 } def /SphericalCoor false def /xUnit { 17.07182  mul }
def /yUnit { 17.07182  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 0.8 SLW 0.545 0.45 0.332  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.545 0.45 0.332  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 0 0 add 0 7 add 0 0 add } def /P2 { 0 0 5 } def
/P3 { 4 0 0 } def /SphericalCoor false def /xUnit { 17.07182  mul }
def /yUnit { 17.07182  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 0.8 SLW 0.545 0.45 0.332  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 7 5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 510 1235 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.45 0.332  setrgbcolor 
1.0 SLW 0.545 0.45 0.332  setrgbcolor  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.45 0.332  setrgbcolor 
[ tx@NodeDict begin tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter
} { 0 0 } ifelse end   false NArray  /DS 2.0 2. CLW mul add 2 div def
/PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto
gsave 1.  1.  scale (b) show grestore } bind def  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul exch
17.07182 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 510
1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.5  setgray  end
 
@endspecial 510 1235
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 510 1235 a 487 1255 a Fs(O)510 1235 y
tx@Dict begin  PutEnd  end
 510 1235 a 510
1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul
exch 17.07182 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.5  setgray  end
 
@endspecial
510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 510 1235 a 1 0 0 TeXcolorrgb 488 1250 a Fq(~)500
1265 y Fp(i)p 0 TeXcolorgray 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510
1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul
exch 17.07182 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.5  setgray  end
 
@endspecial
510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 510 1235 a 1 0 0 TeXcolorrgb 490 1244 a Fq(~)504
1259 y Fp(j)p 0 TeXcolorgray 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 510
1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul
exch 17.07182 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 510 1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.5  setgray  end
 
@endspecial
510 1235 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 510 1235 a 1 0 0 TeXcolorrgb 485 1250 a Fq(~)493
1266 y Fp(k)p 0 TeXcolorgray 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale  false
0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED
{ 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg
rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow  moveto
} def /ArrowB { } def /ArrowInside { } def  1.7 SLW 0  setgray  /ArrowA
{ BeginArrow 1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2
div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg
h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore grestore
0 h a sub moveto   EndArrow  moveto } def /ArrowB { } def /ArrowInside
{ } def  [ 0 0 0 4 7 5  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.
 def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.
 def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def
/RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta 12.
 def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2
Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def
/Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true
def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation
false def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 17.07182
 mul } def /yUnit { 17.07182  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.7 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0.545 0.45 0.332  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 0 0 0 4 7 0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 17.07182  mul } def /yUnit { 17.07182  mul } def
convertStackTo2D end   /Lineto /lineto load def 1  setlinejoin false
  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.2 SLW 0.545 0.45 0.332  setrgbcolor  1. .setopacityalpha
  3.0 0 0 add  DotLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0.545 0.45 0.332  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 0 0 5 4 7 5
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 17.07182  mul } def /yUnit { 17.07182  mul } def
convertStackTo2D end   /Lineto /lineto load def 1  setlinejoin false
  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.2 SLW 0.545 0.45 0.332  setrgbcolor  1. .setopacityalpha
  3.0 0 0 add  DotLine  grestore end
 
@endspecial 510 1235 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4.5 7.5 5.7 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  17.07182 mul
exch 17.07182 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 510
1235 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.5  setgray  end
 
@endspecial 510 1235
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 510 1235 a 0.545 0.45 0.332 TeXcolorrgb 486 1255 a
Fs(M)p 0 TeXcolorgray 510 1235 a
tx@Dict begin  PutEnd  end
 510 1235 a 1779 667
a FN(Dans)21 b(un)h(rep\350re)2352 580 y Fo(\263)2383
667 y FN(O;)2462 648 y FH(~)2476 667 y FF(i)s FG(,)2520
648 y FH(~)2537 667 y FF(j)t FG(,)2579 647 y FH(~)2588
667 y FF(k)2633 580 y Fo(\264)2665 667 y FN(,)f(pour)h(tout)f(point)k
FF(M)t FN(,)e(il)f(existe)1779 779 y(un)f(unique)h(triplet)2411
781 y(\()2439 779 y FF(x)2481 792 y FD(M)2544 779 y FN(;)15
b FF(y)2619 792 y FD(M)2681 779 y FN(;)d FF(z)2754 792
y FD(M)2817 781 y FN(\))2864 779 y(de)21 b(r\351els)g(tels)h(que)2253
853 y FC(\241)-21 b(\241)f(!)2253 909 y FF(O)5 b(M)20
b FC(\306)d FF(x)2525 922 y FD(M)2597 909 y FC(\242)2618
891 y FH(~)2632 909 y FF(i)c FC(\305)k FF(y)2782 922
y FD(M)2854 909 y FC(\242)2879 891 y FH(~)2896 909 y
FF(j)d FC(\305)g FF(z)3043 922 y FD(M)3115 909 y FC(\242)3139
889 y FH(~)3148 909 y FF(k)1779 1029 y FN(\()1807 1027
y FF(x)1849 1040 y FD(M)1933 1027 y FN(;)37 b FF(y)2030
1040 y FD(M)2114 1027 y FN(;)d FF(z)2209 1040 y FD(M)2271
1029 y FN(\))2323 1027 y(est)25 b(le)h(triplet)i(de)e(coordonn\351es)f
(du)i(point)1782 1139 y FF(M)e FN(\(ou)c(du)h(vecteur)2412
1083 y FC(\241)-21 b(\241)f(!)2412 1139 y FF(O)5 b(M)g
FN(\).)1782 1239 y FF(x)1824 1252 y FD(M)1907 1239 y
FN(est)21 b(l'abscisse)o(,)28 b FF(y)2451 1252 y FD(M)2535
1239 y FN(est)20 b(l'ordonn\351e)o(,)25 b FF(z)3113 1252
y FD(M)3197 1239 y FN(est)c(la)g(cote)o(.)-128 1685 y(Dans)h(cette)f
(repr\351sentation,)g(le)h(point)j FF(M)h FN(a)21 b(pour)h
(coordonn\351es)1940 1687 y(\()1966 1685 y(4)g(;)30 b(7)21
b(;)30 b(5)2240 1687 y(\))2266 1685 y(.)22 b(P)m(ar)g(ailleurs)n(,)2769
1629 y FC(\241)-22 b(\241)g(!)2769 1685 y FF(O)5 b(M)19
b FC(\306)14 b FN(4)3028 1667 y FH(~)3042 1685 y FF(i)e
FC(\305)e FN(7)3182 1667 y FH(~)3199 1685 y FF(j)j FC(\305)d
FN(5)3337 1665 y FH(~)3346 1685 y FF(k)-128 1818 y
SDict begin H.S end
 -128
1818 a -128 1818 a
SDict begin 12 H.A end
 -128 1818 a -128 1818 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.3.2) cvn /DEST pdfmark
end
 -128 1818
a 0.932 0.464 0 TeXcolorrgb 100 x FJ(2.3.2)93 b(Calculs)26
b(avec)f(les)i(coordonn\351es)p 0 TeXcolorgray -128 1981
a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 1981 a -128 1981 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 1981 a 0 TeXcolorgray
-70 2155 a FN(Dans)21 b(un)h(rep\350re)503 2068 y Fo(\263)535
2155 y FN(O;)614 2136 y FH(~)628 2155 y FF(i)s FG(,)672
2136 y FH(~)689 2155 y FF(j)s FG(,)730 2135 y FH(~)739
2155 y FF(k)785 2068 y Fo(\264)816 2155 y FN(,)g(on)f(consid\350re)h
(les)f(vecteurs)c FH(~)-43 b FF(u)1825 2157 y FN(\()1854
2155 y FF(x)22 b FN(;)37 b FF(y)22 b FN(;)34 b FF(z)2127
2157 y FN(\))2173 2155 y(et)14 b FH(~)-41 b FF(v)2314
2091 y Fo(\241)2347 2155 y FF(x)2387 2125 y Fw(0)2429
2155 y FN(;)37 b FF(y)2526 2125 y Fw(0)2569 2155 y FN(;)d
FF(z)2662 2125 y Fw(0)2683 2091 y Fo(\242)2713 2155 y
FN(.)p 0 TeXcolorgray -70 2273 a(\226)p 0 TeXcolorgray
37 w FH(~)-44 b FF(u)17 b FC(\306)6 b FH(~)-40 b FF(v)22
b FN(si,)g(et)f(seulement)g(si,)k FF(x)15 b FC(\306)i
FF(x)1069 2243 y Fw(0)1090 2273 y FN(,)29 b FF(y)14 b
FC(\306)21 b FF(y)1308 2243 y Fw(0)1351 2273 y FN(et)k
FF(z)16 b FC(\306)i FF(z)1608 2243 y Fw(0)1629 2273 y
FN(.)p 0 TeXcolorgray -70 2373 a(\226)p 0 TeXcolorgray
41 w(Le)k(vecteur)g(somme)15 b FH(~)-43 b FF(u)12 b FC(\305)r
FH(~)-40 b FF(v)22 b FN(a)g(pour)f(coordonn\351es)1582
2309 y Fo(\241)1615 2373 y FF(x)11 b FC(\305)i FF(x)1773
2343 y Fw(0)1815 2373 y FN(;)37 b FF(y)10 b FC(\305)17
b FF(y)2033 2343 y Fw(0)2076 2373 y FN(;)34 b FF(z)12
b FC(\305)i FF(z)2286 2343 y Fw(0)2307 2309 y Fo(\242)2337
2373 y FN(.)p 0 TeXcolorgray -70 2473 a(\226)p 0 TeXcolorgray
41 w(P)m(our)23 b(tout)e(r\351el)g FI(\270)p FN(,)100
b FI(\270)10 b FC(\242)5 b FH(~)-43 b FF(u)17 b FC(\306)922
2475 y FN(\()948 2473 y FI(\270)p FG(.)s FF(x)23 b FN(;)30
b FI(\270)p FG(.)7 b FF(y)22 b FN(;)30 b FI(\270)p FG(.)t
FF(z)1432 2475 y FN(\))1459 2473 y(.)-70 2672 y(Soit)d
FF(A)s FN(\()s FF(x)228 2686 y FD(A)298 2672 y FN(;)37
b FF(y)396 2686 y FD(A)466 2672 y FN(;)d FF(z)562 2686
y FD(A)610 2672 y FN(\))21 b(et)h FF(B)814 2674 y FN(\()842
2672 y FF(x)882 2685 y FD(B)951 2672 y FN(;)37 b FF(y)1046
2685 y FD(B)1115 2672 y FN(;)d FF(z)1208 2685 y FD(B)1255
2674 y FN(\))1302 2672 y(deux)22 b(points)g(de)f(l'espace)g(:)p
0 TeXcolorgray -70 2784 a(\226)p 0 TeXcolorgray 41 w(le)h(vecteur)385
2728 y FC(\241)-32 b(\241)f(!)391 2784 y FF(A)t(B)23
b FN(a)e(pour)h(coordonn\351es)1236 2786 y(\()1264 2784
y FF(x)1304 2797 y FD(B)1362 2784 y FC(\241)13 b FF(x)1473
2798 y FD(A)1543 2784 y FN(;)37 b FF(y)1638 2797 y FD(B)1695
2784 y FC(\241)17 b FF(y)1807 2798 y FD(A)1877 2784 y
FN(;)34 b FF(z)1970 2797 y FD(B)2027 2784 y FC(\241)14
b FF(z)2137 2798 y FD(A)2185 2786 y FN(\))2211 2784 y(.)p
0 TeXcolorgray -70 2884 a(\226)p 0 TeXcolorgray 41 w(le)22
b(milieu)k FF(I)h FN(du)22 b(segment)845 2887 y([)877
2884 y FF(A)t(B)993 2887 y FN(])1040 2884 y(a)f(pour)h(coordonn\351es)
1747 2820 y Fo(\241)1790 2844 y FD(x)1822 2856 y Fm(A)1861
2844 y Fw(\305)s FD(x)1935 2855 y Fm(B)p 1787 2865 187
5 v 1864 2913 a Fl(2)2005 2884 y FN(;)2072 2844 y FD(y)2101
2856 y Fm(A)2141 2844 y Fw(\305)6 b FD(y)2215 2855 y
Fm(B)p 2066 2865 189 5 v 2144 2913 a Fl(2)2286 2884 y
FN(;)2350 2844 y FD(z)2381 2856 y Fm(A)2420 2844 y Fw(\305)s
FD(z)2493 2855 y Fm(B)p 2347 2865 186 5 v 2423 2913 a
Fl(2)2542 2820 y Fo(\242)2571 2884 y FN(.)p 0 TeXcolorgray
-98 2014 3747 4 v -98 2939 4 927 v 3645 2939 V -98 2941
3747 4 v 3646 2974 35 931 v -65 2974 3747 35 v -128 1981
a
tx@Dict begin  PutEnd  end
 -128 1981 a -128 1981 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 1981 a -128 1981 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128
1981 a 0 TeXcolorgray -73 2091 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(D\351\002nition)p 0 TeXcolorgray -128
1981 a
tx@Dict begin  PutEnd  end
 -128 1981 a 0.094 0.455 0.804 TeXcolorrgb -128
3296 a
SDict begin H.S end
 -128 3296 a -128 3296 a
SDict begin 12 H.A end
 -128 3296 a -128 3296
a
SDict begin [/View [/XYZ H.V]/Dest (section*.13) cvn /DEST pdfmark
end
 -128 3296 a FP(Distance)22 b(dans)h(un)f(rep\350re)h(orthonorm\351)p
0 TeXcolorgray -128 3375 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 3375 a -128 3375 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128
3375 a 0 TeXcolorgray -70 3548 a FN(Dans)e(un)h(rep\350re)f
FP(orthonormal)1034 3461 y Fo(\263)1065 3548 y FN(O;)1144
3530 y FH(~)1158 3548 y FF(i)s FG(,)1202 3530 y FH(~)1219
3548 y FF(j)t FG(,)1261 3528 y FH(~)1270 3548 y FF(k)1315
3461 y Fo(\264)1347 3548 y FN(,)p 0 TeXcolorgray -70
3660 a(\226)p 0 TeXcolorgray 41 w(La)h(distance)g(entre)f(les)h(points)
27 b FF(A)s FN(\()s FF(x)1156 3674 y FD(A)1226 3660 y
FN(;)37 b FF(y)1324 3674 y FD(A)1394 3660 y FN(;)d FF(z)1490
3674 y FD(A)1538 3660 y FN(\))21 b(et)h FF(B)1742 3662
y FN(\()1770 3660 y FF(x)1810 3673 y FD(B)1879 3660 y
FN(;)37 b FF(y)1974 3673 y FD(B)2043 3660 y FN(;)d FF(z)2136
3673 y FD(B)2183 3662 y FN(\))2230 3660 y(est)21 b(donn\351e)g(par)p
1079 3743 122 5 v 1085 3813 a FF(A)t(B)16 b FC(\306)1284
3711 y Fo(q)p 1361 3711 1195 5 v 1361 3815 a FN(\()1390
3813 y FF(x)1430 3826 y FD(B)1487 3813 y FC(\241)d FF(x)1598
3827 y FD(A)1646 3815 y FN(\))1672 3783 y Fl(2)1719 3813
y FC(\305)1784 3815 y FN(\()1817 3813 y FF(y)1854 3826
y FD(B)1911 3813 y FC(\241)k FF(y)2023 3827 y FD(A)2071
3815 y FN(\))2097 3783 y Fl(2)2144 3813 y FC(\305)2209
3815 y FN(\()2239 3813 y FF(z)2277 3826 y FD(B)2334 3813
y FC(\241)d FF(z)2444 3827 y FD(A)2492 3815 y FN(\))2518
3783 y Fl(2)p 0 TeXcolorgray -70 3930 a FN(\226)p 0 TeXcolorgray
41 w(Deux)22 b(vecteurs)17 b FH(~)-43 b FF(u)r FN(\()r
FF(u)676 3942 y FD(x)719 3930 y FN(;)18 b FF(u)813 3942
y FD(y)856 3930 y FN(;)h FF(u)948 3942 y FD(z)982 3930
y FN(\))i(et)13 b FH(~)-40 b FF(v)p FN(\()r FF(v)1232
3942 y FD(x)1274 3930 y FN(;)18 b FF(v)1359 3942 y FD(y)1400
3930 y FN(;)h FF(v)1483 3942 y FD(z)1516 3930 y FN(\))i(sont)g
(orthogonaux)h(si,)g(et)f(seulement)f(si,)1366 4048 y
FF(u)1418 4060 y FD(x)1463 4048 y FC(\242)12 b FF(v)1539
4060 y FD(x)1583 4048 y FC(\305)g FF(u)1705 4060 y FD(y)1749
4048 y FC(\242)g FF(v)1828 4060 y FD(y)1872 4048 y FC(\305)g
FF(u)1991 4060 y FD(z)2035 4048 y FC(\242)g FF(v)2111
4060 y FD(z)2158 4048 y FC(\306)i FN(0)p 0 TeXcolorgray
-98 3407 3747 4 v -98 4099 4 694 v 3645 4099 V -98 4101
3747 4 v 3646 4134 35 697 v -65 4134 3747 35 v -128 3375
a
tx@Dict begin  PutEnd  end
 -128 3375 a -128 3375 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 3375 a -128 3375 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128
3375 a 0 TeXcolorgray -73 3485 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(D\351\002nition)p 0 TeXcolorgray -128
3375 a
tx@Dict begin  PutEnd  end
 -128 3375 a 0.094 0.455 0.804 TeXcolorrgb -128
4456 a
SDict begin H.S end
 -128 4456 a -128 4456 a
SDict begin 12 H.A end
 -128 4456 a -128 4456
a
SDict begin [/View [/XYZ H.V]/Dest (section*.14) cvn /DEST pdfmark
end
 -128 4456 a FP(V)-6 b(ecteurs)23 b(colin\351aires)p
0 TeXcolorgray -128 4519 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4519 a -128 4519 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128
4519 a 0 TeXcolorgray -70 4662 a FN(Les)e(vecteurs)c
FH(~)-43 b FF(u)r FN(\()r FF(u)530 4674 y FD(x)573 4662
y FN(;)19 b FF(u)668 4674 y FD(y)710 4662 y FN(;)g FF(u)802
4674 y FD(z)836 4662 y FN(\))i(et)13 b FH(~)-40 b FF(v)p
FN(\()r FF(v)1086 4674 y FD(x)1128 4662 y FN(;)18 b FF(v)1213
4674 y FD(y)1254 4662 y FN(;)h FF(v)1337 4674 y FD(z)1370
4662 y FN(\))i(sont)g(colin\351aires)h(lorsqu'il)f(existe)h
FI(\270)14 b FC(2)h Fk(R)2707 4674 y Fl(0)2765 4662 y
FN(tel)21 b(que)1545 4706 y Fo(8)1545 4775 y(<)1545 4913
y(:)1610 4764 y FF(u)1662 4776 y FD(x)1711 4764 y FC(\306)14
b FI(\270)c FC(\242)i FF(v)1914 4776 y FD(x)1610 4864
y FF(u)1665 4876 y FD(y)1714 4864 y FC(\306)i FI(\270)c
FC(\242)i FF(v)1920 4876 y FD(y)1610 4963 y FF(u)1662
4975 y FD(z)1710 4963 y FC(\306)i FI(\270)c FC(\242)i
FF(v)1913 4975 y FD(z)p 0 TeXcolorgray -98 4551 3747
4 v -98 5020 4 471 v 3645 5020 V -98 5022 3747 4 v 3646
5055 35 474 v -65 5055 3747 35 v -128 4519 a
tx@Dict begin  PutEnd  end
 -128 4519
a -128 4519 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 4519 a -128 4519 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 4519 a 0 TeXcolorgray
-73 4629 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p
0 TeXcolorgray -128 4519 a
tx@Dict begin  PutEnd  end
 -128 4519 a 0.094 0.455 0.804
TeXcolorrgb 0 TeXcolorgray 0.094 0.455 0.804 TeXcolorrgb
eop end
%%Page: 9 9
TeXDict begin 9 8 bop 0.094 0.455 0.804 TeXcolorrgb 0
0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100 -372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a
100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.9) cvn /DEST pdfmark end
 100 -372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t
(\311)t(T)t(R)t(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t
Fx(E)t(S)t(P)q(A)t(C)t(E)2726 b FN(9)p 109 -238 3780
2 v 0.094 0.455 0.804 TeXcolorrgb 109 -38 a
SDict begin H.S end
 109 -38 a
109 -38 a
SDict begin 12 H.A end
 109 -38 a 109 -38 a
SDict begin [/View [/XYZ H.V]/Dest (section*.15) cvn /DEST pdfmark
end
 109 -38 a FP(V)-6 b(ecteurs)22
b(coplanaires)p 0 TeXcolorgray 109 40 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 40 a 109
40 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 40 a 0 TeXcolorgray 166 183 a FN(Les)29 b(vecteurs)24
b FH(~)-43 b FF(u)r FN(\()r FF(u)781 195 y FD(x)824 183
y FN(;)19 b FF(u)919 195 y FD(y)961 183 y FN(;)g FF(u)1053
195 y FD(z)1087 183 y FN(\),)i FH(~)-40 b FF(v)p FN(\()r
FF(v)1276 195 y FD(x)1318 183 y FN(;)18 b FF(v)1403 195
y FD(y)1444 183 y FN(;)h FF(v)1527 195 y FD(z)1560 183
y FN(\))28 b(et)34 b FH(~)-53 b FF(w)q FN(\()r FF(w)1866
195 y FD(x)1907 183 y FN(;)18 b FF(w)2012 195 y FD(y)2053
183 y FN(;)h FF(w)2156 195 y FD(z)2189 183 y FN(\))28
b(sont)h(coplanaires)g(lorsqu'il)h(existe)e FI(\270)p
FG(,)i FI(\271)20 b FC(2)h Fk(R)3698 195 y Fl(0)3763
183 y FN(tel)166 283 y(que)1648 319 y Fo(8)1648 388 y(<)1648
525 y(:)1713 377 y FF(w)1776 389 y FD(x)1824 377 y FC(\306)14
b FI(\270)c FC(\242)i FF(u)2036 389 y FD(x)2082 377 y
FC(\305)e FI(\271)g FC(\242)i FF(v)2281 389 y FD(x)1713
477 y FF(w)1779 489 y FD(y)1827 477 y FC(\306)i FI(\270)c
FC(\242)i FF(u)2042 489 y FD(y)2087 477 y FC(\305)e FI(\271)g
FC(\242)i FF(v)2289 489 y FD(y)1713 576 y FF(w)1776 588
y FD(z)1823 576 y FC(\306)i FI(\270)c FC(\242)i FF(u)2035
588 y FD(z)2080 576 y FC(\305)e FI(\271)g FC(\242)i FF(v)2279
588 y FD(z)p 0 TeXcolorgray 138 73 3747 4 v 138 633 4
562 v 3881 633 V 138 635 3747 4 v 3883 668 35 565 v 171
668 3747 35 v 109 40 a
tx@Dict begin  PutEnd  end
 109 40 a 109 40 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 40 a 109
40 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 40 a 0 TeXcolorgray 163 150 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p 0 TeXcolorgray
109 40 a
tx@Dict begin  PutEnd  end
 109 40 a 833 x FC(})45 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17
b FN(:)60 b(Montrons)33 b(en)g(premier)h(lieu)g(que)f(les)g(vecteurs)c
FH(~)-44 b FF(u)s FN(\(0;)8 b(4;)g FC(\241)p FN(2\),)26
b FH(~)-40 b FF(v)p FN(\(3;)8 b FC(\241)p FN(1;)g(2\))34
b(et)k FH(~)-53 b FF(w)q FN(\(3;)8 b(7;)g FC(\241)p FN(2\))33
b(sont)595 973 y(coplanaires)n(.)109 1097 y(On)21 b(v\351ri\002e)h(que)
f(les)h(vecteurs)16 b FH(~)-43 b FF(u)24 b FN(et)13 b
FH(~)-40 b FF(v)22 b FN(sont)f(pas)h(colin\351aires)f(puis)h(on)g(rec)o
(herc)o(he)g(des)f(r\351els)g FI(\270)h FN(et)f FI(\271)h
FN(v\351ri\002ant)g(:)1797 1214 y FH(~)-52 b FF(w)14
b FC(\306)h FI(\270)-5 b FH(~)-43 b FF(u)12 b FC(\305)e
FI(\271)-8 b FH(~)-40 b FF(v)109 1247 y
SDict begin H.S end
 109 1247 a 109
1247 a
SDict begin 12 H.A end
 109 1247 a 109 1247 a
SDict begin [/View [/XYZ H.V]/Dest (Item.1) cvn /DEST pdfmark end
 109 1247 a 0 TeXcolorgray
193 x FP(1.)p 0 TeXcolorgray 136 w FH(~)d FF(u)16 b FC(\306)e
FI(\270)c FC(\242)r FH(~)-40 b FF(v)30 b FC(\()-12 b(\))779
1281 y Fo(8)779 1350 y(<)779 1488 y(:)843 1339 y FN(0)14
b FC(\306)g FN(3)p FI(\270)843 1439 y FN(4)g FC(\306)g(\241)p
FI(\270)843 1538 y FC(\241)p FN(2)g FC(\306)g FN(2)p
FI(\270)1195 1440 y FC(\()-12 b(\))1364 1281 y Fo(8)1364
1350 y(<)1364 1488 y(:)1427 1339 y FI(\270)15 b FC(\306)f
FN(0)1427 1439 y FI(\270)h FC(\306)f(\241)p FN(4)1427
1538 y FI(\270)h FC(\306)f(\241)p FN(1)2101 1347 y(Comme)22
b FI(\270)j FN(ne)e(peut)h(\352tre)f(simultan\351ment)h(\351gal)g(\340)
f(0,)i(-4)2101 1447 y(et)d(-1,)h(on)f(en)g(conc)o(lut)i(la)e
(non-colin\351arit\351)h(des)f(vecteurs)2097 1546 y FH(~)-44
b FF(u)24 b FN(et)13 b FH(~)-40 b FF(v)109 1583 y
SDict begin H.S end
 109
1583 a 109 1583 a
SDict begin 12 H.A end
 109 1583 a 109 1583 a
SDict begin [/View [/XYZ H.V]/Dest (Item.2) cvn /DEST pdfmark end
 109 1583 a 0
TeXcolorgray 193 x FP(2.)p 0 TeXcolorgray 145 w FH(~)-52
b FF(w)14 b FC(\306)h FI(\270)10 b FC(\242)5 b FH(~)-43
b FF(u)13 b FC(\305)d FI(\271)g FC(\242)r FH(~)-40 b
FF(v)30 b FC(\()-12 b(\))1007 1617 y Fo(8)1007 1686 y(<)1007
1824 y(:)1070 1675 y FN(3)14 b FC(\306)g FN(3)p FI(\271)1070
1775 y FN(7)g FC(\306)g FN(4)p FI(\270)c FC(\241)g FI(\271)1070
1874 y FC(\241)p FN(2)k FC(\306)g(\241)p FN(2)p FI(\270)c
FC(\305)g FN(2)p FI(\271)1644 1776 y FC(\()-12 b(\))1813
1617 y Fo(8)1813 1686 y(<)1813 1824 y(:)1876 1675 y FI(\271)15
b FC(\306)f FN(1)1876 1775 y(7)g FC(\306)g FN(4)p FI(\270)c
FC(\241)g FN(1)1876 1874 y FC(\241)p FN(2)k FC(\306)g(\241)p
FN(2)p FI(\270)c FC(\305)g FN(2)p FI(\271)2450 1776 y
FC(\()-12 b(\))2619 1617 y Fo(8)2619 1686 y(<)2619 1824
y(:)2682 1675 y FI(\271)15 b FC(\306)f FN(1)2682 1775
y FI(\270)h FC(\306)f FN(2)2682 1874 y FC(\241)p FN(2)g
FC(\306)h(\241)p FN(2)p FI(\270)10 b FC(\305)g FN(2)p
FI(\271)315 1969 y FN(Les)27 b(vecteurs)g(seront)g(coplanaires)h(si)f
FI(\270)g FN(et)g FI(\271)h FN(sont)e(aussi)i(solutions)e(de)i(la)f
(troisi\350me)f(\351quation.)i(C'est)e(le)h(cas)315 2069
y(puisque)21 b(:)1767 2168 y FC(\241)p FN(2)14 b FC(\306)g(\241)p
FN(2)c FC(\242)g FN(\(2\))g FC(\305)g FN(2)g FC(\242)g
FN(\(1\))109 2303 y
SDict begin H.S end
 109 2303 a 109 2303 a
SDict begin 12 H.A end
 109 2303 a
109 2303 a
SDict begin [/View [/XYZ H.V]/Dest (section.2.4) cvn /DEST pdfmark
end
 109 2303 a 0.93 0.26 0 TeXcolorrgb 140 x FK(2.4)110
b(Repr\351sentation)32 b(param\351trique)p 0 TeXcolorgray
109 2625 a FN(Soient)22 b(une)g(droite)h(vectorielle)i
FF(d)s FN(\()6 b FF(A)s FG(,)-5 b FH(~)-43 b FF(u)t FN(\))23
b(et)f(un)h(plan)g(vectoriel)g FI(\274)p FN(\()6 b FF(A)s
FN(;)2284 2588 y FC(\241)-57 b(!)2295 2625 y FF(u)17
b FG(,)2380 2588 y FC(\241)-57 b(!)2394 2625 y FF(v)22
b FN(\))g(a)o(vec)h(le)g(point)g(d'ancrage)29 b FF(A)s
FN(\()s FF(x)3475 2639 y FD(A)3524 2625 y FN(;)15 b FF(y)3600
2639 y FD(A)3648 2625 y FN(;)d FF(z)3722 2639 y FD(A)3771
2625 y FN(\))23 b(et)109 2725 y(les)e(vecteurs)g(directeurs)d
FH(~)-43 b FF(u)r FN(\()r FF(u)1065 2737 y FD(x)1099
2725 y FG(,)r FF(u)1177 2737 y FD(y)1212 2725 y FG(,)r
FF(u)1287 2737 y FD(z)1322 2725 y FN(\),)13 b FH(~)-40
b FF(v)q FN(\()r FF(v)1504 2737 y FD(x)1537 2725 y FG(,)r
FF(v)1606 2737 y FD(y)1639 2725 y FG(,)r FF(v)1705 2737
y FD(z)1738 2725 y FN(\))22 b(donn\351s)n(.)f(Alors)g(:)671
2885 y FF(M)t FN(\()s FF(x)q FG(,)7 b FF(y)p FG(,)t FF(z)r
FN(\))15 b FC(2)i FF(d)668 2965 y FC(\241)-17 b(\241)g(!)674
3022 y FF(A)6 b(M)35 b FN(et)16 b FH(~)-43 b FF(u)23
b FN(sont)f(colin\351aires)668 3146 y FC(9)15 b FI(\270)g
FC(2)f Fk(R)g FC(j)947 3090 y(\241)-17 b(\241)g(!)953
3146 y FF(A)6 b(M)27 b FC(\306)15 b FI(\270)10 b FC(\242)5
b FH(~)-43 b FF(u)668 3362 y FC(9)15 b FI(\270)g FC(2)f
Fk(R)g FC(j)956 3203 y Fo(8)956 3272 y(<)956 3410 y(:)1064
3261 y FF(x)g FC(\306)k FF(x)1233 3275 y FD(A)1291 3261
y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1499 3273 y FD(x)1068
3361 y FF(y)i FC(\306)21 b FF(y)1237 3375 y FD(A)1295
3361 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1506 3373
y FD(y)1065 3460 y FF(z)j FC(\306)j FF(z)1230 3474 y
FD(A)1289 3460 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1497
3472 y FD(z)1532 3460 y FG(.)2422 2875 y FF(M)t FN(\()s
FF(x)q FG(,)7 b FF(y)p FG(,)t FF(z)r FN(\))14 b FC(2)h
FI(\274)2419 2956 y FC(\241)-18 b(\241)h(!)2425 3012
y FF(A)6 b(M)12 b FN(,)17 b FH(~)-43 b FF(u)24 b FN(et)13
b FH(~)-40 b FF(v)22 b FN(sont)f(coplanaires)2419 3150
y FC(9)14 b FI(\270)p FG(,)p FI(\271)h FC(2)g Fk(R)f
FC(j)2767 3093 y(\241)-17 b(\241)g(!)2773 3150 y FF(A)6
b(M)27 b FC(\306)14 b FI(\270)c FC(\242)5 b FH(~)-43
b FF(u)14 b FC(\305)c FI(\271)g FC(\242)r FH(~)-40 b
FF(v)2419 3372 y FC(9)14 b FI(\270)p FG(,)p FI(\271)h
FC(2)g Fk(R)f FC(j)2775 3213 y Fo(8)2775 3282 y(<)2775
3419 y(:)2883 3271 y FF(x)h FC(\306)i FF(x)3052 3285
y FD(A)3111 3271 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)3319
3283 y FD(x)3365 3271 y FC(\305)e FI(\271)g FC(\242)i
FF(v)3564 3283 y FD(x)2887 3370 y FF(y)j FC(\306)21 b
FF(y)3057 3384 y FD(A)3115 3370 y FC(\305)10 b FI(\270)g
FC(\242)i FF(u)3326 3382 y FD(y)3371 3370 y FC(\305)e
FI(\271)g FC(\242)i FF(v)3573 3382 y FD(y)2884 3470 y
FF(z)k FC(\306)i FF(z)3050 3484 y FD(A)3109 3470 y FC(\305)10
b FI(\270)g FC(\242)i FF(u)3317 3482 y FD(z)3362 3470
y FC(\305)e FI(\271)g FC(\242)i FF(v)3561 3482 y FD(z)3594
3470 y FG(.)109 3655 y FN(Ce)20 b(syst\350me)h(est)g(appel\351)g
Fh(repr\351sentation)j(param\351trique)f(de)h FF(d)i
FN(\(resp)o(.)21 b FI(\274)p FN(\).)109 3680 y
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 3680
a 109 3680 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 3680 a 0 TeXcolorgray 166 3819 a FN(Ci-dessous)n(,)g
(les)g(syst\350mes)f(d'\351quations)h(param\351triques)g(d'une)h
(droite)i FF(d)h FN(et)c(d'un)h(plan)g FI(\274)698 4023
y FF(d)c FC(\264)832 3864 y Fo(8)832 3933 y(<)832 4070
y(:)940 3922 y FF(x)d FC(\306)i FF(x)1109 3936 y FD(A)1168
3922 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1376 3934
y FD(x)944 4021 y FF(y)j FC(\306)21 b FF(y)1114 4035
y FD(A)1172 4021 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1383
4033 y FD(y)941 4121 y FF(z)k FC(\306)i FF(z)1107 4135
y FD(A)1166 4121 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)1374
4133 y FD(z)1408 4121 y FG(.)2438 4023 y FI(\274)i FC(\264)2570
3864 y Fo(8)2570 3933 y(<)2570 4070 y(:)2678 3922 y FF(x)h
FC(\306)i FF(x)2847 3936 y FD(A)2906 3922 y FC(\305)10
b FI(\270)g FC(\242)i FF(u)3114 3934 y FD(x)3160 3922
y FC(\305)e FI(\271)g FC(\242)i FF(v)3359 3934 y FD(x)2682
4021 y FF(y)i FC(\306)22 b FF(y)2852 4035 y FD(A)2910
4021 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)3121 4033
y FD(y)3166 4021 y FC(\305)e FI(\271)g FC(\242)i FF(v)3368
4033 y FD(y)2679 4121 y FF(z)k FC(\306)i FF(z)2845 4135
y FD(A)2903 4121 y FC(\305)10 b FI(\270)g FC(\242)i FF(u)3111
4133 y FD(z)3157 4121 y FC(\305)e FI(\271)g FC(\242)i
FF(v)3356 4133 y FD(z)3389 4121 y FG(.)p 0 TeXcolorgray
138 3712 3747 4 v 138 4177 4 467 v 3881 4177 V 138 4179
3747 4 v 3883 4212 35 471 v 171 4212 3747 35 v 109 3680
a
tx@Dict begin  PutEnd  end
 109 3680 a 109 3680 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 3680 a 109 3680 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 3680
a 0 TeXcolorgray 163 3789 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(D\351\002nition)p 0 TeXcolorgray 109
3680 a
tx@Dict begin  PutEnd  end
 109 3680 a 868 x FC(})45 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17
b FN(:)60 b(La)22 b(coordonn\351e)f(du)h(vecteur)g(directeur)17
b FH(~)-43 b FF(u)24 b FN(de)d(la)h(droite)i FF(d)18
b FC(\264)2513 4388 y Fo(8)2513 4457 y(<)2513 4595 y(:)2621
4446 y FF(x)d FC(\306)f FI(\270)2625 4546 y FF(y)g FC(\306)g(\241)p
FN(1)c FC(\305)g FN(2)p FI(\270)2622 4646 y FF(z)16 b
FC(\306)e FN(5)c FC(\241)g FN(3)p FI(\270)595 4743 y
FN(est)21 b FH(~)-43 b FF(u)s FN(\(1)26 b(;)35 b(2)26
b(;)35 b FC(\241)p FN(3\).)27 b(Un)f(point)h(d'ancrage)g(\351vident)g
(est)32 b FF(A)s FN(\(0)27 b(;)35 b FC(\241)p FN(1)26
b(;)35 b(5\).)27 b(P)m(ar)g(ailleurs)n(,)h(le)f(point)596
4843 y FF(B)r FN(\(2)21 b(;)30 b(3)21 b(;)30 b FC(\241)p
FN(1\))21 b(appartient)i(aussi)e(\340)g(cette)g(droite)13
b(!)22 b(\(le)f(justi\002er\))109 5017 y FC(})45 b Fi(E)t
Fj(X)t(E)t(M)t(P)t(L)t(E)17 b FN(:)60 b(Les)22 b(repr\351sentations)f
(param\351triques)g(suivantes)h(d\351\002nissent)f(le)g(m\352me)f(plan)
i(:)p 0 TeXcolorgray 0 TeXcolorgray 1288 5278 a FI(\274)14
b FC(\264)1420 5119 y Fo(8)1420 5188 y(<)1420 5325 y(:)1528
5177 y FF(x)h FC(\306)f FN(2)c FC(\305)g FI(\270)g FC(\305)g
FN(2)p FI(\271)1532 5277 y FF(y)k FC(\306)g FN(2)c FC(\305)g
FN(2)p FI(\270)g FC(\305)g FI(\271)1529 5376 y FF(z)15
b FC(\306)g FN(1)10 b FC(\241)g FI(\270)g FC(\241)g FI(\271)2060
5278 y FN(et)21 b FI(\274)2199 5248 y Fw(0)2234 5278
y FC(\264)2303 5119 y Fo(8)2303 5188 y(<)2303 5325 y(:)2411
5177 y FF(x)15 b FC(\306)f FN(1)c FC(\305)g FN(3)p FI(\256)g
FC(\241)g FI(\257)2415 5277 y FF(y)15 b FC(\306)f FN(3)c
FC(\305)g FN(3)p FI(\256)g FC(\305)g FI(\257)2412 5376
y FF(z)16 b FC(\306)e FN(1)c FC(\241)g FN(2)p FI(\256)595
5537 y FN(Il)21 b(suf\002t)e(de)g(v\351ri\002er)i(que)e(trois)h(points)
f(appartenant)i(au)e(premier)h(plan)g(se)f(situent)h(\351galement)595
5637 y(dans)i(le)f(second)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 10 10
TeXDict begin 10 9 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.10) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(10)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (section.2.5) cvn /DEST pdfmark
end
 -128 -121 a 0.93 0.26 0 TeXcolorrgb 109 x FK(2.5)111
b(\311quations)33 b(cart\351siennes)e(de)g(l'espace)p
0 TeXcolorgray -128 94 a
SDict begin H.S end
 -128 94 a -128 94 a
SDict begin 12 H.A end
 -128 94
a -128 94 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.5.1) cvn /DEST pdfmark
end
 -128 94 a 0.932 0.464 0 TeXcolorrgb 93 x
FJ(2.5.1)93 b(\311quation)28 b(d'un)g(plan)p 0 TeXcolorgray
-128 269 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 269 a -128 269 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 269 a 0 TeXcolorgray
0 TeXcolorgray -70 408 a FN(\226)p 0 TeXcolorgray 41
w(Un)22 b(plan)g(de)g(l'espace)f(a)g(une)g(\351quation)h
(cart\351sienne)f(de)g(la)h(forme)1484 526 y FF(a)s(x)11
b FC(\305)h FF(b)c(y)i FC(\305)k FF(c)5 b(z)12 b FC(\305)g
FF(d)22 b FC(\306)14 b FN(0)14 643 y(a)o(vec)24 b FF(a)p
FN(,)h FF(b)f FN(et)h FF(c)e FN(des)f(r\351els)f(non)g(tous)g(nuls)n(.)
p 0 TeXcolorgray -70 743 a(\226)p 0 TeXcolorgray 41 w
(R\351ciproquement,)26 b(toute)e(\351quation)h(de)h(la)f(forme)h
FF(a)s(x)12 b FC(\305)h FF(b)8 b(y)14 b FC(\305)h FF(c)5
b(z)13 b FC(\305)g FF(d)23 b FC(\306)17 b FN(0,)26 b(o\371)f(l'un)h(au)
f(moins)g(des)g(r\351els)i FF(a)p FN(,)h FF(b)g FN(et)h
FF(c)14 843 y FN(n'est)21 b(pas)h(nul,)g(est)f(une)h(\351quation)f
(cart\351sienne)g(d'un)h(plan.)p 0 TeXcolorgray -98 301
3747 4 v -98 885 4 586 v 3645 885 V -98 887 3747 4 v
3646 920 35 590 v -65 920 3747 35 v -128 269 a
tx@Dict begin  PutEnd  end
 -128 269
a -128 269 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 269 a -128 269 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 269 a 0 TeXcolorgray
-73 378 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p
0 TeXcolorgray -128 269 a
tx@Dict begin  PutEnd  end
 -128 269 a 0.094 0.455 0.804
TeXcolorrgb -128 1242 a
SDict begin H.S end
 -128 1242 a -128 1242 a
SDict begin 12 H.A end
 -128
1242 a -128 1242 a
SDict begin [/View [/XYZ H.V]/Dest (section*.16) cvn /DEST pdfmark
end
 -128 1242 a FP(Plans)g(particuliers)p
0 TeXcolorgray -128 1396 a FN(Un)d(plan)h(admettant)f(une)f
(\351quation)h(\253)c(incompl\350te)g(\273,)k(c'est)f(\340)h(dire)h
(dans)f(laquelle)g(ne)f(\002gure)i(qu'une)e(ou)h(deux)g(des)g(trois)
-128 1495 y(variables)25 b FF(x)q FN(,)k FF(y)22 b FN(et)j
FF(z)r FN(,)c(est)g(parall\350le)h(\340)g(un)f(plan)i(de)e
(coordonn\351es)f(ou)i(\340)f(un)h(axe)f(de)h(coordonn\351es)n(.)-128
1595 y FC(})46 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17 b
FN(:)p 0 TeXcolorgray 60 w(\226)p 0 TeXcolorgray 42 w(le)k(plan)h(\()s
FF(x)q(O)9 b(y)p FN(\))21 b(admet)k FF(z)16 b FC(\306)e
FN(0)22 b(comme)e(\351quation)h(cart\351sienne)13 b(;)p
0 TeXcolorgray 359 1695 a(\226)p 0 TeXcolorgray 42 w(le)21
b(plan)h(\()t FF(z)r(O)9 b(y)p FN(\))21 b(admet)j FF(x)15
b FC(\306)f FN(0)22 b(comme)e(\351quation)h(cart\351sienne)13
b(;)p 0 TeXcolorgray 359 1794 a(\226)p 0 TeXcolorgray
42 w(Le)21 b(plan)h(\()s FF(x)q(O)6 b(z)r FN(\))21 b(admet)28
b FF(y)14 b FC(\306)h FN(0)21 b(comme)f(\351quation)h(cart\351sienne)o
(.)-128 1918 y FC(})46 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17
b FN(:)p 0 TeXcolorgray 60 w(\226)p 0 TeXcolorgray 42
w(tout)k(plan)h(parall\350le)g(\340)g(\()s FF(x)q(O)9
b(y)p FN(\))21 b(admet)k FF(z)16 b FC(\306)g FF(d)25
b FN(comme)c(\351quation)g(cart\351sienne)12 b(;)p 0
TeXcolorgray 359 2018 a(\226)p 0 TeXcolorgray 42 w(tout)21
b(plan)h(parall\350le)g(\340)g(\()t FF(z)r(O)9 b(y)p
FN(\))21 b(admet)j FF(x)15 b FC(\306)h FF(d)25 b FN(comme)c
(\351quation)g(cart\351sienne)12 b(;)p 0 TeXcolorgray
359 2117 a(\226)p 0 TeXcolorgray 42 w(tout)21 b(plan)h(parall\350le)g
(\340)g(\()s FF(x)q(O)6 b(z)r FN(\))20 b(admet)28 b FF(y)15
b FC(\306)h FF(d)25 b FN(comme)c(\351quation)g(cart\351sienne)o(.)-128
2241 y FC(})46 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17 b
FN(:)p 0 TeXcolorgray 60 w(\226)p 0 TeXcolorgray 42 w(tout)k(plan)h
(parall\350le)g(\340)g(\()p FF(O)5 b(x)q FN(\))21 b(admet)g(pour)h
(\351quation)h FF(b)8 b(y)i FC(\305)k FF(c)5 b(z)18 b
FC(\306)e FF(d)26 b FN(a)o(vec)c(\()r FF(b)9 b FN(;)21
b FF(c)q FN(\))15 b FC(6\306)g FN(\(0)8 b(;)16 b(0\))p
0 TeXcolorgray 359 2341 a(\226)p 0 TeXcolorgray 42 w(tout)21
b(plan)h(parall\350le)g(\340)g(\()p FF(O)9 b(y)p FN(\))21
b(admet)g(pour)h(\351quation)h FF(a)s(x)11 b FC(\305)j
FF(c)5 b(z)18 b FC(\306)e FF(d)26 b FN(a)o(vec)21 b(\()r
FF(a)8 b FN(;)22 b FF(c)q FN(\))15 b FC(6\306)f FN(\(0)8
b(;)16 b(0\))p 0 TeXcolorgray 359 2441 a(\226)p 0 TeXcolorgray
42 w(tout)21 b(plan)h(parall\350le)g(\340)g(\()p FF(O)6
b(z)r FN(\))21 b(admet)g(pour)g(\351quation)j FF(a)s(x)11
b FC(\305)h FF(b)c(y)16 b FC(\306)g FF(d)25 b FN(a)o(vec)d(\()r
FF(a)8 b FN(;)20 b FF(b)q FN(\))15 b FC(6\306)f FN(\(0)8
b(;)16 b(0\))p -128 2713 3993 4 v -128 2812 4 100 v 150
2782 a Fg(Plan)k Ff(\274)f Fg(d'\351quation)j Fd(x)13
b Fc(\306)i Fd(k)p 1166 2812 V 552 w Fg(Plan)k Ff(\274)h
Fg(d'\351quation)26 b Fd(y)12 b Fc(\306)j Fd(k)p 2459
2812 V 607 w Fg(Plan)k Ff(\274)g Fg(d'\351quation)k Fd(z)15
b Fc(\306)g Fd(k)p 3861 2812 V -128 3799 4 987 v -64
3769 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 140.84015 a add def
/d 0.0 a add neg def /h 115.23283 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 -64 3769 a 414 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 6 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 0
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 10 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 t
0 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 6 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 10
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 10 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 t
6 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  
1  setlinejoin 0  setlinecap stroke  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 6 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 4 0 t tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 10 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 4 t 0 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 414 3535 a 414 3535
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535 a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 414 3535 a 398 3551 a Fd(x)414
3535 y
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 414
3535 a 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 414 3535 a 400
3544 a Fd(y)414 3535 y
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535
a 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 414 3535 a 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535
a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 414 3535 a 399 3551 a Fd(z)414 3535 y
tx@Dict begin  PutEnd  end
 414 3535 a 414
3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 414 3535 a 414 3535
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 414 3535 a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535
a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 414 3535 a 414 3535
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 414 3535 a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535
a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 414 3535 a 414 3535
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 3535 a 414 3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 414 3535 a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535
a 414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 3535 a 391 3556
a Fs(O)414 3535 y
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 3535 a 1 0 0
TeXcolorrgb 392 3551 a Fq(~)404 3566 y Fp(i)p 0 TeXcolorgray
414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 3535 a 1 0 0
TeXcolorrgb 394 3545 a Fq(~)408 3560 y Fp(j)p 0 TeXcolorgray
414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 414 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 3535 a 1 0 0
TeXcolorrgb 389 3550 a Fq(~)397 3566 y Fp(k)p 0 TeXcolorgray
414 3535 a
tx@Dict begin  PutEnd  end
 414 3535 a 1105 3769 a
currentpoint initclip moveto
 1105 3769 a 1166 3799
4 987 v 1229 3769 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 140.84015 a add def
/d 0.0 a add neg def /h 115.23283 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1229 3769 a 1708 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 6 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 8 6
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 8 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 6
0 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 6 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 0 6
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 8 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 6
6 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  
1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 8 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { t 6 0 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 6 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 0 6 t tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708
3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 3535
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1708 3535 a 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 3535 a 1708
3535 a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 1708 3535 a 1692 3551 a Fd(x)1708 3535 y
tx@Dict begin  PutEnd  end
 1708
3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1708 3535
a 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 3535 a 1708 3535 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 1708 3535 a 1694
3544 a Fd(y)1708 3535 y
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708
3535 a 1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1708 3535 a 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 3535
a 1708 3535 a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 1708 3535 a 1693 3551 a Fd(z)1708 3535
y
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708
3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 1708 3535
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1708 3535 a 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 3535 a 1708
3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1708 3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535
a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1708 3535 a 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708
3535 a 1708 3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1708 3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535
a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1708 3535 a 1708
3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 3535 a 1708 3535 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1708 3535 a 1708 3535
a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708
3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 1708 3535
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 3535 a 1685 3556 a Fs(O)1708 3535 y
tx@Dict begin  PutEnd  end
 1708 3535
a 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial
1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 3535 a 1 0 0 TeXcolorrgb 1686 3551 a
Fq(~)1698 3566 y Fp(i)p 0 TeXcolorgray 1708 3535 a
tx@Dict begin  PutEnd  end
 1708
3535 a 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 3535 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end


@endspecial 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 3535 a 1 0 0 TeXcolorrgb
1688 3545 a Fq(~)1702 3560 y Fp(j)p 0 TeXcolorgray 1708
3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 1708 3535 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 3535 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 1708 3535 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 3535 a 1 0 0
TeXcolorrgb 1683 3550 a Fq(~)1691 3566 y Fp(k)p 0 TeXcolorgray
1708 3535 a
tx@Dict begin  PutEnd  end
 1708 3535 a 2399 3769 a
currentpoint initclip moveto
 2399 3769 a 2459
3799 4 987 v 2577 3769 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 140.84015 a add def
/d 0.0 a add neg def /h 112.67215 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2577 3769 a 3056 3556 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 6.5 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 0
4.5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 8.5 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 6.5
t 4.5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D
12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped {
moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat   0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load
stopped { moveto } if } def /ArrowB { } def /ArrowInside { } def  
/RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec
1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0
def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha
45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1
Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2
Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul
def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 6.5 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 8.5
4.5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 8.5 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 0 t
4.5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  
1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 8.5 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 0 t 4.5 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 6.5 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub
div }{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /xyz { t 0 4.5 tx@3DPlotDict begin saveCoor
ConvertTo2D x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin
def xyz moveto  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat  gsave 1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056
3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3056 3556
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 3056 3556 a 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056 3556 a 3056
3556 a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 3056 3556 a 3040 3572 a Fd(x)3056 3556 y
tx@Dict begin  PutEnd  end
 3056
3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 3056 3556
a 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056 3556 a 3056 3556 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 3056 3556 a 3042
3565 a Fd(y)3056 3556 y
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056
3556 a 3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 3056 3556 a 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056 3556
a 3056 3556 a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 3056 3556 a 3041 3572 a Fd(z)3056 3556
y
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056
3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial 3056 3556
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 3056 3556 a 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056 3556 a 3056
3556 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 3056 3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556
a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 3056 3556 a 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056
3556 a 3056 3556 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 3056 3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556
a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 3056 3556 a 3056
3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3056 3556 a 3056 3556 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 3056 3556 a 3056 3556
a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3056
3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 3056 3556
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3056 3556 a 3033 3577 a Fs(O)3056 3556 y
tx@Dict begin  PutEnd  end
 3056 3556
a 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial
3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3056 3556 a 1 0 0 TeXcolorrgb 3034 3572 a
Fq(~)3046 3587 y Fp(i)p 0 TeXcolorgray 3056 3556 a
tx@Dict begin  PutEnd  end
 3056
3556 a 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3056 3556 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end


@endspecial 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3056 3556 a 1 0 0 TeXcolorrgb
3036 3566 a Fq(~)3050 3581 y Fp(j)p 0 TeXcolorgray 3056
3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3056 3556 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3056 3556 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 3056 3556 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3056 3556 a 1 0 0
TeXcolorrgb 3031 3572 a Fq(~)3039 3588 y Fp(k)p 0 TeXcolorgray
3056 3556 a
tx@Dict begin  PutEnd  end
 3056 3556 a 3746 3769 a
currentpoint initclip moveto
 3746 3769 a 3861
3799 4 987 v -128 3899 4 100 v 390 3869 a Ff(\274)p Fg(//\()7
b Fd(y)p Fg(O)t Fd(z)r Fg(\))p 1166 3899 V 1033 w Ff(\274)p
Fg(//\()s Fd(x)q Fg(O)t Fd(z)r Fg(\))p 2459 3899 V 1086
w Ff(\274)p Fg(//\()s Fd(x)q Fg(O)g Fd(y)p Fg(\))p 3861
3899 V -128 3902 3993 4 v -128 4002 4 100 v 50 3972 a(Plan)20
b Ff(\274)f Fg(d'\351quation)h Fd(a)t(x)10 b Fc(\305)h
Fd(b)d(y)13 b Fc(\306)i Fd(d)p 1166 4002 V 362 w Fg(Plan)20
b Ff(\274)f Fg(d'\351quation)h Fd(a)t(x)10 b Fc(\305)j
Fd(c)5 b(z)14 b Fc(\306)i Fd(d)p 2459 4002 V 419 w Fg(Plan)k
Ff(\274)f Fg(d'\351quation)i Fd(b)8 b(y)h Fc(\305)k Fd(c)5
b(z)15 b Fc(\306)g Fd(d)p 3861 4002 V -128 4988 4 987
v -64 4958 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 140.84015 a add def
/d 0.0 a add neg def /h 115.23283 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 -64 4958 a 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 6 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 0
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 4 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t -1.625
t mul 6.5 add 0 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat   0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load
stopped { moveto } if } def /ArrowB { } def /ArrowInside { } def  
/RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec
1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0
def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha
45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1
Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2
Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul
def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 6 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 0 6.5
t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 4 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t -1.625
t mul 6.5 add 6 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat  gsave 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill
 grestore gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 6 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 6 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 4 0 t tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 6 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 4 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { t -1.625 t mul 6.5 add 0 tx@3DPlotDict begin
saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365 mul end } def  1
{ /t tMin def xyz moveto  /t t dt add def 2 1 sub { xyz  dup 1.e30
12.80365 mul gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{
L } ifelse } ifelse  /t t dt add def } repeat /t t dt sub def /u u
du add def } repeat  gsave 1.0 SLW 0.545 0.536 0.44  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 6 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 0 6.5 t tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 414 4724 a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 4724 a 414 4724
a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 414 4724 a 398 4740 a Fd(x)414 4724 y
tx@Dict begin  PutEnd  end
 414 4724 a 414
4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 414 4724 a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414
4724 a 414 4724 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 414 4724 a 400 4733 a Fd(y)414 4724
y
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 414 4724
a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 4724 a 414 4724 a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 414 4724 a 399 4740
a Fd(z)414 4724 y
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414
4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 414 4724 a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 4724 a 414 4724
a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724
a 414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 414 4724 a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 4724 a 414 4724
a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724
a 414 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 414 4724 a 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 414 4724 a 414 4724
a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin  PutEnd  end
 414 4724
a 414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial
414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 4724 a 391 4745 a Fs(O)414 4724 y
tx@Dict begin  PutEnd  end
 414
4724 a 414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end


@endspecial 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 4724 a 1 0 0 TeXcolorrgb
392 4740 a Fq(~)404 4755 y Fp(i)p 0 TeXcolorgray 414
4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 4724 a 1 0 0
TeXcolorrgb 394 4734 a Fq(~)408 4749 y Fp(j)p 0 TeXcolorgray
414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 414 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 414 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 414 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 414 4724 a 1 0 0
TeXcolorrgb 389 4740 a Fq(~)397 4756 y Fp(k)p 0 TeXcolorgray
414 4724 a
tx@Dict begin  PutEnd  end
 414 4724 a 1105 4958 a
currentpoint initclip moveto
 1105 4958 a 1166 4988
4 987 v 1229 4958 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 140.84015 a add def
/d 0.0 a add neg def /h 115.23283 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1229 4958 a 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 4 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 0
-1.25 t mul 5 add tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat   0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load
stopped { moveto } if } def /ArrowB { } def /ArrowInside { } def  
/RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec
1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0
def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha
45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1
Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2
Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul
def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 8 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 4 t
0 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 4 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 8
-1.25 t mul 5 add tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat   0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load
stopped { moveto } if } def /ArrowB { } def /ArrowInside { } def  
/RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec
1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0
def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha
45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1
Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2
Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul
def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 8 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 0 t
5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill  grestore
gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  
1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 4 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { t 0 -1.25 t mul 5 add tx@3DPlotDict begin
saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365 mul end } def  1
{ /t tMin def xyz moveto  /t t dt add def 2 1 sub { xyz  dup 1.e30
12.80365 mul gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{
L } ifelse } ifelse  /t t dt add def } repeat /t t dt sub def /u u
du add def } repeat  gsave 1.0 SLW 0.545 0.536 0.44  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 8 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 4 t 0 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 8 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 0 t 5 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1708 4724 a 1708
4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 4724 a 1708 4724 a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 1708 4724 a 1692 4740
a Fd(x)1708 4724 y
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724
a 1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1708 4724 a 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 4724 a 1708
4724 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 1708 4724 a 1694 4733 a Fd(y)1708 4724 y
tx@Dict begin  PutEnd  end
 1708
4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1708 4724
a 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 4724 a 1708 4724 a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 1708 4724 a 1693
4740 a Fd(z)1708 4724 y
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708
4724 a 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1708 4724 a 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 4724 a 1708
4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1708 4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724
a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1708 4724 a 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708
4724 a 1708 4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1708 4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724
a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1708 4724 a 1708
4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1708 4724 a 1708 4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1708 4724 a 1708 4724
a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708
4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 1708 4724
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 4724 a 1685 4745 a Fs(O)1708 4724 y
tx@Dict begin  PutEnd  end
 1708 4724
a 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial
1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 4724 a 1 0 0 TeXcolorrgb 1686 4740 a
Fq(~)1698 4755 y Fp(i)p 0 TeXcolorgray 1708 4724 a
tx@Dict begin  PutEnd  end
 1708
4724 a 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end


@endspecial 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 4724 a 1 0 0 TeXcolorrgb
1688 4734 a Fq(~)1702 4749 y Fp(j)p 0 TeXcolorgray 1708
4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 1708 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1708 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 1708 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1708 4724 a 1 0 0
TeXcolorrgb 1683 4740 a Fq(~)1691 4756 y Fp(k)p 0 TeXcolorgray
1708 4724 a
tx@Dict begin  PutEnd  end
 1708 4724 a 2399 4958 a
currentpoint initclip moveto
 2399 4958 a 2459
4988 4 987 v 2561 4958 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 144.68127 a add def
/d 0.0 a add neg def /h 115.23283 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2561 4958 a 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0.932 0.912 0.75  setrgbcolor 
 0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped
{ moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0.
 def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 7 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 0
5 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 5 def /t tMin def /t1 0 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 0 -1.3
t mul 6.5 add t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat   0.5 SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load
stopped { moveto } if } def /ArrowB { } def /ArrowInside { } def  
/RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec
1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0
def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha
45.  def /Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1
Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2
Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul
def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 7 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { t 6.5
0 tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365
mul end } def  1 { /t tMin def xyz /lineto load stopped { moveto }
if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat   0.5
SLW 0.932 0.912 0.75  setrgbcolor  /ArrowA { /lineto load stopped {
moveto } if } def /ArrowB { } def /ArrowInside { } def   /RotX 0. 
def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def
/yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit
1.0 def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def
/Beta 12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos
def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1
Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def
/showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /tMin 0 def /t tMin def /t1 5 def /u 0 def /u1 0 def
/dt t1 t sub 2 dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /du u1
u sub 1  dup 1 gt { 1 sub div }{ pop pop 0 } ifelse def /xyz { 7 -1.3
t mul 6.5 add t tx@3DPlotDict begin saveCoor ConvertTo2D x2D 12.80365
mul y2D 12.80365 mul end } def  1 { /t tMin def xyz /lineto load stopped
{ moveto } if  /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul
gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse }
ifelse  /t t dt add def } repeat /t t dt sub def /u u du add def }
repeat  gsave 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha  fill
 grestore gsave 0.5 SLW 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 7 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { t 0 5 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 5 def /t tMin
def /t1 0 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { 0 -1.3 t mul 6.5 add t tx@3DPlotDict begin
saveCoor ConvertTo2D x2D 12.80365 mul y2D 12.80365 mul end } def  1
{ /t tMin def xyz moveto  /t t dt add def 2 1 sub { xyz  dup 1.e30
12.80365 mul gt { moveto }{ dup -1.e30 12.80365 mul lt { moveto }{
L } ifelse } ifelse  /t t dt add def } repeat /t t dt sub def /u u
du add def } repeat  gsave 1.0 SLW 0.545 0.536 0.44  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /tMin 0 def /t tMin
def /t1 7 def /u 0 def /u1 0 def /dt t1 t sub 2 dup 1 gt { 1 sub div
}{ pop pop 0 } ifelse def /du u1 u sub 1  dup 1 gt { 1 sub div }{ pop
pop 0 } ifelse def /xyz { t 6.5 0 tx@3DPlotDict begin saveCoor ConvertTo2D
x2D 12.80365 mul y2D 12.80365 mul end } def  1 { /t tMin def xyz moveto
 /t t dt add def 2 1 sub { xyz  dup 1.e30 12.80365 mul gt { moveto
}{ dup -1.e30 12.80365 mul lt { moveto }{ L } ifelse } ifelse  /t t
dt add def } repeat /t t dt sub def /u u du add def } repeat  gsave
1.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 3071 4724 a 3071
4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071 4724 a 3071 4724 a
tx@Dict begin { 5.0 4.635 3.98248 0.135 180.  Uput UUput } PutCoor
PutBegin  end
 3071 4724 a 3055 4740
a Fd(x)3071 4724 y
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724
a 3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 3071 4724 a 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071 4724 a 3071
4724 a
tx@Dict begin { 5.0 4.99498 3.98248 1.719 0.  Uput UUput } PutCoor
PutBegin  end
 3071 4724 a 3057 4733 a Fd(y)3071 4724 y
tx@Dict begin  PutEnd  end
 3071
4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 3071 4724
a 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071 4724 a 3071 4724 a
tx@Dict begin { 5.0 4.50899 3.98248 0.135 90.  Uput UUput } PutCoor
PutBegin  end
 3071 4724 a 3056
4740 a Fd(z)3071 4724 y
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071
4724 a 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 1 0 0  setrgbcolor  end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 3071 4724 a 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071 4724 a 3071
4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 3071 4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724
a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 3071 4724 a 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071
4724 a 3071 4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 3071 4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724
a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 3071 4724 a 3071
4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 3071 4724 a 3071 4724 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 3071 4724 a 3071 4724
a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul exch
12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3071
4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 3071 4724
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3071 4724 a 3048 4745 a Fs(O)3071 4724 y
tx@Dict begin  PutEnd  end
 3071 4724
a 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.2 -.2 .6 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial
3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3071 4724 a 1 0 0 TeXcolorrgb 3049 4740 a
Fq(~)3061 4755 y Fp(i)p 0 TeXcolorgray 3071 4724 a
tx@Dict begin  PutEnd  end
 3071
4724 a 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.2 .6 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3071 4724 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end


@endspecial 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3071 4724 a 1 0 0 TeXcolorrgb
3051 4734 a Fq(~)3065 4749 y Fp(j)p 0 TeXcolorgray 3071
4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3071 4724 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
12.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .4 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  12.80365 mul
exch 12.80365 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 3071 4724 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0.545 0.536 0.44  setrgbcolor 
end
 
@endspecial 3071 4724 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 3071 4724 a 1 0 0
TeXcolorrgb 3046 4740 a Fq(~)3054 4756 y Fp(k)p 0 TeXcolorgray
3071 4724 a
tx@Dict begin  PutEnd  end
 3071 4724 a 3762 4958 a
currentpoint initclip moveto
 3762 4958 a 3861
4988 4 987 v -128 5088 4 100 v 411 5058 a Ff(\274)p Fg(//\(O)t
Fd(z)r Fg(\))p 1166 5088 V 1071 w Ff(\274)p Fg(//\(O)7
b Fd(y)p Fg(\))p 2459 5088 V 1125 w Ff(\274)p Fg(//\(O)s
Fd(x)q Fg(\))p 3861 5088 V -128 5091 3993 4 v 0.094 0.455 0.804
TeXcolorrgb -128 5271 a
SDict begin H.S end
 -128 5271 a -128 5271 a
SDict begin 12 H.A end
 -128
5271 a -128 5271 a
SDict begin [/View [/XYZ H.V]/Dest (section*.17) cvn /DEST pdfmark
end
 -128 5271 a FP(D\351terminer)24 b(une)e(\351quation)
g(cart\351sienne)g(d'un)g(plan)p 0 TeXcolorgray -128
5350 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 5350 a -128 5350 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 5350 a 0 TeXcolorgray
-70 5523 a FN(Dans)31 b(l'espace)g(muni)h(d'un)f(rep\350re)1117
5436 y Fo(\263)1149 5523 y FN(O;)1228 5504 y FH(~)1242
5523 y FF(i)s FG(,)1286 5504 y FH(~)1303 5523 y FF(j)s
FG(,)1344 5503 y FH(~)1353 5523 y FF(k)1399 5436 y Fo(\264)1430
5523 y FN(,)h(montrer)f(que)g(les)g(points)37 b FF(A)2418
5525 y FN(\()2444 5523 y(1;)8 b(0;)g(3)2631 5525 y(\))2658
5523 y(,)33 b FF(B)2778 5525 y FN(\()2803 5523 y(1;)8
b FC(\241)p FN(1;)g(0)3045 5525 y(\))3103 5523 y(et)32
b FF(C)3271 5525 y FN(\()3296 5523 y FC(\241)p FN(1;)8
b FC(\241)p FN(2;)g(1)3593 5525 y(\))-70 5635 y(d\351\002nissent)21
b(un)h(plan)g(et)g(d\351terminer)f(une)g(\351quation)g(de)h(ce)f(plan.)
p 0 TeXcolorgray -98 5383 3747 4 v -98 5677 4 297 v 3645
5677 V -98 5679 3747 4 v 3646 5712 35 300 v -65 5712
3747 35 v -128 5350 a
tx@Dict begin  PutEnd  end
 -128 5350 a -128 5350 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 5350
a -128 5350 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 5350 a 0 TeXcolorgray -73 5404 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.0 neg 3.0
3.0 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill  grestore
end
 
@endspecial 0 TeXcolorgray -128 5350 a
tx@Dict begin  PutEnd  end
 -128
5350 a 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 11 11
TeXDict begin 11 10 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.11) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(11)p 109 -238 3780 2 v 0 TeXcolorgray 109 -33 a(Les)22
b(vecteurs)580 -90 y FC(\241)-32 b(\241)g(!)586 -33 y
FF(A)t(B)710 -31 y FN(\()736 -33 y(0;)8 b FC(\241)p FN(1;)g
FC(\241)p FN(3)1033 -31 y(\))1082 -33 y(et)1174 -90 y
FC(\241)-32 b(\241)h(!)1180 -33 y FF(A)t(C)1305 -31 y
FN(\()1331 -33 y FC(\241)p FN(2;)8 b FC(\241)p FN(2;)g
FC(\241)p FN(2)1683 -31 y(\))1732 -33 y(ne)23 b(sont)f(pas)h
(colin\351aires)g(donc)h(les)e(points)29 b FF(A)s FN(,)c
FF(B)f FN(et)f FF(C)j FN(ne)d(sont)f(pas)109 67 y(align\351s)n(,)g(ils)
g(d\351\002nissent)f(un)h(plan)g(\()6 b FF(A)t(B)s(C)s
FN(\).)109 166 y(On)21 b(peut)h(d\351terminer)f(une)h(\351quation)f
(cart\351sienne)g(du)h(plan)g(\()6 b FF(A)t(B)s(C)s FN(\))21
b(par)h(deux)g(m\351thodes)e(:)109 211 y
SDict begin H.S end
 109 211 a 109
211 a
SDict begin 12 H.A end
 109 211 a 109 211 a
SDict begin [/View [/XYZ H.V]/Dest (Item.3) cvn /DEST pdfmark end
 109 211 a 0 TeXcolorgray 98
x FP(1.)p 0 TeXcolorgray 141 w FN(Une)h(\351quation)g(cart\351sienne)g
(du)h(plan)g(\()6 b FF(A)t(B)s(C)s FN(\))21 b(est)g(de)g(la)h(forme)
1828 426 y FF(a)s(x)11 b FC(\305)h FF(b)c(y)i FC(\305)k
FF(c)5 b(z)19 b FC(\306)d FF(d)315 544 y FN(o\371)23
b FF(a)p FN(,)i FF(b)q FN(,)i FF(c)c FN(et)g FF(d)j FN(sont)21
b(des)g(r\351els)n(.)p 0 TeXcolorgray 0 TeXcolorgray
976 694 a FF(A)1041 696 y FN(\()1067 694 y(1;)8 b(0;)g(3)1254
696 y(\))1295 694 y FC(2)15 b FN(\()6 b FF(A)t(B)s(C)s
FN(\))205 b FC(\()-12 b(\))279 b FF(a)10 b FC(\305)g
FN(3)t FF(c)15 b FC(\306)k FF(d)971 793 y(B)1037 795
y FN(\()1062 793 y(1;)8 b FC(\241)p FN(1;)g(0)1304 795
y(\))1345 793 y FC(2)15 b FN(\()6 b FF(A)t(B)s(C)s FN(\))155
b FC(\()-12 b(\))315 b FF(a)10 b FC(\241)i FF(b)j FC(\306)k
FF(d)971 893 y(C)1038 895 y FN(\()1064 893 y FC(\241)p
FN(1;)8 b FC(\241)p FN(2;)g(1)1361 895 y(\))1402 893
y FC(2)14 b FN(\()6 b FF(A)t(B)s(C)s FN(\))99 b FC(\()-12
b(\))100 b(\241)r FF(a)10 b FC(\241)g FN(2)r FF(b)h FC(\305)j
FF(c)h FC(\306)20 b FF(d)315 1045 y FN(Ainsi,)k FF(a)p
FN(,)h FF(b)e FN(et)i FF(c)f FN(sont)d(solutions)g(du)h(syst\350me)e(:)
998 1170 y Fo(8)998 1239 y(<)998 1376 y(:)1282 1228 y
FF(a)10 b FC(\305)g FN(3)t FF(c)86 b FC(\306)f FF(d)1318
1328 y(a)10 b FC(\241)i FF(b)86 b FC(\306)f FF(d)1103
1427 y FC(\241)r FF(a)10 b FC(\241)g FN(2)r FF(b)h FC(\305)j
FF(c)87 b FC(\306)e FF(d)1825 1329 y FC(,)1916 1101 y
Fo(8)1916 1170 y(>)1916 1193 y(>)1916 1216 y(>)1916 1239
y(<)1916 1376 y(>)1916 1399 y(>)1916 1422 y(>)1916 1445
y(:)2701 1200 y FF(c)g FC(\306)2970 1144 y FF(d)13 b
FC(\241)f FF(a)p 2968 1181 176 5 v 3034 1257 a FN(3)2692
1328 y FF(b)85 b FC(\306)g FF(a)10 b FC(\241)i FF(d)2021
1470 y FC(\241)r FF(a)e FC(\241)g FN(2\()r FF(a)g FC(\241)i
FF(d)s FN(\))e FC(\305)2554 1414 y FF(d)j FC(\241)f FF(a)p
2552 1451 V 2618 1527 a FN(3)2820 1470 y FC(\306)85 b
FF(d)1825 1803 y FC(,)1916 1575 y Fo(8)1916 1644 y(>)1916
1667 y(>)1916 1690 y(>)1916 1713 y(<)1916 1850 y(>)1916
1873 y(>)1916 1896 y(>)1916 1919 y(:)2192 1674 y FF(c)g
FC(\306)2461 1618 y FF(d)13 b FC(\241)f FF(a)p 2459 1655
V 2525 1731 a FN(3)2183 1801 y FF(b)85 b FC(\306)g FF(a)10
b FC(\241)i FF(d)2021 1944 y FC(\241)2086 1888 y FN(10)r
FF(a)p 2086 1925 133 5 v 2130 2001 a FN(3)2311 1944 y
FC(\306)83 b(\241)2514 1888 y FN(4)r FF(d)p 2514 1925
96 5 v 2541 2001 a FN(3)1825 2312 y FC(,)1916 2039 y
Fo(8)1916 2108 y(>)1916 2131 y(>)1916 2153 y(>)1916 2176
y(>)1916 2199 y(>)1916 2222 y(<)1916 2360 y(>)1916 2383
y(>)1916 2405 y(>)1916 2428 y(>)1916 2451 y(>)1916 2474
y(:)2032 2148 y FF(c)i FC(\306)2301 2092 y FF(d)p 2299
2129 53 5 v 2304 2205 a FN(5)2023 2318 y FF(b)g FC(\306)e(\241)2354
2262 y FN(3)r FF(d)p 2354 2299 96 5 v 2380 2375 a FN(5)2023
2489 y FF(a)h FC(\306)2299 2433 y FN(2)r FF(d)p 2299
2470 V 2325 2546 a FN(5)315 2629 y(En)21 b(c)o(hoisissant,)j
FF(d)19 b FC(\306)14 b FN(5)21 b(on)g(obtient)j FF(a)15
b FC(\306)f FN(2,)24 b FF(b)15 b FC(\306)g(\241)p FN(3)21
b(et)26 b FF(c)15 b FC(\306)g FN(1)21 b(donc)h(le)g(plan)g(\()6
b FF(A)t(B)s(C)s FN(\))20 b(a)i(pour)g(\351quation)1855
2747 y(2)s FF(x)11 b FC(\241)f FN(3)d FF(y)j FC(\305)k
FF(z)i FC(\306)e FN(5)109 2781 y
SDict begin H.S end
 109 2781 a 109 2781
a
SDict begin 12 H.A end
 109 2781 a 109 2781 a
SDict begin [/View [/XYZ H.V]/Dest (Item.4) cvn /DEST pdfmark end
 109 2781 a 0 TeXcolorgray 98
x FP(2.)p 0 TeXcolorgray 144 w FF(M)t FN(\()s FF(x)q
FN(;)h FF(y)p FN(;)d FF(z)r FN(\))22 b(est)e(un)i(point)g(du)g(plan)g
(\()6 b FF(A)t(B)s(C)s FN(\))21 b(si,)h(et)f(seulement)f(si,)i(les)f
(points)28 b FF(A)s FN(,)23 b FF(B)r FN(,)g FF(C)h FN(et)g
FF(M)i FN(sont)21 b(coplanaires)n(.)315 2993 y(C'est)f(\340)h(dire)o(,)
h(si)g(et)f(seulement)f(si,)i(il)h(existe)e(deux)h(r\351els)f
FI(\256)g FN(et)h FI(\257)f FN(tels)g(que)1777 3069 y
FC(\241)-21 b(\241)g(!)1783 3125 y FF(A)6 b(M)19 b FC(\306)14
b FI(\256)2056 3069 y FC(\241)-32 b(\241)g(!)2062 3125
y FF(A)t(B)12 b FC(\305)e FI(\257)2302 3069 y FC(\241)-31
b(\241)f(!)2308 3125 y FF(A)t(C)315 3258 y FN(Or)430
3201 y FC(\241)-21 b(\241)g(!)436 3258 y FF(A)6 b(M)583
3260 y FN(\()611 3258 y FF(x)11 b FC(\241)f FN(1;)15
b FF(y)p FN(;)d FF(z)g FC(\241)e FN(3)1033 3260 y(\))1060
3258 y(,)1103 3201 y FC(\241)-32 b(\241)f(!)1109 3258
y FF(A)t(B)1233 3260 y FN(\()1258 3258 y(0;)8 b FC(\241)p
FN(1;)g FC(\241)p FN(3)1555 3260 y(\))1603 3258 y(et)1694
3201 y FC(\241)-32 b(\241)g(!)1700 3258 y FF(A)t(C)1825
3260 y FN(\()1851 3258 y FC(\241)p FN(2;)8 b FC(\241)p
FN(2;)g FC(\241)p FN(2)2203 3260 y(\))2251 3258 y(d'o\371)932
3346 y Fo(8)932 3414 y(<)932 3552 y(:)1040 3404 y FF(x)j
FC(\241)f FN(1)83 b FC(\306)g(\241)p FN(2)p FI(\257)1159
3503 y FF(y)g FC(\306)g(\241)p FI(\256)10 b FC(\241)g
FN(2)p FI(\257)1042 3603 y FF(z)i FC(\241)e FN(3)83 b
FC(\306)g(\241)p FN(3)p FI(\256)10 b FC(\241)g FN(2)p
FI(\257)1802 3505 y FC(,)1892 3300 y Fo(8)1892 3369 y(>)1892
3392 y(>)1892 3414 y(<)1892 3552 y(>)1892 3575 y(>)1892
3598 y(:)2108 3353 y FN(1)g FC(\241)j FF(x)p 2108 3390
161 5 v 2167 3467 a FN(2)2362 3410 y FC(\306)83 b FI(\257)2000
3536 y FF(x)11 b FC(\241)17 b FF(y)10 b FC(\241)g FN(1)83
b FC(\306)g FI(\256)2124 3636 y FF(z)12 b FC(\241)e FN(3)82
b FC(\306)h(\241)p FN(3\()s FF(x)11 b FC(\241)17 b FF(y)10
b FC(\241)g FN(1\))g FC(\305)g FN(\()s FF(x)h FC(\241)f
FN(1\))1802 3905 y FC(,)1892 3700 y Fo(8)1892 3769 y(>)1892
3792 y(>)1892 3814 y(<)1892 3952 y(>)1892 3975 y(>)1892
3998 y(:)2193 3753 y FN(1)g FC(\241)j FF(x)p 2193 3790
V 2252 3867 a FN(2)2447 3810 y FC(\306)83 b FI(\257)2085
3936 y FF(x)11 b FC(\241)17 b FF(y)10 b FC(\241)g FN(1)83
b FC(\306)g FI(\256)1997 4036 y FN(2)s FF(x)11 b FC(\241)f
FN(3)d FF(y)j FC(\305)k FF(z)85 b FC(\306)e FN(5)315
4164 y(Ainsi,)22 b(le)f(plan)h(\()6 b FF(A)t(B)s(C)s
FN(\))21 b(a)g(pour)h(\351quation)f(2)s FF(x)11 b FC(\241)f
FN(3)d FF(y)j FC(\305)k FF(z)i FC(\306)f FN(5)p 0 TeXcolorgray
0 TeXcolorgray 1235 5778 a
 currentpoint currentpoint translate 0.9 0.9 scale neg exch neg exch
translate
 1235 5778 a 1257 5778 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 201.65717 a add def
/d 0.0 a add neg def /h 201.65717 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1257
5778 a 2094 5180 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray   0. true -100.82858 -72.02042
100.82858 129.63675 0 Frame  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath   0.4 .setopacityalpha  1 setlinejoin /PSfont
{/Times-Roman } def /pst@fill { 0.4 .setopacityalpha fill } def /strokeopacity
0.4 def /fillopacity 0.4 def /xunit {14.40408 } def /decal -2 def /viewpointXYZ
{45 -20 20} def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def
/fontsize {10  14.40408 mul 28.45 div } bind def /projectionsifacevisible
true def /R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def
/theta 90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff
.25 def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff
1 def /solidintersectiontype 0 def /section {R h 2 div neg R h 2 div
r h 2 div r h 2 div neg } def /base [ -3 5 -7 1] def /solidintersectionlinewidth
[ 2] def /solidintersectioncolor [ (noir)] def /solidintersectionplan
[ [0 0 1 0] [1 0 0 0] [0 1 0 0]] def /axe { 0 0 1} def /plansection
[ ] def /definition (equation) def /args { [2 -3 1 -5] -7} def /Mode
2 def /lightintensity 2 def /tablez [] def /zcolor [] def /solidlinewidth
{0.8 } def /linecolor {0  setgray } def /linestyle {solid} def /fillcolor
{0.932 0.912 0.75  setrgbcolor currentrgbcolor} def /fillincolor {0
1 0  setrgbcolor currentrgbcolor} def /color1 {1 0 0 0  setcmykcolor
} def /color2 {0 1 0 0  setcmykcolor } def /color3 {0 0 1  setrgbcolor
} def /color4 {1 0 0  setrgbcolor } def /range [ -5 5] def /action
(draw**) def /texte () def /pos (cc) def /proj-fontsize {10  14.40408
mul 28.45 div } bind def /rmfaces [] def /solidname (monplan) def/fcol
[] def /solidhue [] def /solidinouthue [] def /solidinhue [] def /origin
{0 0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin  0. 0. 0.  /CZ exch def /CY
exch def /CX exch def pst-plan end  /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {15
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ 0 360] def /action (draw**) def /texte ((ABC)) def /pos (cc) def
/proj-fontsize {15  14.40408 mul 28.45 div } bind def /rmfaces [] def
/fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue []
def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow []
def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf
[] def /solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin
true def /affinagerm true def /chanfrein false def /solidgrid true
def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
/projectionsifacevisible true def /isolatin true def /solidlinewidth
{0.8 } def /PSfont {/Times-Roman } def /normale {0 0 1} bind def /fontsize
{15  14.40408 mul 28.45 div } bind def /origin {0 0 0} def /RotationAngleText
{0} def /range [ 0 360] def /path { newpath 0 0 moveto} def /function
{ } def /texte ((ABC)) def /pos (cc) def /proj-definition () def /proj-args
{ } def /proj-action (draw**) def /planprojpst monplan def /noface
0 def /resolution 36 def  /CX 0 def /CY 0 def /CZ 0 def 3/xorigine
exch def 0 /yorigine exch def gsave proj-pst-texte end  gsave 0.8 SLW
0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke
 grestore grestore newpath end
 
@endspecial 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 0 0 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@O 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094
5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin -1 0 0 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@X 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 -5 0 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@Y 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180
a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 0 -1 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@Z 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 8 0 0 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@X' 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180 a 2094
5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 5 0 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@Y' 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 0 7 3dto2d cm_1 exch cm_1
exch end 14.40408 mul exch 14.40408 mul exch } false /N@Z' 10 {InitPnode
} /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180
a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 8 10.0 14.40408 div add 0
 0 3dto2d cm_1 exch cm_1 exch end 14.40408 mul exch 14.40408 mul exch
} false /N@Xname 10 {InitPnode } /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0  5 10.0 14.40408 div add
 0 3dto2d cm_1 exch cm_1 exch end 14.40408 mul exch 14.40408 mul exch
} false /N@Yname 10 {InitPnode } /NodeScale {} def NewNode end end
 2094 5180 a 2094 5180 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0  0  7 10.0 14.40408 div
add 3dto2d cm_1 exch cm_1 exch end 14.40408 mul exch 14.40408 mul exch
} false /N@Zname 10 {InitPnode } /NodeScale {} def NewNode end end
 2094
5180 a @beginspecial @setspecial
  tx@Dict begin STP newpath   1. .setopacityalpha  1 setlinejoin /PSfont
{/Times-Roman } def /pst@fill { 1. .setopacityalpha fill } def /strokeopacity
1. def /fillopacity 1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ
{45 -20 20} def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def
/fontsize {10  14.40408 mul 28.45 div } bind def /projectionsifacevisible
true def /R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def
/theta 90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff
.25 def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff
1 def /solidintersectiontype -1 def /section {R h 2 div neg R h 2 div
r h 2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { 0 -1.666 0} def /Mode 2 def /lightintensity 2 def /tablez
[] def /zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray
} def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin  0. 0. 0.  /CZ exch def /CY
exch def /CX exch def pst-point end    1. .setopacityalpha  1 setlinejoin
/PSfont {/Times-Roman } def /pst@fill { 1. .setopacityalpha fill }
def /strokeopacity 1. def /fillopacity 1. def /xunit {14.40408 } def
/decal -2 def /viewpointXYZ {45 -20 20} def /Decran 60 def /RotX 0
def /RotY 0 def /RotZ 0 def /fontsize {10  14.40408 mul 28.45 div }
bind def /projectionsifacevisible true def /R 4 def /r1 4 def /r0 1.5
def /resolution 36 def /phi 0 def /theta 90 def /r 2 def /a 4 def /b
a def /c a def /h 6 def /trunccoeff .25 def /chanfreincoeff .8 def
/affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype -1
def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg } def
/base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def /solidintersectioncolor
[ (rouge)] def /solidintersectionplan [ [0 0 1 0]] def /axe { 0 0 1}
def /plansection [ ] def /definition () def /args { 2.5 0 0} def /Mode
2 def /lightintensity 2 def /tablez [] def /zcolor [] def /solidlinewidth
{1.0 } def /linecolor {0  setgray } def /linestyle {solid} def /fillcolor
{1  setgray currentrgbcolor} def /fillincolor {0 1 0  setrgbcolor currentrgbcolor}
def /color1 {1 0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor
} def /color3 {0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor
} def /range [ -5 5] def /action (draw**) def /texte () def /pos (cc)
def /proj-fontsize {10  14.40408 mul 28.45 div } bind def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
 0. 0. 0.  /CZ exch def /CY exch def /CX exch def pst-point end   
1. .setopacityalpha  1 setlinejoin /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {14.40408 } def /decal -2 def /viewpointXYZ {45 -20 20}
def /Decran 60 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 14.40408 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { 0 0 5} def /Mode 2 def /lightintensity 2 def /tablez
[] def /zcolor [] def /solidlinewidth {1.0 } def /linecolor {0  setgray
} def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  14.40408 mul 28.45 div } bind def /rmfaces [] def /fcol [] def
/solidhue [] def /solidinouthue [] def /solidinhue [] def /origin {0
0 0} def /sommets [] def /faces [] def /solidshow [] def /solidnum
[] def SolidesDict begin /solidnumsep 15.0  def end /solidnumf [] def
/solidtrunc [] def /solidaffinage [] def /ngrid [] def /isolatin true
def /affinagerm true def /chanfrein false def /solidgrid true def /solidplanmarks
false def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin  0. 0. 0.  /CZ exch def /CY
exch def /CX exch def pst-point end  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  1.0 SLW 0  setgray  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict
/N@X known { /N@X load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 5.0 0.  CLW mul add dup
1.4  mul exch 0. mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.0 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Y
known { /N@Y load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 5.0 0.  CLW mul add dup
1.4  mul exch 0. mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.0 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Z
known { /N@Z load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 5.0 0.  CLW mul add dup
1.4  mul exch 0. mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.0 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0. 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@X' known { /N@X' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@X known { /N@X
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 5.0 0.  CLW mul add dup 1.4  mul exch 0. mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0. 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Y' known { /N@Y' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Y known { /N@Y
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 5.0 0.  CLW mul add dup 1.4  mul exch 0. mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0. 1.4 5.0 0. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.
1.4 5.0 0. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Z' known { /N@Z' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Z known { /N@Z
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 5.0 0.  CLW mul add dup 1.4  mul exch 0. mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
2094 5180 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Xname known { /N@Xname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2094 5180 a 2076 5198 a FF(x)2094 5180 y
tx@Dict begin  PutEnd  end

2094 5180 a 2094 5180 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Yname known { /N@Yname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2094 5180 a 2078 5190 a FF(y)2094
5180 y
tx@Dict begin  PutEnd  end
 2094 5180 a 2094 5180 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Zname known { /N@Zname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2094 5180 a 2077 5198
a FF(z)2094 5180 y
tx@Dict begin  PutEnd  end
 2094 5180 a @beginspecial @setspecial
  tx@Dict begin STP newpath end


@endspecial 2931 5778 a
currentpoint initclip moveto
 2931 5778 a 1235 5778 a
 currentpoint currentpoint translate 1 0.9 div 1 0.9 div scale neg
exch neg exch translate
 1235
5778 a 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 12 12
TeXDict begin 12 11 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.12) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(12)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.5.2) cvn /DEST pdfmark
end
 -128 -121 a 0.932 0.464 0 TeXcolorrgb 83 x FJ(2.5.2)93
b(V)-7 b(ecteur)28 b(orthogonal)e(\340)g(un)i(plan)p
0 TeXcolorgray -128 115 a FN(On)19 b(dit)g(qu'un)g(vecteur)c
FH(~)-44 b FF(n)20 b FN(est)d(orthogonal)i(\(ou)f(normal\))g(\340)g(un)
h(plan)g FI(\274)g FN(si)f(la)h(direction)g(de)c FH(~)-45
b FF(n)20 b FN(est)e(une)h(droite)f(orthogonale)-128
215 y(au)k(plan)g FI(\274)p FN(.)g(C'est)e(\340)i(dire)g(une)f(droite)h
(orthogonale)f(\340)g(toutes)g(les)g(droites)g(contenues)g(dans)h(le)f
(plan)i FI(\274)p FN(.)p 0 TeXcolorgray 0 TeXcolorgray
994 1125 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 184.94283 a add def
/d 0.0 a add neg def /h 96.73915 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 994 1125 a 1448 1078 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.804 0.79 0.648  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ -33.57402 7.96672
-3.41418 53.49129    /Lineto /lineto load def 1  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.0 SLW 0.804 0.79 0.648  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 85.35823 6.82881
-33.57402 7.96672    /Lineto /lineto load def 1  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 2.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0.804 0.79 0.648  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 115.51807 52.35294
-3.41418 53.49129    /Lineto /lineto load def 1  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.0 SLW 0.804 0.79 0.648  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0.545 0.536 0.44  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 85.35823 6.82881
115.51807 52.35294    /Lineto /lineto load def 1  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 2.0 SLW 0.545 0.536 0.44  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.25
1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 19.91682 81.94403 19.34766 36.98865    /Lineto /lineto load
def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def
} if () length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul
neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 1 0 0  setrgbcolor  1.
.setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 19.91682 97.8775 19.91682 81.94403
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup
1.4  mul exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1
Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n
1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt {
/Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5
 abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos
ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop
} repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2
x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 19.34766 36.98865 19.06328 7.39755
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup
1.4  mul exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1
Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n
1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt {
/Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5
 abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos
ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop
} repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2
x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 18.7789 -14.79555 19.06328 7.39755
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup
1.4  mul exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1
Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n
1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt {
/Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5
 abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos
ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop
} repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2
x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.25
1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 85.9274 20.77037 19.34766 36.98865    /Lineto /lineto load
def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def
} if () length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul
neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 1448 1078 a
tx@Dict begin { -44.3862 14.79555 } PutCoor PutBegin  end
 1448 1078 a 1450
1133 a FF(P)1448 1078 y
tx@Dict begin  PutEnd  end
 1448 1078 a 1448 1078 a
tx@Dict begin { 9.10507 79.66776 } PutCoor PutBegin  end
 1448
1078 a 1 0 0 TeXcolorrgb 1444 1138 a FH(~)-44 b FF(n)p
0 TeXcolorgray 1448 1078 a
tx@Dict begin  PutEnd  end
 1448 1078 a 1448 1078 a
tx@Dict begin { 93.89413 34.1432 } PutCoor PutBegin  end
 1448
1078 a 1371 1133 a FF(M)1448 1078 y
tx@Dict begin  PutEnd  end
 1448 1078 a 1448
1078 a
tx@Dict begin { 17.07181 36.98865 } PutCoor PutBegin  end
 1448 1078 a -58 w FF(A)1448 1078 y
tx@Dict begin  PutEnd  end
 1448 1078 a
2530 1125 a
currentpoint initclip moveto
 2530 1125 a -99 1304 a FP(Dans)22 b(un)g(rep\350re)i
(othonormal)p FN(,)e(le)g(vecteur)c FH(~)-44 b FF(n)1481
1306 y FN(\()1509 1304 y FF(a)p FN(;)10 b FF(b)q FN(;)i
FF(c)1696 1306 y FN(\))1747 1304 y(est)21 b(orthogonal)h(au)f(plan)1390
1422 y FI(\274)14 b FC(\264)i FF(a)s(x)11 b FC(\305)h
FF(b)c(y)i FC(\305)k FF(c)5 b(z)12 b FC(\305)g FF(d)21
b FC(\306)14 b FN(0)-99 1539 y(La)22 b(r\351ciproque)f(de)h(cette)f
(af\002rmation)g(est)g(vraie)o(.)p -128 1220 3858 4 v
-128 1582 4 364 v 3727 1582 V -128 1584 3858 4 v -128
1701 a FC(})46 b Fi(E)t Fj(X)t(E)t(M)t(P)t(L)t(E)17 b
FN(:)60 b(Soit)21 b FI(\274)g FN(le)h(plan)g(d'\351quation)f(3)s
FF(x)11 b FC(\241)f FN(4)d FF(y)j FC(\305)g FN(5)t FF(z)i
FC(\241)e FN(7)k FC(\306)h FN(0.)21 b(Un)h(vecteur)g(normal)f(de)h
FI(\274)f FN(est)c FH(~)-44 b FF(n)q FN(\(3)21 b(;)30
b FC(\241)p FN(4)22 b(;)30 b(5\))-128 1917 y
SDict begin H.S end
 -128 1917
a -128 1917 a
SDict begin 12 H.A end
 -128 1917 a -128 1917 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.5.3) cvn /DEST pdfmark
end
 -128 1917 a 0.932 0.464 0
TeXcolorrgb 116 x FJ(2.5.3)93 b(Distance)28 b(d'un)f(point)h(\340)e(un)
h(plan)p 0 TeXcolorgray -128 2115 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 2115 a -128
2115 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 2115 a 0 TeXcolorgray -70 2271 a FN(Soient)h(le)h(plan)h
FI(\274)f FN(d'\351quation)i FF(a)s(x)13 b FC(\305)i
FF(b)8 b(y)14 b FC(\305)j FF(c)5 b(z)14 b FC(\305)h FF(d)25
b FC(\306)20 b FN(0)29 b(\()r FF(a)p FN(,)r FF(b)j FN(et)h
FF(c)e FN(non)e(tous)g(nuls\))g(et)g(le)g(point)j FF(M)i
FN(de)29 b(coordonn\351es)-70 2371 y(\()s FF(x)1 2384
y FD(M)63 2371 y FN(;)15 b FF(y)138 2384 y FD(M)201 2371
y FN(;)d FF(z)274 2384 y FD(M)336 2371 y FN(\).)-70 2470
y(La)22 b(distance)g(du)g(point)j FF(M)h FN(au)21 b(plan)h
FI(\274)g FN(est)e(\351gale)i(\340)1149 2625 y(d)q(\()s
FF(M)t FG(,)p FI(\274)p FN(\))14 b FC(\306)1489 2569
y(j)r FF(a)c FC(\242)j FF(x)1642 2582 y FD(M)1716 2569
y FC(\305)f FF(b)f FC(\242)17 b FF(y)1914 2582 y FD(M)1988
2569 y FC(\305)d FF(c)d FC(\242)j FF(z)2177 2582 y FD(M)2251
2569 y FC(\305)e FF(d)s FC(j)p 1489 2606 902 5 v 1711
2628 a(p)p 1774 2628 395 5 v 1776 2699 a FF(a)1820 2675
y Fl(2)1868 2699 y FC(\305)g FF(b)1979 2675 y Fl(2)2027
2699 y FC(\305)i FF(c)2131 2675 y Fl(2)p 0 TeXcolorgray
-98 2148 3747 4 v -98 2728 4 582 v 3645 2728 V -98 2730
3747 4 v 3646 2763 35 585 v -65 2763 3747 35 v -128 2115
a
tx@Dict begin  PutEnd  end
 -128 2115 a -128 2115 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 2115 a -128 2115 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128
2115 a 0 TeXcolorgray -73 2225 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 4.99478 neg
49.67589 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(Propri\351t\351)p 0 TeXcolorgray -128
2115 a
tx@Dict begin  PutEnd  end
 -128 2115 a 853 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 17.26025 2.15753 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 4.31506 -25.89038 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 165 w Fh(D\351monstration)p
0 TeXcolorgray 0 TeXcolorgray 16 3068 a FN(On)21 b(part)h(de)g(la)g
(formule)1428 3267 y(d\()s FF(M)t FG(,)p FI(\274)p FN(\))15
b FC(\306)1768 3092 y Fo(\257)1768 3138 y(\257)1768 3184
y(\257)1793 3126 y FC(\241)-17 b(\241)g(!)1799 3183 y
FF(A)6 b(M)23 b FC(\242)1986 3146 y(\241)-57 b(!)1997
3183 y FF(n)2061 3092 y Fo(\257)2061 3138 y(\257)2061
3184 y(\257)p 1768 3248 319 5 v 1847 3262 a(\260)1847
3308 y(\260)1890 3292 y FC(\241)g(!)1900 3329 y FF(n)1964
3262 y Fo(\260)1964 3308 y(\260)3509 3416 y @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 -6.4726 -15.10272
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 21.57532 12.94519
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
-128 3569 a
SDict begin H.S end
 -128 3569 a -128 3569 a
SDict begin 12 H.A end
 -128 3569 a -128
3569 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.5.4) cvn /DEST pdfmark
end
 -128 3569 a 0.932 0.464 0 TeXcolorrgb 116 x FJ(2.5.4)93
b(Plans)27 b(parall\350les)p 0 TeXcolorgray -128 3767
a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 3767 a -128 3767 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 -128 3767 a 0 TeXcolorgray
-70 3913 a FN(Deux)i(plans)g FI(\274)f FN(et)g FI(\274)592
3883 y Fw(0)641 3913 y FN(d'\351quations)g(respectives)j
FF(a)s(x)13 b FC(\305)h FF(b)8 b(y)14 b FC(\305)i FF(c)5
b(z)23 b FC(\306)f FF(d)32 b FN(et)e FF(a)2244 3883 y
Fw(0)2269 3913 y FF(x)13 b FC(\305)h FF(b)2434 3883 y
Fw(0)2464 3913 y FF(y)e FC(\305)k FF(c)2621 3883 y Fw(0)2648
3913 y FF(z)21 b FC(\306)h FF(d)2832 3883 y Fw(0)2883
3913 y FN(sont)28 b(parall\350les)g(si,)h(et)-70 4013
y(seulement)20 b(si,)i(les)g(coef\002cients)h FF(a)p
FN(,)h FF(b)q FN(,)j FF(c)d FN(et)f FF(a)1337 3982 y
Fw(0)1359 4013 y FN(,)h FF(b)1448 3982 y Fw(0)1470 4013
y FN(,)i FF(c)1552 3982 y Fw(0)1596 4013 y FN(sont)21
b(proportionnels)n(.)p 0 TeXcolorgray -98 3799 3747 4
v -98 4055 4 258 v 3645 4055 V -98 4057 3747 4 v 3646
4090 35 261 v -65 4090 3747 35 v -128 3767 a
tx@Dict begin  PutEnd  end
 -128 3767
a -128 3767 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 -128 3767 a -128 3767 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 -128 3767 a 0 TeXcolorgray
-73 3877 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end
 
@endspecial FP(D\351\002nition)p
0 TeXcolorgray -128 3767 a
tx@Dict begin  PutEnd  end
 -128 3767 a 628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 628
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 628 5244
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial 628
5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 4 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 4.5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
628 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 628 5244 a 628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 628 5244 a 628 5244
a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 628 5244 a 610 5262 a FF(x)628 5244 y
tx@Dict begin  PutEnd  end
 628 5244 a 628
5244 a
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 628 5244 a 628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 628
5244 a 628 5244 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 628 5244 a 612 5254 a FF(y)628 5244
y
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 628 5244
a 628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 628 5244 a 628 5244 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 628 5244 a 611 5262
a FF(z)628 5244 y
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin  PutEnd  end
 628 5244 a 628
5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0.1 0.15 -.1 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 628 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 628 5244 a 598 5272 a FN(O)628 5244 y
tx@Dict begin  PutEnd  end
 628
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.545 0.45 0.332  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 3.2 0 0 0 0
3.8 0 3.5 0 3.2 0 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0. 
def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0. 
def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def
/RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta 30.
 def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2
Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def
/Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true
def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation
false def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.545 0.45
0.332  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.094 0.455 0.804  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 2 0 0 0 0 2.6
0 2.3 0 2 0 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.094 0.455
0.804  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2.5 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 628 5244 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 628 5244 a 0.545 0.45 0.332
TeXcolorrgb 588 5254 a Ff(\274)632 5268 y Fl(1)p 0 TeXcolorgray
628 5244 a
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1.3 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 628 5244 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 628 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 628 5244 a 0.094 0.455 0.804
TeXcolorrgb 588 5254 a Ff(\274)632 5268 y Fl(2)p 0 TeXcolorgray
628 5244 a
tx@Dict begin  PutEnd  end
 628 5244 a 628 5244 a
tx@Dict begin { 5.69057 -72.83923 } PutCoor PutBegin  end
 628 5244 a 342 5264
a FN(Plans)h(parall\350les)628 5244 y
tx@Dict begin  PutEnd  end
 628 5244 a 2707
5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 4 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 4.5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
2707 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 2707 5244 a 2707 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2707 5244 a 2707
5244 a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 2707 5244 a 2689 5262 a FF(x)2707 5244 y
tx@Dict begin  PutEnd  end
 2707
5244 a 2707 5244 a
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 2707 5244
a 2707 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2707 5244 a 2707 5244 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 2707 5244 a 2691
5254 a FF(y)2707 5244 y
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin  PutEnd  end
 2707
5244 a 2707 5244 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 2707 5244 a 2707 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2707 5244
a 2707 5244 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 2707 5244 a 2690 5262 a FF(z)2707 5244
y
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0.1 0.15 -.1 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 2707 5244
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 2707 5244 a 2677 5272 a FN(O)2707 5244 y
tx@Dict begin  PutEnd  end
 2707 5244
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.545 0.45 0.332  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 3.2 0 0 0 0
3.8 0 2.5 0 3.2 0 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0. 
def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0. 
def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def
/RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta 30.
 def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2
Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def
/Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true
def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation
false def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.545 0.45
0.332  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.094 0.455 0.804  setrgbcolor  /ArrowA
{ moveto } def /ArrowB { } def /ArrowInside { } def  [ 2 0 0 0 0 2.6
0 3.5 0 2 0 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.094 0.455
0.804  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ 1.885 1.817 -1.2 -.957
1.406 2.8  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   0  setlinecap [  5.0  3.0  0.0  0.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 1 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def  [ 0 1.544 1.453 1.032 1.694
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 135.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 22.76228  mul } def /yUnit { 22.76228  mul } def
convertStackTo2D end   /Lineto /lineto load def 1  setlinejoin false
  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.0 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1 1.7 2.8 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 2707 5244
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 2707 5244 a 1 0 0 TeXcolorrgb 2682 5268 a Fe(\242)p
0 TeXcolorgray 2707 5244 a
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.032 1.694 0 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  0.8 SLW 1 0
0  setrgbcolor  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  [ tx@NodeDict
begin tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0
} ifelse end   false NArray  /DS 2.0 2. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.2  1.2 
scale (b) show grestore } bind def  newpath n { transform floor .5
add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1.544 1.453 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707 5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  0.8 SLW 1 0
0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  [ tx@NodeDict
begin tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0
} ifelse end   false NArray  /DS 2.0 2. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.2  1.2 
scale (b) show grestore } bind def  newpath n { transform floor .5
add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2.5 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707 5244 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 2707 5244 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 2707 5244 a 0.545 0.45 0.332
TeXcolorrgb 2667 5254 a Ff(\274)2711 5268 y Fl(1)p 0
TeXcolorgray 2707 5244 a
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 135.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 3 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 2707
5244 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 2707 5244
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 2707 5244 a 0.094 0.455 0.804 TeXcolorrgb 2667 5254
a Ff(\274)2711 5268 y Fl(2)p 0 TeXcolorgray 2707 5244
a
tx@Dict begin  PutEnd  end
 2707 5244 a 2707 5244 a
tx@Dict begin { 5.69057 -72.83923 } PutCoor PutBegin  end
 2707 5244 a 2128 5272 a FN(Plans)h
(s\351cants)e(selon)f(une)i(droite)g FH(\242)2707 5244
y
tx@Dict begin  PutEnd  end
 2707 5244 a 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 13 13
TeXDict begin 13 12 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.13) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(13)p 109 -238 3780 2 v 0 TeXcolorgray 109 -121 a
SDict begin H.S end

109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.5.5) cvn /DEST pdfmark
end
 109 -121
a 0.932 0.464 0 TeXcolorrgb 83 x FJ(2.5.5)92 b(Syst\350me)28
b(d'\351quations)g(cart\351siennes)h(d'une)e(droite)p
0 TeXcolorgray 109 44 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 44 a 109 44 a
tx@Dict begin { 0.0 -6.4726 } PutCoor PutBegin  end
 109 44 a 0
TeXcolorgray 166 217 a FN(L)-8 b('espace)26 b(est)f(muni)g(d'un)h
(rep\350re)1263 130 y Fo(\263)1294 217 y FN(O;)1373 199
y FH(~)1387 217 y FF(i)s FG(,)1431 199 y FH(~)1448 217
y FF(j)s FG(,)1489 197 y FH(~)1498 217 y FF(k)1544 130
y Fo(\264)1576 217 y FN(.)g(Un)f(point)k FF(M)2056 219
y FN(\()2085 217 y FF(x)q FN(;)15 b FF(y)p FN(;)d FF(z)2271
219 y FN(\))2323 217 y(appartient)27 b(\340)e(une)h(droite)f
FH(\242)h FN(de)f(l'espace)g(si,)h(et)166 329 y(seulement)21
b(si,)h(ses)e(coordonn\351es)h(v\351ri\002ent)h(un)g(syst\350me)e
(d'\351quations)h(de)g(la)h(forme)616 493 y FH(\242)14
b FC(\264)755 383 y Fo(\275)845 441 y FF(a)s(x)d FC(\305)h
FF(b)c(y)i FC(\305)k FF(c)5 b(z)152 b FC(\306)85 b FF(d)845
541 y(a)889 511 y Fw(0)914 541 y FF(x)11 b FC(\305)h
FF(b)1075 511 y Fw(0)1105 541 y FF(y)e FC(\305)k FF(c)1258
511 y Fw(0)1284 541 y FF(z)85 b FC(\306)g FF(d)1595 511
y Fw(0)1698 493 y FN(o\371)24 b FF(a)p FN(,)g FF(b)q
FN(,)j FF(c)d FN(et)f FF(a)2183 459 y Fw(0)2205 493 y
FN(,)h FF(b)2294 459 y Fw(0)2316 493 y FN(,)i FF(c)2398
459 y Fw(0)2442 493 y FN(ne)21 b(sont)g(pas)h(proportionnels)n(.)p
0 TeXcolorgray 138 76 3747 4 v 138 597 4 523 v 3881 597
V 138 599 3747 4 v 3883 632 35 527 v 171 632 3747 35
v 109 44 a
tx@Dict begin  PutEnd  end
 109 44 a 109 44 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 109 44 a 109 44 a
tx@Dict begin { 12.94519 2.15753 } PutCoor PutBegin  end
 109 44
a 0 TeXcolorgray 163 154 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.0 SLW 1  setgray  0. true 3.0 neg 3.11153 neg
51.72194 9.70522 .5 Frame  gsave 1  setgray  1. .setopacityalpha  fill
 grestore end


@endspecial FP(D\351\002nition)p 0 TeXcolorgray 109
44 a
tx@Dict begin  PutEnd  end
 109 44 a 0 TeXcolorgray 0 TeXcolorgray 874 2266
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 270.87296 a add def
/d 0.0 a add neg def /h 174.13261 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 874 2266 a 1998 1784 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray   0. true -135.43648 -58.0442
135.43648 116.08841 0 Frame  gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@O 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@X 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998
1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@Y 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@Z 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998 1784
a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
6 0 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@X' 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 6 0 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@Y' 10 {InitPnode } /NodeScale {} def NewNode end end
 1998 1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0 0 6 3dto2d cm_1 exch cm_1 exch end 19.34807 mul exch 19.34807 mul
exch } false /N@Z' 10 {InitPnode } /NodeScale {} def NewNode end end
 1998
1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
6 5.0 19.34807 div add 0  0 3dto2d cm_1 exch cm_1 exch end 19.34807
mul exch 19.34807 mul exch } false /N@Xname 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 1784 a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0  6 5.0 19.34807 div add  0 3dto2d cm_1 exch cm_1 exch end 19.34807
mul exch 19.34807 mul exch } false /N@Yname 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 1784
a 1998 1784 a
tx@Dict begin tx@NodeDict begin { /PSfont {/Times-Roman } def /pst@fill
{ 1. .setopacityalpha fill } def /strokeopacity 1. def /fillopacity
1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ {40 30 20}
def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize {10
 19.34807 mul 28.45 div } bind def /projectionsifacevisible true def
/R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (draw**) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /fcol [] def /solidhue [] def /solidinouthue [] def /solidinhue
[] def /origin {0 0 0} def /sommets [] def /faces [] def /solidshow
[] def /solidnum [] def SolidesDict begin /solidnumsep 15.0  def end
/solidnumf [] def /solidtrunc [] def /solidaffinage [] def /ngrid []
def /isolatin true def /affinagerm true def /chanfrein false def /solidgrid
true def /solidplanmarks false def /solidplangrid false def /solidshowbase3d
false def /activationgestioncouleurs true def /solidshowbase false
def /soliddualreg false def /solidgeode false def /solidhollow false
def /solidbiface true def viewpointXYZ /ZpointVue ED /YpointVue ED
/XpointVue ED /THETA {YpointVue XpointVue atan} bind def /PHI {ZpointVue
XpointVue dup mul YpointVue dup mul add sqrt atan} bind def /Dobs {XpointVue
dup mul YpointVue dup mul add ZpointVue dup mul add sqrt} bind def
XpointVue YpointVue ZpointVue /viewpoint defpoint3d  SolidesDict begin
0  0  6 5.0 19.34807 div add 3dto2d cm_1 exch cm_1 exch end 19.34807
mul exch 19.34807 mul exch } false /N@Zname 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 1784 a @beginspecial @setspecial
  tx@Dict begin STP newpath   1. .setopacityalpha  1 setlinejoin /PSfont
{/Times-Roman } def /pst@fill { 1. .setopacityalpha fill } def /strokeopacity
1. def /fillopacity 1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ
{40 30 20} def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize
{10  19.34807 mul 28.45 div } bind def /projectionsifacevisible true
def /R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype -1 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
(equation) def /args { [1 0 1 -2]} def /Mode 2 def /lightintensity
2 def /tablez [] def /zcolor [] def /solidlinewidth {0.8 } def /linecolor
{0  setgray } def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (none) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /solidname (P) def/fcol [] def /solidhue [] def /solidinouthue
[] def /solidinhue [] def /origin {0 0 0} def /sommets [] def /faces
[] def /solidshow [] def /solidnum [] def SolidesDict begin /solidnumsep
15.0  def end /solidnumf [] def /solidtrunc [] def /solidaffinage []
def /ngrid [] def /isolatin true def /affinagerm true def /chanfrein
false def /solidgrid true def /solidplanmarks false def /solidplangrid
false def /solidshowbase3d false def /activationgestioncouleurs true
def /solidshowbase false def /soliddualreg false def /solidgeode false
def /solidhollow false def /solidbiface true def viewpointXYZ /ZpointVue
ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue atan} bind
def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul add sqrt atan}
bind def /Dobs {XpointVue dup mul YpointVue dup mul add ZpointVue dup
mul add sqrt} bind def XpointVue YpointVue ZpointVue /viewpoint defpoint3d
 SolidesDict begin  0. 0. 0.  /CZ exch def /CY exch def /CX exch def
pst-plan end    1. .setopacityalpha  1 setlinejoin /PSfont {/Times-Roman
} def /pst@fill { 1. .setopacityalpha fill } def /strokeopacity 1.
def /fillopacity 1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ
{40 30 20} def /Decran 50 def /RotX 0 def /RotY 90 def /RotZ 15 def
/fontsize {10  19.34807 mul 28.45 div } bind def /projectionsifacevisible
true def /R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def
/theta 90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff
.25 def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff
1 def /solidintersectiontype -1 def /section {R h 2 div neg R h 2 div
r h 2 div r h 2 div neg } def /base [ -4 2 -5 5] def /solidintersectionlinewidth
[ 1] def /solidintersectioncolor [ (rouge)] def /solidintersectionplan
[ [0 0 1 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
() def /args { } def /Mode 2 def /lightintensity 2 def /tablez [] def
/zcolor [] def /solidlinewidth {0.8 } def /linecolor {0  setgray }
def /linestyle {solid} def /fillcolor {1  setgray currentrgbcolor}
def /fillincolor {0 1 0  setrgbcolor currentrgbcolor} def /color1 {1
0 0 0  setcmykcolor } def /color2 {0 1 0 0  setcmykcolor } def /color3
{0 0 1  setrgbcolor } def /color4 {1 0 0  setrgbcolor } def /range
[ -5 5] def /action (none) def /texte () def /pos (cc) def /proj-fontsize
{10  19.34807 mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces
[] def /plansepare {P} def/solidname (parts_plan) def/fcol [] def /solidhue
[] def /solidinouthue [] def /solidinhue [] def /origin {0 0 0} def
/sommets [] def /faces [] def /solidshow [] def /solidnum [] def SolidesDict
begin /solidnumsep 15.0  def end /solidnumf [] def /solidtrunc [] def
/solidaffinage [] def /ngrid [] def /isolatin true def /affinagerm
true def /chanfrein false def /solidgrid true def /solidplanmarks false
def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin 0 0 0 /CZ exch def /CY exch
def /CX exch def pst-grille end    0.6 .setopacityalpha  1 setlinejoin
/PSfont {/Times-Roman } def /pst@fill { 0.6 .setopacityalpha fill }
def /strokeopacity 0.6 def /fillopacity 0.6 def /xunit {19.34807 }
def /decal -2 def /viewpointXYZ {40 30 20} def /Decran 50 def /RotX
0 def /RotY 0 def /RotZ 0 def /fontsize {10  19.34807 mul 28.45 div
} bind def /projectionsifacevisible true def /R 4 def /r1 4 def /r0
1.5 def /resolution 36 def /phi 0 def /theta 90 def /r 2 def /a 4 def
/b a def /c a def /h 6 def /trunccoeff .25 def /chanfreincoeff .8 def
/affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype -1
def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg } def
/base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def /solidintersectioncolor
[ (rouge)] def /solidintersectionplan [ [0 0 1 0]] def /axe { 0 0 1}
def /plansection [ ] def /definition () def /args { } def /Mode 2 def
/lightintensity 2 def /tablez [] def /zcolor [] def /solidlinewidth
{0.8 } def /linecolor {0  setgray } def /linestyle {solid} def /fillcolor
{0.7348 0.8695 1  setrgbcolor currentrgbcolor} def /fillincolor {0
1 0  setrgbcolor currentrgbcolor} def /color1 {1 0 0 0  setcmykcolor
} def /color2 {0 1 0 0  setcmykcolor } def /color3 {0 0 1  setrgbcolor
} def /color4 {1 0 0  setrgbcolor } def /range [ -5 5] def /action
(draw**) def /texte () def /pos (cc) def /proj-fontsize {10  19.34807
mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces [] def
/solidloadname {parts_plan1} def/fcol [] def /solidhue [] def /solidinouthue
[] def /solidinhue [] def /origin {0 0 0} def /sommets [] def /faces
[] def /solidshow [] def /solidnum [] def SolidesDict begin /solidnumsep
15.0  def end /solidnumf [] def /solidtrunc [] def /solidaffinage []
def /ngrid [] def /isolatin true def /affinagerm true def /chanfrein
false def /solidgrid true def /solidplanmarks false def /solidplangrid
false def /solidshowbase3d false def /activationgestioncouleurs true
def /solidshowbase false def /soliddualreg false def /solidgeode false
def /solidhollow false def /solidbiface true def viewpointXYZ /ZpointVue
ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue atan} bind
def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul add sqrt atan}
bind def /Dobs {XpointVue dup mul YpointVue dup mul add ZpointVue dup
mul add sqrt} bind def XpointVue YpointVue ZpointVue /viewpoint defpoint3d
 SolidesDict begin  0. 0. 0.  /CZ exch def /CY exch def /CX exch def
pst-load end    1. .setopacityalpha  1 setlinejoin /PSfont {/Times-Roman
} def /pst@fill { 1. .setopacityalpha fill } def /strokeopacity 1.
def /fillopacity 1. def /xunit {19.34807 } def /decal -2 def /viewpointXYZ
{40 30 20} def /Decran 50 def /RotX 0 def /RotY 0 def /RotZ 0 def /fontsize
{10  19.34807 mul 28.45 div } bind def /projectionsifacevisible true
def /R 4 def /r1 4 def /r0 1.5 def /resolution 36 def /phi 0 def /theta
90 def /r 2 def /a 4 def /b a def /c a def /h 6 def /trunccoeff .25
def /chanfreincoeff .8 def /affinagecoeff .8 def /dualregcoeff 1 def
/solidintersectiontype 0 def /section {R h 2 div neg R h 2 div r h
2 div r h 2 div neg } def /base [ -3 3 -5 5] def /solidintersectionlinewidth
[ 2] def /solidintersectioncolor [ (bleu)] def /solidintersectionplan
[ [1.932 0.518 0 0]] def /axe { 0 0 1} def /plansection [ ] def /definition
(equation) def /args { [1 0 1 -2]} def /Mode 2 def /lightintensity
2 def /tablez [] def /zcolor [] def /solidlinewidth {0.8 } def /linecolor
{0  setgray } def /linestyle {solid} def /fillcolor {0.9412 0.9004
0.847  setrgbcolor currentrgbcolor} def /fillincolor {0 1 0  setrgbcolor
currentrgbcolor} def /color1 {1 0 0 0  setcmykcolor } def /color2 {0
1 0 0  setcmykcolor } def /color3 {0 0 1  setrgbcolor } def /color4
{1 0 0  setrgbcolor } def /range [ -5 5] def /action (draw*) def /texte
() def /pos (cc) def /proj-fontsize {10  19.34807 mul 28.45 div } bind
def /lightsrc {viewpoint} def /rmfaces [] def /fcol [] def /solidhue
[] def /solidinouthue [] def /solidinhue [] def /origin {0 0 0} def
/sommets [] def /faces [] def /solidshow [] def /solidnum [] def SolidesDict
begin /solidnumsep 15.0  def end /solidnumf [] def /solidtrunc [] def
/solidaffinage [] def /ngrid [] def /isolatin true def /affinagerm
true def /chanfrein false def /solidgrid true def /solidplanmarks false
def /solidplangrid false def /solidshowbase3d false def /activationgestioncouleurs
true def /solidshowbase false def /soliddualreg false def /solidgeode
false def /solidhollow false def /solidbiface true def viewpointXYZ
/ZpointVue ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue
atan} bind def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul
add sqrt atan} bind def /Dobs {XpointVue dup mul YpointVue dup mul
add ZpointVue dup mul add sqrt} bind def XpointVue YpointVue ZpointVue
/viewpoint defpoint3d  SolidesDict begin  0. 0. 0.  /CZ exch def /CY
exch def /CX exch def pst-plan end    0.6 .setopacityalpha  1 setlinejoin
/PSfont {/Times-Roman } def /pst@fill { 0.6 .setopacityalpha fill }
def /strokeopacity 0.6 def /fillopacity 0.6 def /xunit {19.34807 }
def /decal -2 def /viewpointXYZ {40 30 20} def /Decran 50 def /RotX
0 def /RotY 0 def /RotZ 0 def /fontsize {10  19.34807 mul 28.45 div
} bind def /projectionsifacevisible true def /R 4 def /r1 4 def /r0
1.5 def /resolution 36 def /phi 0 def /theta 90 def /r 2 def /a 4 def
/b a def /c a def /h 6 def /trunccoeff .25 def /chanfreincoeff .8 def
/affinagecoeff .8 def /dualregcoeff 1 def /solidintersectiontype -1
def /section {R h 2 div neg R h 2 div r h 2 div r h 2 div neg } def
/base [ -1 -1 1 -1 0 1] def /solidintersectionlinewidth [ 1] def /solidintersectioncolor
[ (rouge)] def /solidintersectionplan [ [0 0 1 0]] def /axe { 0 0 1}
def /plansection [ ] def /definition () def /args { } def /Mode 2 def
/lightintensity 2 def /tablez [] def /zcolor [] def /solidlinewidth
{0.8 } def /linecolor {0  setgray } def /linestyle {solid} def /fillcolor
{0.7348 0.8695 1  setrgbcolor currentrgbcolor} def /fillincolor {0
1 0  setrgbcolor currentrgbcolor} def /color1 {1 0 0 0  setcmykcolor
} def /color2 {0 1 0 0  setcmykcolor } def /color3 {0 0 1  setrgbcolor
} def /color4 {1 0 0  setrgbcolor } def /range [ -5 5] def /action
(draw**) def /texte () def /pos (cc) def /proj-fontsize {10  19.34807
mul 28.45 div } bind def /lightsrc {viewpoint} def /rmfaces [] def
/solidloadname {parts_plan0} def/fcol [] def /solidhue [] def /solidinouthue
[] def /solidinhue [] def /origin {0 0 0} def /sommets [] def /faces
[] def /solidshow [] def /solidnum [] def SolidesDict begin /solidnumsep
15.0  def end /solidnumf [] def /solidtrunc [] def /solidaffinage []
def /ngrid [] def /isolatin true def /affinagerm true def /chanfrein
false def /solidgrid true def /solidplanmarks false def /solidplangrid
false def /solidshowbase3d false def /activationgestioncouleurs true
def /solidshowbase false def /soliddualreg false def /solidgeode false
def /solidhollow false def /solidbiface true def viewpointXYZ /ZpointVue
ED /YpointVue ED /XpointVue ED /THETA {YpointVue XpointVue atan} bind
def /PHI {ZpointVue XpointVue dup mul YpointVue dup mul add sqrt atan}
bind def /Dobs {XpointVue dup mul YpointVue dup mul add ZpointVue dup
mul add sqrt} bind def XpointVue YpointVue ZpointVue /viewpoint defpoint3d
 SolidesDict begin  0. 0. 0.  /CZ exch def /CY exch def /CX exch def
pst-load end  /ArrowA { moveto } def /ArrowB { } def /ArrowInside {
} def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@X known { /N@X load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known { /N@O
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  0  setlinecap [  5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Y
known { /N@Y load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Z
known { /N@Z load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@X' known { /N@X' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@X known { /N@X
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Y' known { /N@Y' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Y known { /N@Y
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.8 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Z' known { /N@Z' load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@Z known { /N@Z
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 1998 1784 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Xname known { /N@Xname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 1784 a 1980
1802 a FF(x)1998 1784 y
tx@Dict begin  PutEnd  end
 1998 1784 a 1998 1784 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Yname known { /N@Yname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998
1784 a 1982 1794 a FF(y)1998 1784 y
tx@Dict begin  PutEnd  end
 1998 1784 a 1998
1784 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Zname known { /N@Zname
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 1784 a 1981 1802 a FF(z)1998 1784 y
tx@Dict begin  PutEnd  end
 1998
1784 a 1998 1784 a
tx@Dict begin { -92.87077 23.21762 } PutCoor PutBegin  end
 1998 1784 a 0 0 1 TeXcolorrgb 1970
1811 a FH(\242)p 0 TeXcolorgray 1998 1784 a
tx@Dict begin  PutEnd  end
 1998 1784
a @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 3123 2266 a
currentpoint initclip moveto

3123 2266 a 1410 2569 a FH(\242)14 b FC(\264)1550 2459
y Fo(\275)2115 2518 y FF(x)d FC(\305)j FF(z)84 b FC(\306)f
FN(2)1638 2617 y(1)p FG(,)p FN(932)10 b FC(\242)j FF(x)e
FC(\305)f FN(0)p FG(,)p FN(518)g FC(\242)17 b FF(y)84
b FC(\306)f FN(0)p 0.094 0.455 0.804 TeXcolorrgb 109
2826 a
SDict begin H.S end
 109 2826 a 109 2826 a
SDict begin 12 H.A end
 109 2826 a 109 2826 a
SDict begin [/View [/XYZ H.V]/Dest (section*.18) cvn /DEST pdfmark
end
 109
2826 a FP(Syst\350me)23 b(d'\351quations)f(cart\351siennes)g(des)g
(axes)p 0 TeXcolorgray 109 2995 a FN(Le)f(plan)h(\351tant)g(muni)f
(d'un)h(rep\350re)1245 2908 y Fo(\263)1277 2995 y FN(O;)1356
2976 y FH(~)1370 2995 y FF(i)s FG(,)1414 2976 y FH(~)1431
2995 y FF(j)s FG(,)1472 2975 y FH(~)1481 2995 y FF(k)1527
2908 y Fo(\264)1558 2995 y FN(,)g(on)g(a)f(:)p 0 TeXcolorgray
109 3172 a(\226)p 0 TeXcolorgray 41 w(l'axe)h(\()p FF(O)5
b(x)q FN(\))21 b(admet)802 3062 y Fo(\275)897 3120 y
FF(y)14 b FC(\306)g FN(0)894 3220 y FF(z)i FC(\306)e
FN(0)1135 3172 y(comme)21 b(syst\350me)f(d'\351quations)h
(cart\351siennes)12 b(;)p 0 TeXcolorgray 109 3379 a(\226)p
0 TeXcolorgray 41 w(l'axe)22 b(\()p FF(O)9 b(y)p FN(\))21
b(admet)805 3269 y Fo(\275)896 3328 y FF(x)15 b FC(\306)f
FN(0)897 3427 y FF(z)i FC(\306)e FN(0)1135 3379 y(comme)21
b(syst\350me)f(d'\351quations)h(cart\351siennes)12 b(;)p
0 TeXcolorgray 109 3587 a(\226)p 0 TeXcolorgray 41 w(l'axe)22
b(\()p FF(O)6 b(z)r FN(\))21 b(admet)801 3477 y Fo(\275)896
3535 y FF(y)14 b FC(\306)g FN(0)891 3635 y FF(a)h FC(\306)f
FN(0)1135 3587 y(comme)20 b(syst\350me)g(d'\351quations)h
(cart\351siennes)n(.)109 3789 y
SDict begin H.S end
 109 3789 a 109 3789 a
SDict begin 12 H.A end

109 3789 a 109 3789 a
SDict begin [/View [/XYZ H.V]/Dest (section.2.6) cvn /DEST pdfmark
end
 109 3789 a 0.93 0.26 0 TeXcolorrgb
88 x FK(2.6)110 b(Exercices)31 b(r\351solus)p 0 TeXcolorgray
109 3961 a
SDict begin H.S end
 109 3961 a 109 3961 a
SDict begin 12 H.A end
 109 3961 a 109 3961
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.1) cvn /DEST pdfmark end
 109 3961 a 200 x FP(Exercice)22 b(n)533 4136 y Fb(o)579
4161 y FP(1)p 667 4136 3222 4 v 109 4275 a FN(Soient)f(les)g(points)27
b FF(A)s FN(\()p FC(\241)p FN(3;)8 b(0;)g(0\),)24 b FF(B)r
FN(\(0;)8 b(4;)g(0\))21 b(et)h FF(C)s FN(\(0;)8 b(0;)g
FC(\241)p FN(2\))22 b(de)f(l'espace)o(.)109 4303 y
SDict begin H.S end
 109
4303 a 109 4303 a
SDict begin 12 H.A end
 109 4303 a 109 4303 a
SDict begin [/View [/XYZ H.V]/Dest (Item.5) cvn /DEST pdfmark end
 109 4303 a 0
TeXcolorgray 97 x FP(a.)p 0 TeXcolorgray 64 w FN(D\351terminer)g(une)g
(\351quation)h(cart\351sienne)f(du)h(plan)g(\()6 b FF(A)t(B)s(C)s
FN(\).)109 4429 y
SDict begin H.S end
 109 4429 a 109 4429 a
SDict begin 12 H.A end
 109 4429 a 109
4429 a
SDict begin [/View [/XYZ H.V]/Dest (Item.6) cvn /DEST pdfmark end
 109 4429 a 0 TeXcolorgray 96 x FP(b.)p 0 TeXcolorgray
64 w FN(D\351terminer)22 b(une)h(\351quation)f(cart\351sienne)g(du)h
(plan)h FI(\274)e FN(passant)h(par)g FF(O)i FN(\(l'origine)e(des)f
(axes\))g(et)h(parall\350le)g(au)f(plan)241 4624 y(\()6
b FF(A)t(B)s(C)s FN(\).)109 4647 y
SDict begin H.S end
 109 4647 a 109 4647
a
SDict begin 12 H.A end
 109 4647 a 109 4647 a
SDict begin [/View [/XYZ H.V]/Dest (Item.7) cvn /DEST pdfmark end
 109 4647 a 0 TeXcolorgray 113
4750 a FP(c.)p 0 TeXcolorgray 64 w FN(D\351terminer)19
b(une)h(\351quation)g(cart\351sienne)f(du)i(plan)f FI(\274)1930
4719 y Fw(0)1971 4750 y FN(passant)g(par)g FF(O)j FN(et)c(par)h(les)g
(milieux)h(des)e(segments)g([)q FF(C)9 b(A)s FN(])20
b(et)241 4849 y([)q FF(C)t(B)r FN(].)109 4870 y
SDict begin H.S end
 109 4870
a 109 4870 a
SDict begin 12 H.A end
 109 4870 a 109 4870 a
SDict begin [/View [/XYZ H.V]/Dest (Item.8) cvn /DEST pdfmark end
 109 4870 a 0 TeXcolorgray
104 x FP(d.)p 0 TeXcolorgray 64 w FN(D\351terminer)h(une)h
(repr\351sentation)f(param\351trique)g(de)h(la)g(droite)h
FF(d)s FN(,)g(intersection)f(des)f(plans)h FI(\274)f
FN(et)g FI(\274)3423 4944 y Fw(0)3444 4974 y FN(.)109
5099 y @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 17.26025 2.15753 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 4.31506 -43.15063 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 164 w FP(Solutions)109 5087
y
SDict begin H.S end
 109 5087 a 109 5087 a
SDict begin 12 H.A end
 109 5087 a 109 5087 a
SDict begin [/View [/XYZ H.V]/Dest (Item.9) cvn /DEST pdfmark end
 109 5087
a 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 252 5199
a FP(a.)p 0 TeXcolorgray 64 w FN(Une)26 b(\351quation)g(du)h(plan)g(\()
6 b FF(A)t(B)s(C)s FN(\))25 b(est)j FF(a)s(x)12 b FC(\305)i
FF(b)8 b(y)13 b FC(\305)j FF(c)5 b(z)13 b FC(\305)h FF(d)23
b FC(\306)18 b FN(0)26 b(a)o(vec)i FF(a)p FN(,)i FF(b)q
FN(,)i FF(c)c FN(et)g FF(d)i FN(sont)c(des)f(r\351els)h(non)g(tous)384
5299 y(nuls)n(.)384 5398 y(Les)c(coordonn\351es)f(respectives)h(des)g
(trois)f(points)29 b FF(A)s FN(,)24 b FF(B)f FN(et)f
FF(C)j FN(la)d(v\351ri\002ent,)h(donc)g FC(\241)p FN(3)r
FF(a)11 b FC(\305)h FF(d)18 b FC(\306)d FN(0,)22 b(4)r
FF(b)11 b FC(\305)h FF(d)20 b FC(\306)15 b FN(0)384 5498
y(et)21 b FC(\241)p FN(2)t FF(c)11 b FC(\305)h FF(d)20
b FC(\306)14 b FN(0.)384 5598 y(Ainsi,)24 b(puisque)g(les)f(r\351els)i
FF(a)p FN(,)h FF(b)g FN(et)g FF(c)g FN(sont)d(non)g(nuls)h(on)f(a)i
FF(a)16 b FC(\306)2383 5565 y FD(d)p 2381 5578 41 5 v
2385 5626 a Fl(3)2431 5598 y FN(,)26 b FF(b)18 b FC(\306)d(\241)2676
5565 y FD(d)p 2674 5578 V 2678 5626 a Fl(4)2748 5598
y FN(et)27 b FF(c)17 b FC(\306)2978 5565 y FD(d)p 2976
5578 V 2980 5626 a Fl(2)3026 5598 y FN(,)24 b(et)f(le)g(r\351el)i
FF(d)i FN(est)c(non)384 5697 y(nul)d(puisque)h FF(a)p
FN(,)g FF(b)q FN(,)k FF(c)20 b FN(et)h FF(d)h FN(ne)d(sont)f(pas)h
(tous)f(nuls)n(,)h(d'o\371,)g(apr\350s)g(une)f(simpli\002cation)i(par)h
FF(d)s FN(,)g(une)d(\351quation)384 5797 y(du)k(plan)g(\()6
b FF(A)t(B)s(C)s FN(\))21 b(est)1784 5858 y FF(x)p 1781
5895 43 5 v 1781 5971 a FN(3)1844 5914 y FC(\241)1926
5858 y FF(y)p 1919 5895 47 5 v 1921 5971 a FN(4)1985
5914 y FC(\305)2065 5858 y FF(z)p 2061 5895 43 5 v 2061
5971 a FN(2)2124 5914 y FC(\305)10 b FN(1)k FC(\306)g
FN(0)p 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 14 14
TeXDict begin 14 13 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.14) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(14)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray 148 -38
a FN(ou)21 b(mieux)h(:)1322 62 y(\()6 b FF(A)t(B)s(C)s
FN(\))13 b FC(\264)h FN(4)s FF(x)d FC(\241)f FN(3)d FF(y)j
FC(\305)g FN(6)t FF(z)i FC(\305)e FN(12)k FC(\306)g FN(0)-128
127 y
SDict begin H.S end
 -128 127 a -128 127 a
SDict begin 12 H.A end
 -128 127 a -128 127 a
SDict begin [/View [/XYZ H.V]/Dest (Item.10) cvn /DEST pdfmark end
 -128
127 a 0 TeXcolorgray 16 225 a FP(b.)p 0 TeXcolorgray
64 w FN(Le)21 b(plan)i FI(\274)e FN(est)g(parall\350le)h(au)f(plan)i
(\()6 b FF(A)t(B)s(C)s FN(\),)21 b(il)h(a)f(donc)h(le)f(m\352me)f
(vecteur)i(normal)f(:)1226 343 y FI(\274)14 b FC(\264)g
FN(4)s FF(x)d FC(\241)f FN(3)d FF(y)j FC(\305)g FN(6)t
FF(z)i FC(\305)g FF(k)j FC(\306)h FN(0)154 b(\()r FF(k)15
b FC(2)h Fk(R)2369 355 y Fl(0)2405 343 y FN(\))148 460
y(De)21 b(plus)h(les)f(coordonn\351es)g(du)h(point)g
FF(O)i FN(v\351ri\002ent)e(cette)f(\351quation,)h(d'o\371)h
FF(k)15 b FC(\306)g FN(0.)148 560 y(Une)21 b(\351quation)g(du)h(plan)h
FI(\274)e FN(est)1560 660 y(4)s FF(x)11 b FC(\241)f FN(3)d
FF(y)j FC(\305)g FN(6)t FF(z)16 b FC(\306)e FN(0)-128
725 y
SDict begin H.S end
 -128 725 a -128 725 a
SDict begin 12 H.A end
 -128 725 a -128 725 a
SDict begin [/View [/XYZ H.V]/Dest (Item.11) cvn /DEST pdfmark end
 -128
725 a 0 TeXcolorgray 20 823 a FP(c.)p 0 TeXcolorgray
64 w FN(Le)j(plan)g FI(\274)479 793 y Fw(0)517 823 y
FN(passe)f(par)h(le)g(point)g FF(O)r FN(\(0;)8 b(0;)g(0\))18
b(donc)f(il)g(a)g(une)g(\351quation)f(cart\351sienne)h(du)g(type)i
FF(u)t(x)r FC(\305)s FF(v)8 b(y)q FC(\305)s FF(w)d(z)15
b FC(\306)f FN(0,)148 923 y(les)21 b(r\351els)i FF(u)q
FN(,)i FF(v)d FN(et)i FF(w)e FN(\351tant)f(non)g(tous)g(nuls)n(.)148
1023 y(Les)f(milieux)g(des)g(segments)e([)q FF(C)9 b(A)s
FN(])20 b(et)f([)q FF(C)t(B)r FN(])f(ont)i(pour)g(coordonn\351es)f
(respectives)2739 958 y Fo(\241)2769 1023 y FC(\241)2834
990 y Fl(3)p 2834 1003 33 5 v 2834 1051 a(2)2877 1023
y FN(;)8 b(0;)g FC(\241)p FN(1)3076 958 y Fo(\242)3126
1023 y FN(et)3214 1025 y(\()3240 1023 y(0;)g(2;)g FC(\241)p
FN(1)3482 1025 y(\))148 1133 y(et)21 b(ils)h(appartiennent)g(au)g(plan)
g FI(\274)1218 1102 y Fw(0)1261 1133 y FN(donc)f FC(\241)1511
1100 y Fl(3)p 1511 1113 V 1511 1161 a(2)1556 1133 y FF(u)11
b FC(\241)h FF(w)k FC(\306)e FN(0)22 b(et)f(2)r FF(v)11
b FC(\241)h FF(w)j FC(\306)f FN(0.)148 1232 y(En)21 b(c)o(hoisissant)j
FF(w)15 b FC(\306)f(\241)p FN(6)22 b(on)f(obtient)i FF(v)15
b FC(\306)f(\241)p FN(3)21 b(et)j FF(u)15 b FC(\306)g
FN(4,)22 b(d'o\371)f(une)h(\351quation)f(du)h(plan)g
FI(\274)2888 1202 y Fw(0)2931 1232 y FN(:)1560 1350 y(4)s
FF(x)11 b FC(\241)f FN(3)d FF(y)j FC(\241)g FN(6)t FF(z)16
b FC(\306)e FN(0)-128 1383 y
SDict begin H.S end
 -128 1383 a -128 1383 a
SDict begin 12 H.A end

-128 1383 a -128 1383 a
SDict begin [/View [/XYZ H.V]/Dest (Item.12) cvn /DEST pdfmark end
 -128 1383 a 0 TeXcolorgray 16
1482 a FP(d.)p 0 TeXcolorgray 64 w FN(Les)28 b(plans)g
FI(\274)f FN(et)g FI(\274)749 1451 y Fw(0)798 1482 y
FN(ont)g(en)g(commun)g(les)g(milieux)i(des)e(segments)f([)q
FF(C)9 b(A)s FN(])28 b(et)f([)q FF(C)t(B)r FN(])f(mais)h(pas)g(le)h
(point)g(0)148 1581 y(qui)21 b(n'appartient)g(qu'au)f(second)h(donc)f
FI(\274)g FN(et)g FI(\274)1612 1551 y Fw(0)1654 1581
y FN(sont)g(bien)g(s\351cants)g(et)g(ont)g(pour)h(intersection)g(la)f
(droite)j FF(d)148 1681 y FN(passant)e(par)h(les)g(milieux)g(des)f
(segments)f([)q FF(C)9 b(A)s FN(])22 b(et)f([)q FF(C)t(B)r
FN(].)148 1780 y(Les)f(coordonn\351es)f(respectives)g(de)h(ces)g(deux)g
(points)g(sont)1999 1716 y Fo(\241)2029 1780 y FC(\241)2094
1748 y Fl(3)p 2094 1761 33 5 v 2094 1809 a(2)2136 1780
y FN(;)8 b(0;)g FC(\241)p FN(1)2335 1716 y Fo(\242)2386
1780 y FN(et)2474 1782 y(\()2500 1780 y(0;)g(2;)g FC(\241)p
FN(1)2742 1782 y(\))2789 1780 y(d'o\371)19 b(les)h(coordonn\351es)148
1890 y(d'un)26 b(vecteur)g(directeur)g(de)g(la)g(droite)h
FF(d)j FN(:)1532 1826 y Fo(\241)1572 1858 y Fl(3)p 1572
1871 V 1572 1919 a(2)1614 1890 y FN(;)8 b(2;)g(0)1758
1826 y Fo(\242)1802 1890 y FN(;)26 b(ou)f(pour)h(simpli\002er)g
(l'\351criture)g(celle)g(d'une)g(autre)f(:)148 1990 y(\(3;)8
b(4;)g(0\))13 b(;)148 2184 y(on)21 b(en)h(d\351duit)g(une)f
(repr\351sentation)g(param\351trique)h(de)f(la)h(droite)i
FF(d)h FN(:)2366 2025 y Fo(8)2366 2093 y(<)2366 2231
y(:)2474 2082 y FF(x)87 b FC(\306)c FN(3)p FI(\270)2478
2182 y FF(y)g FC(\306)g FN(4)p FI(\270)10 b FC(\305)g
FN(2)155 b(\()p FI(\270)14 b FC(2)h Fk(R)p FN(\))2475
2282 y FF(z)89 b FC(\306)83 b(\241)p FN(1)3509 2320 y
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 -6.4726 -58.25336
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 38.83557 12.94519
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial -128 2356 a
SDict begin H.S end
 -128 2356 a -128
2356 a
SDict begin 12 H.A end
 -128 2356 a -128 2356 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.2) cvn /DEST pdfmark end
 -128 2356 a 202 x FP(Exercice)23
b(n)297 2532 y Fb(o)343 2558 y FP(2)p 430 2533 3222 4
v -128 2696 a FN(L)-8 b('espace)28 b(est)e(rapport\351)i(au)f
(rep\350re)f(orthonorm\351)1476 2609 y Fo(\263)1507 2696
y FN(O;)1586 2677 y FH(~)1600 2696 y FF(i)s FG(,)1644
2677 y FH(~)1661 2696 y FF(j)s FG(,)1702 2676 y FH(~)1711
2696 y FF(k)1757 2609 y Fo(\264)1789 2696 y FN(.)h(On)g(consid\350re)g
(les)g(points)34 b FF(A)s FN(\(3)27 b(;)35 b(0)27 b(;)36
b(6\))27 b(et)k FF(I)5 b FN(\(0)27 b(;)36 b(0)27 b(;)36
b(6\),)-128 2808 y(et)26 b(l'on)h(appelle)f FH(\242)53
b FN(la)27 b(droite)f(passant)g(par)33 b FF(A)d FN(et)g
FF(I)5 b FN(.)28 b(On)e(appelle)h FI(\274)f FN(le)g(plan)h
(d'\351quation)f(2)7 b FF(y)12 b FC(\305)k FF(z)e FC(\241)e
FN(6)17 b FC(\306)h FN(0)26 b(et)g FI(\303)g FN(le)g(plan)-128
2907 y(d'\351quation)j FF(y)10 b FC(\241)g FN(2)t FF(z)i
FC(\305)e FN(12)k FC(\306)g FN(0.)-128 2938 y
SDict begin H.S end
 -128 2938
a -128 2938 a
SDict begin 12 H.A end
 -128 2938 a -128 2938 a
SDict begin [/View [/XYZ H.V]/Dest (Item.13) cvn /DEST pdfmark end
 -128 2938 a 0 TeXcolorgray
98 x FP(1.)p 0 TeXcolorgray 141 w FN(D\351montrer)21
b(que)g FI(\274)h FN(et)f FI(\303)g FN(sont)g(perpendiculaires)n(.)-128
3068 y
SDict begin H.S end
 -128 3068 a -128 3068 a
SDict begin 12 H.A end
 -128 3068 a -128 3068
a
SDict begin [/View [/XYZ H.V]/Dest (Item.14) cvn /DEST pdfmark end
 -128 3068 a 0 TeXcolorgray 96 x FP(2.)p 0 TeXcolorgray
141 w FN(D\351montrer)g(que)g(l'intersection)h(des)f(plans)h
FI(\274)f FN(et)g FI(\303)h FN(est)f(la)g(droite)h FH(\242)p
FN(.)-128 3196 y
SDict begin H.S end
 -128 3196 a -128 3196 a
SDict begin 12 H.A end
 -128 3196 a
-128 3196 a
SDict begin [/View [/XYZ H.V]/Dest (Item.15) cvn /DEST pdfmark end
 -128 3196 a 0 TeXcolorgray 96 x FP(3.)p 0
TeXcolorgray 141 w FN(D\351montrer)i(que)h FI(\274)f
FN(et)g FI(\303)h FN(coupent)g(l'axe)1390 3228 y Fo(\241)1419
3292 y FN(O)d(;)1552 3255 y FC(\241)-57 b(!)1574 3292
y FI(|)1626 3228 y Fo(\242)1681 3292 y FN(\(l'axe)24
b(\()p FF(O)9 b(y)p FN(\)\))25 b(et)f(d\351terminer)h(les)f
(coordonn\351es)g(des)g(points)i FF(B)78 3392 y FN(et)d
FF(C)s FN(,)e(intersections)h(respectives)f(de)h FI(\274)f
FN(et)g FI(\303)g FN(a)o(vec)h(l'axe)1877 3328 y Fo(\241)1906
3392 y FN(O)g(;)2039 3355 y FC(\241)-57 b(!)2061 3392
y FI(|)2114 3328 y Fo(\242)2143 3392 y FN(.)-128 3431
y
SDict begin H.S end
 -128 3431 a -128 3431 a
SDict begin 12 H.A end
 -128 3431 a -128 3431 a
SDict begin [/View [/XYZ H.V]/Dest (Item.16) cvn /DEST pdfmark end
 -128
3431 a 0 TeXcolorgray 110 x FP(4.)p 0 TeXcolorgray 141
w FN(D\351montrer)17 b(qu'une)h(\351quation)f(du)h(plan)g
FI(\271)g FN(passant)f(par)j FF(B)e FN(et)g(de)f(vecteur)h(normal)2677
3485 y FC(\241)-28 b(\241)g(!)2683 3541 y FF(A)t(C)28
b FN(est)175 b FF(x)s FC(\305)r FN(4)7 b FF(y)s FC(\305)r
FN(2)t FF(z)t FC(\241)r FN(12)14 b FC(\306)78 3641 y
FN(0)p FG(.)-128 3656 y
SDict begin H.S end
 -128 3656 a -128 3656 a
SDict begin 12 H.A end
 -128
3656 a -128 3656 a
SDict begin [/View [/XYZ H.V]/Dest (Item.17) cvn /DEST pdfmark end
 -128 3656 a 0 TeXcolorgray 113 x FP(5.)p
0 TeXcolorgray 141 w FN(Donner)22 b(une)f(repr\351sentation)g
(param\351trique)h(de)f(la)h(droite)g(\()p FF(O)8 b(A)s
FN(\).)78 3869 y(D\351montrer)24 b(que)g(la)g(droite)g(\(O)6
b FF(A)s FN(\))24 b(et)g(le)g(plan)h FI(\271)f FN(sont)f(s\351cants)h
(en)g(un)g(point)j FF(H)i FN(dont)24 b(on)g(d\351terminera)g(les)f
(coor)m(-)78 3968 y(donn\351es)n(.)p 0 TeXcolorgray 0
TeXcolorgray 2046 5601 a
tx@Dict begin tx@NodeDict begin {-204.85968 -34.14328 } false /N@C
10 {InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot
/Dot { moveto gsave 1.  1.  scale (b) show grestore } bind def  tx@NodeDict
begin tx@NodeDict /N@C known { /N@C load GetCenter } { 0 0 } ifelse
end Dot end


@endspecial 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot  mark RAngle /ps@a ED cleartomark
ps@a neg def grestore  end
 2046
5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@C known { 9.29993
135. /N@C load 0 GetEdge 0.0 135. AddOffset /N@C load GetCenter 3 -1
roll add 3 1 roll add exch } { CP } ifelse end } PutCoor PutBegin 
end
 2046 5601 a 2046 5601 a
tx@Dict begin ps@rot  RotBegin  end
 2046 5601
a 2017 5629 a FF(C)2046 5601 y
tx@Dict begin RotEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {51.21492 8.53581 } false /N@B 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot
/Dot { moveto gsave 1.  1.  scale (b) show grestore } bind def  tx@NodeDict
begin tx@NodeDict /N@B known { /N@B load GetCenter } { 0 0 } ifelse
end Dot end


@endspecial 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot  mark RAngle /ps@a ED cleartomark
ps@a neg def grestore  end
 2046
5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@B known { 9.29993
-90. /N@B load 0 GetEdge 0.0 -90. AddOffset /N@B load GetCenter 3 -1
roll add 3 1 roll add exch } { CP } ifelse end } PutCoor PutBegin 
end
 2046 5601 a 2046 5601 a
tx@Dict begin ps@rot  RotBegin  end
 2046 5601
a 2018 5629 a FF(B)2046 5601 y
tx@Dict begin RotEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {0.0 102.42984 } false /N@I 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot
/Dot { moveto gsave 1.  1.  scale (b) show grestore } bind def  tx@NodeDict
begin tx@NodeDict /N@I known { /N@I load GetCenter } { 0 0 } ifelse
end Dot end


@endspecial 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot  mark RAngle /ps@a ED cleartomark
ps@a neg def grestore  end
 2046
5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@I known { 9.29993
45. /N@I load 0 GetEdge 0.0 45. AddOffset /N@I load GetCenter 3 -1
roll add 3 1 roll add exch } { CP } ifelse end } PutCoor PutBegin 
end
 2046 5601 a 2046 5601 a
tx@Dict begin ps@rot  RotBegin  end
 2046 5601
a 2029 5629 a FF(I)2046 5601 y
tx@Dict begin RotEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {0.0 0.0 } false /N@O 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot
/Dot { moveto gsave 1.  1.  scale (b) show grestore } bind def  tx@NodeDict
begin tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse
end Dot end


@endspecial 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot  mark RAngle /ps@a ED cleartomark
ps@a neg def grestore  end
 2046
5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@O known { 9.29993
-130. /N@O load 0 GetEdge 0.0 -130. AddOffset /N@O load GetCenter 3
-1 roll add 3 1 roll add exch } { CP } ifelse end } PutCoor PutBegin
 end
 2046 5601 a 2046 5601 a
tx@Dict begin ps@rot  RotBegin  end
 2046 5601
a 2015 5629 a FF(O)2046 5601 y
tx@Dict begin RotEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {-144.68225 -50.77103 } false /N@E
10 {InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {60.26286 85.8534 } false /N@F 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046
5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {111.46085 -8.04062 } false /N@H 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {-231.61096 -38.599 } false /N@N 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601
a 2046 5601 a
tx@Dict begin tx@NodeDict begin {153.64476 25.60745 } false /N@R 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {0.0 170.7164 } false /N@Q 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a 2046
5601 a
tx@Dict begin tx@NodeDict begin {153.64476 60.26286 } false /N@T 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {-91.38443 -15.22786 } false /N@D 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601
a
tx@Dict begin tx@NodeDict begin {98.14473 16.35449 } false /N@G 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {0.0 45.71774 } false /N@J 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {-204.85968 158.7663 } false /N@S 10
{InitPnode } /NodeScale {} def NewNode end end
 2046
5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {153.64476 -42.25241 } false /N@P 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {17.07164 2.84535 } false /N@Y 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601
a 2046 5601 a
tx@Dict begin tx@NodeDict begin {14.25493 -3.89227 } false /N@X 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a 2046 5601 a
tx@Dict begin tx@NodeDict begin {0.0 17.07164 } false /N@Z 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046 5601 a 2046
5601 a
tx@Dict begin tx@NodeDict begin {43.66922 75.14923 } false /N@K 10
{InitPnode } /NodeScale {} def NewNode end end
 2046 5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ tx@NodeDict begin tx@NodeDict
/N@I known { /N@I load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@F known { /N@F load GetCenter } { 0 0 } ifelse end tx@NodeDict
begin tx@NodeDict /N@H known { /N@H load GetCenter } { 0 0 } ifelse
end tx@NodeDict begin tx@NodeDict /N@B known { /N@B load GetCenter
} { 0 0 } ifelse end   /Lineto /lineto load def 1  setlinejoin false
NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{
n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.9412 0.9004 0.847  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ tx@NodeDict begin tx@NodeDict
/N@I known { /N@I load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@F known { /N@F load GetCenter } { 0 0 } ifelse end tx@NodeDict
begin tx@NodeDict /N@E known { /N@E load GetCenter } { 0 0 } ifelse
end tx@NodeDict begin tx@NodeDict /N@C known { /N@C load GetCenter
} { 0 0 } ifelse end   /Lineto /lineto load def 1  setlinejoin false
NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{
n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.932 0.912 0.75  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 2046 5601 a
tx@Dict begin tx@NodeDict begin {42.54259 90.7358 } false /N@A 10 {InitPnode
} /NodeScale {} def NewNode end end
 2046
5601 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray    /DS 2.0 2. CLW mul
add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot
/Dot { moveto gsave 1.  1.  scale (b) show grestore } bind def  tx@NodeDict
begin tx@NodeDict /N@A known { /N@A load GetCenter } { 0 0 } ifelse
end Dot end
 
@endspecial 2046 5601
a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@rot  mark RAngle /ps@a ED cleartomark
ps@a neg def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@A known { 9.29993
45. /N@A load 0 GetEdge 0.0 45. AddOffset /N@A load GetCenter 3 -1
roll add 3 1 roll add exch } { CP } ifelse end } PutCoor PutBegin 
end
 2046
5601 a 2046 5601 a
tx@Dict begin ps@rot  RotBegin  end
 2046 5601 a 2020 5629 a FF(A)2046
5601 y
tx@Dict begin RotEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@C
known { /N@C load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@N known { /N@N load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@D
known { /N@D load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@C known { /N@C load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@B
known { /N@B load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@D known { /N@D load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@G
known { /N@G load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@B known { /N@B load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@R
known { /N@R load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@G known { /N@G load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@J
known { /N@J load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@I
known { /N@I load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@J known { /N@J load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@Q
known { /N@Q load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@I known { /N@I load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@T
known { /N@T load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@S known { /N@S load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@P
known { /N@P load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@O known { /N@O load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@X known { /N@X load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known { /N@O
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.5 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Y known { /N@Y load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known { /N@O
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.5 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@Z known { /N@Z load GetCenter
} { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@O known { /N@O
load GetCenter } { 0 0 } ifelse end    /Lineto /lineto load def 1 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.5 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@A
known { /N@A load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@C known { /N@C load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@K
known { /N@K load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@A known { /N@A load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add  DotLine  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ tx@NodeDict begin tx@NodeDict /N@B
known { /N@B load GetCenter } { 0 0 } ifelse end tx@NodeDict begin
tx@NodeDict /N@K known { /N@K load GetCenter } { 0 0 } ifelse end 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle -45.  def grestore  end
 2046 5601 a 2046
5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@E known { /N@E load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 7.11 5.105 2.185 -45.  Uput UUput } PutCoor PutBegin
 end
 2046 5601 a 2016 5613
a FI(\303)2046 5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601
a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle -45.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@H known { /N@H load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046
5601 a
tx@Dict begin { 5.0 5.87 4.42499 0.09499 -45.  Uput UUput } PutCoor
PutBegin  end
 2046 5601 a 2022 5619 a FI(\274)2046 5601 y
tx@Dict begin  PutEnd  end
 2046
5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle 45.  def grestore  end
 2046 5601
a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@T known { /N@T load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 6.76999 6.51 0.0 45.  Uput UUput } PutCoor PutBegin
 end
 2046 5601 a 2018
5628 a FH(\242)2046 5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046
5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle 45.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@P known { /N@P load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601
a 2046 5601 a
tx@Dict begin { 5.0 3.09 2.65498 0.09 45.  Uput UUput } PutCoor PutBegin
 end
 2046 5601 a 2035 5612 a Fm(x)2046 5601
y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle -45.  def grestore  end
 2046
5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@R known { /N@R load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 3.32999 2.65498 1.146 -45.  Uput UUput } PutCoor
PutBegin  end
 2046 5601
a 2036 5607 a Fm(y)2046 5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  gsave STV CP T /ps@refangle -45.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Q known { /N@Q load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046
5601 a 2046 5601 a
tx@Dict begin { 5.0 3.006 2.65498 0.09 -45.  Uput UUput } PutCoor PutBegin
 end
 2046 5601 a 2036 5612 a Fm(z)2046
5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@X known { /N@X load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 5.3855 6.26698 0.09 180.  Uput UUput } PutCoor
PutBegin  end
 2046
5601 a 2024 5594 a Fa(\241)-34 b(!)2036 5627 y Fm(i)2046
5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  gsave STV CP T /ps@refangle 135.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Y known { /N@Y load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 5.3855 6.26698 1.146 135.  Uput UUput } PutCoor
PutBegin  end
 2046
5601 a 2024 5589 a Fa(\241)g(!)2039 5622 y Fm(j)2046
5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601
a
tx@Dict begin  gsave STV CP T /ps@refangle -135.  def grestore  end
 2046 5601 a 2046 5601 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@Z known { /N@Z load
GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 2046 5601 a 2046 5601 a
tx@Dict begin { 5.0 5.3855 6.36899 0.09 -135.  Uput UUput } PutCoor
PutBegin  end
 2046
5601 a 2024 5593 a Fa(\241)g(!)2031 5627 y Fm(k)2046
5601 y
tx@Dict begin  PutEnd  end
 2046 5601 a 2046 5601 a
tx@Dict begin  PutEnd  end
 2046 5601 a 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 15 15
TeXDict begin 15 14 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.15) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(15)p 109 -238 3780 2 v 0 TeXcolorgray 109 -38 a
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 17.26025 2.15753 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 4.31506 -43.15063 4.31506 2.15753
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 164 w FP(Solutions)109 -51 y
SDict begin H.S end

109 -51 a 109 -51 a
SDict begin 12 H.A end
 109 -51 a 109 -51 a
SDict begin [/View [/XYZ H.V]/Dest (Item.18) cvn /DEST pdfmark end
 109 -51 a 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 252 62 a FP(1.)p 0 TeXcolorgray
141 w FN(Les)19 b(plans)h FI(\274)f FN(et)f FI(\303)i
FN(ont)f(pour)g(vecteurs)g(normaux)h(respectifs)2389
25 y FC(\241)-57 b(!)2399 62 y FF(n)17 b FN(\(0;)8 b(2;)g(1\))20
b(et)2810 -1 y FC(\241)-52 b(!)2812 62 y FF(n)2859 31
y Fw(0)2889 62 y FN(\(0)19 b(;)28 b(1)19 b(;)28 b FC(\241)p
FN(2\).)19 b(On)g(a)3489 25 y FC(\241)-57 b(!)3499 62
y FF(n)23 b FC(\242)3596 -1 y(\241)-52 b(!)3598 62 y
FF(n)3645 31 y Fw(0)3690 62 y FC(\306)458 183 y FN(0,)22
b(donc)730 146 y FC(\241)-57 b(!)740 183 y FF(n)31 b
FC(?)892 120 y(\241)-52 b(!)894 183 y FF(n)941 152 y
Fw(0)993 183 y FN(et)21 b(par)h(suite)o(,)f(les)h(plans)g
FI(\274)f FN(et)g FI(\303)g FN(sont)g(perpendiculaires)n(.)109
215 y
SDict begin H.S end
 109 215 a 109 215 a
SDict begin 12 H.A end
 109 215 a 109 215 a
SDict begin [/View [/XYZ H.V]/Dest (Item.19) cvn /DEST pdfmark end
 109 215
a 0 TeXcolorgray 252 311 a FP(2.)p 0 TeXcolorgray 141
w FN(L)-8 b('intersection)22 b(des)f(plans)h FI(\274)f
FN(et)g FI(\303)h FN(est)f(une)g(droite)h(\(plans)g
(perpendiculaires\).)464 410 y FF(A)c FC(2)c FI(\274)21
b FN(car)h(2)10 b FC(\243)g FN(0)g FC(\305)g FN(6)g FC(\241)g
FN(6)15 b FC(\306)f FN(0)22 b(et)27 b FF(A)17 b FC(2)e
FI(\303)21 b FN(car)h(0)10 b FC(\241)g FN(12)g FC(\305)g
FN(12)15 b FC(\306)f FN(0,)22 b(donc)28 b FF(A)17 b FC(2)e
FI(\274)10 b FC(\\)g FI(\303)j FN(;)458 510 y(on)21 b(montre)g(de)g(la)
h(m\352me)e(fa\347on)h(que)k FF(I)c FC(2)14 b FI(\274)c
FC(\\)g FI(\303)p FN(.)458 610 y(Les)25 b(points)32 b
FF(A)d FN(et)g FF(I)i FN(\351tant)25 b(distincts)n(,)i(la)f(droite)f
(d'intersection)h(des)f(plans)h FI(\274)f FN(et)g FI(\303)h
FN(est)e(donc)i(la)g(droite)458 709 y(\()6 b FF(A)h(I)e
FN(\),)23 b(c'est-\340-dire)e(la)g(droite)h FH(\242)p
FN(.)109 738 y
SDict begin H.S end
 109 738 a 109 738 a
SDict begin 12 H.A end
 109 738 a 109 738
a
SDict begin [/View [/XYZ H.V]/Dest (Item.20) cvn /DEST pdfmark end
 109 738 a 0 TeXcolorgray 252 882 a FP(3.)p 0 TeXcolorgray
141 w FN(Soit)d FF(M)t FN(\()s FF(x)e FN(;)32 b FF(y)17
b FN(;)29 b FF(z)r FN(\))15 b(un)i(point)g(de)f(l'espace)o(.)j
FF(M)i FN(appartient)c(\340)f(l'axe)2472 795 y Fo(\263)2503
882 y FF(O)r FN(;)2594 827 y FC(\241)-57 b(!)2621 882
y FF(j)2670 795 y Fo(\264)2718 882 y FN(si)16 b(et)g(seulement)g(si)
3341 772 y Fo(\275)3432 830 y FF(x)84 b FC(\306)f FN(0)3434
930 y FF(z)i FC(\306)e FN(0)3787 882 y(.)461 1139 y FF(M)28
b FN(appartient)d(\340)f(l'axe)1219 1052 y Fo(\263)1250
1139 y FF(O)r FN(;)1341 1084 y FC(\241)-57 b(!)1368 1139
y FF(j)1417 1052 y Fo(\264)1472 1139 y FN(et)23 b(au)h(plan)h
FI(\274)e FN(si)h(et)g(seulement)f(si)2586 980 y Fo(8)2586
1049 y(<)2586 1186 y(:)2835 1038 y FF(x)224 b FC(\306)83
b FN(0)2837 1138 y FF(z)225 b FC(\306)83 b FN(0)2691
1237 y(2)7 b FF(y)j FC(\305)k FF(z)e FC(\241)e FN(6)83
b FC(\306)g FN(0)3355 1139 y(c'est-\340-dire)458 1446
y(si)21 b(et)h(seulement)e(si)1101 1287 y Fo(8)1101 1356
y(<)1101 1494 y(:)1213 1345 y FF(x)83 b FC(\306)g FN(0)1213
1445 y FF(y)g FC(\306)g FN(3)1215 1544 y FF(z)h FC(\306)f
FN(0)1568 1446 y(.)22 b(Le)f(plan)i FI(\274)e FN(coupe)g(donc)h(l'axe)
2568 1359 y Fo(\263)2599 1446 y FF(O)r FN(;)2690 1391
y FC(\241)-57 b(!)2717 1446 y FF(j)2766 1359 y Fo(\264)2819
1446 y FN(au)21 b(point)i FF(B)r FN(\(0)d(;)30 b(3)22
b(;)30 b(0\).)458 1673 y(Un)18 b(raisonnement)e(analogue)i(montre)f
(que)g(le)g(plan)i FI(\303)e FN(coupe)h(l'axe)2592 1586
y Fo(\263)2624 1673 y FF(O)r FN(;)2715 1618 y FC(\241)-57
b(!)2741 1673 y FF(j)2790 1586 y Fo(\264)2839 1673 y
FN(en)18 b(un)f(point)i FF(C)s FN(\(0)e(;)26 b FC(\241)p
FN(12)18 b(;)26 b(0\).)109 1787 y
SDict begin H.S end
 109 1787 a 109 1787
a
SDict begin 12 H.A end
 109 1787 a 109 1787 a
SDict begin [/View [/XYZ H.V]/Dest (Item.21) cvn /DEST pdfmark end
 109 1787 a 0 TeXcolorgray 252
1901 a FP(4.)p 0 TeXcolorgray 141 w FN(On)d(a)654 1844
y FC(\241)-28 b(\241)g(!)660 1901 y FF(A)t(C)11 b FN(\()p
FC(\241)p FN(3)22 b(;)32 b FC(\241)p FN(12)22 b(;)32
b FC(\241)p FN(6\))22 b(donc)h(le)g(plan)g FI(\271)g
FN(a)g(une)g(\351quation)f(cart\351sienne)h(de)g(la)g(forme)e(:)j
FC(\241)p FN(3)s FF(x)11 b FC(\241)g FN(12)c FF(y)j FC(\241)458
2000 y FN(6)t FF(z)i FC(\305)g FF(d)18 b FC(\306)c FN(0.)22
b(Et)g FF(B)r FN(\(0)e(;)30 b(3)22 b(;)8 b(0\))14 b FC(2)h
FI(\271)p FN(,)22 b(donc)g(0)10 b FC(\241)g FN(12)g FC(\243)g
FN(3)g FC(\241)g FN(0)g FC(\305)i FF(d)19 b FC(\306)14
b FN(0,)22 b(d'o\371)h FF(d)18 b FC(\306)c FN(36.)458
2100 y(Le)22 b(plan)h FI(\271)f FN(a)g(donc)g(pour)h(\351quation)e
(cart\351sienne)h FC(\241)p FN(3)s FF(x)11 b FC(\241)f
FN(12)d FF(y)k FC(\241)f FN(6)t FF(z)i FC(\305)e FN(36)15
b FC(\306)f FN(0,)23 b(ou)e(encore)o(,)h(en)g(simpli\002ant)458
2200 y(par)g FC(\241)p FN(3)f(:)k FF(x)11 b FC(\305)f
FN(4)d FF(y)j FC(\305)g FN(2)t FF(z)i FC(\241)e FN(12)k
FC(\306)g FN(0.)109 2230 y
SDict begin H.S end
 109 2230 a 109 2230 a
SDict begin 12 H.A end
 109
2230 a 109 2230 a
SDict begin [/View [/XYZ H.V]/Dest (Item.22) cvn /DEST pdfmark end
 109 2230 a 0 TeXcolorgray 252 2341
a FP(5.)p 0 TeXcolorgray 141 w FN(La)21 b(droite)g(\()p
FF(O)8 b(A)s FN(\))21 b(passe)g(par)g FF(O)r FN(\(0)g(;)29
b(0)21 b(;)30 b(0\))20 b(et)g(a)h(pour)g(vecteur)h(directeur)2739
2284 y FC(\241)-26 b(\241)g(!)2739 2341 y FF(O)8 b(A)k
FN(\(3)21 b(;)29 b(0)21 b(;)29 b(6\).)21 b(Une)g(repr\351sen-)458
2536 y(tation)g(param\351trique)h(de)f(\()p FF(O)8 b(A)s
FN(\))22 b(est)f(donc)h(:)1861 2377 y Fo(8)1861 2446
y(<)1861 2583 y(:)1972 2435 y FF(x)84 b FC(\306)f FN(3)s
FF(t)1973 2535 y(y)g FC(\306)g FN(0)154 b(\()s FF(t)15
b FC(2)g Fk(R)p FN(\))1974 2634 y FF(z)85 b FC(\306)e
FN(6)s FF(t)2689 2536 y FN(.)458 2729 y(Un)17 b(point)j
FF(M)i FN(appartient)17 b(\340)g(la)g(droite)g(\()p FF(O)8
b(A)s FN(\))18 b(et)e(au)h(plan)h FI(\271)f FN(si)g(et)f(seulement)g
(si)h(il)h(existe)e(un)h(r\351el)j FF(t)e FN(tel)f(que)461
2864 y FF(M)t FN(\(3)s FF(t)22 b FN(;)29 b(0)20 b(;)29
b(6)s FF(t)p FN(\))22 b(et)e(\(3)s FF(t)p FN(\))8 b FC(\305)g
FN(4)g FC(\243)g FN(0)g FC(\305)g FN(2)g FC(\243)g FN(\(6)s
FF(t)p FN(\))g FC(\241)g FN(12)17 b FC(\306)d FN(0,)21
b(ce)f(qui)h(donne)g(une)f(unique)h(valeur)g(:)j FF(t)15
b FC(\306)3325 2808 y FN(4)p 3325 2845 43 5 v 3325 2921
a(5)3378 2864 y(.)21 b(La)g(droite)458 3044 y(\()p FF(O)8
b(A)s FN(\))23 b(et)f(le)g(plan)h FI(\271)g FN(sont)e(donc)i
(s\351cants)f(en)g(un)h(point)i FF(H)i FN(qui)c(a)f(pour)h
(coordonn\351es)3105 2934 y Fo(\265)3139 3044 y FN(3)10
b FC(\243)3267 2987 y FN(4)p 3267 3024 V 3267 3101 a(5)3342
3044 y(;)30 b(0)21 b(;)30 b(6)10 b FC(\243)3636 2987
y FN(4)p 3636 3024 V 3636 3101 a(5)3689 2934 y Fo(\266)3723
3044 y FN(,)458 3235 y(c'est-\340-dire)23 b FF(H)949
3125 y Fo(\265)993 3179 y FN(12)p 993 3216 86 5 v 1014
3292 a(5)1110 3235 y(;)30 b(0)22 b(;)1287 3179 y(24)p
1287 3216 V 1308 3292 a(5)1383 3125 y Fo(\266)1417 3235
y FN(.)3745 3335 y @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 -6.4726 -58.25336
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.42262 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 12.94519 38.83557 12.94519
-6.4726    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.42262 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 16 16
TeXDict begin 16 15 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.16) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(16)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (section.2.7) cvn /DEST pdfmark
end
 -128 -121 a 0.93 0.26 0 TeXcolorrgb 83 x FK(2.7)111
b(Exercices)p 0 TeXcolorgray -128 46 a
SDict begin H.S end
 -128 46 a -128
46 a
SDict begin 12 H.A end
 -128 46 a -128 46 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.7.1) cvn /DEST pdfmark
end
 -128 46 a 0.932 0.464 0 TeXcolorrgb
115 x FJ(2.7.1)93 b(Echauffements)p 0 TeXcolorgray -128
215 a
SDict begin H.S end
 -128 215 a -128 215 a
SDict begin 12 H.A end
 -128 215 a -128 215 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.3) cvn /DEST pdfmark end
 -128
215 a 201 x FP(Exercice)23 b(n)297 391 y Fb(o)343 416
y FP(3)p 430 391 3222 4 v -128 529 a FN(Donner)f(le)f(nombre)g(de)g
(faces)g(de)g(c)o(hacun)i(des)e(solides)h(suivants)g(:)p
0 TeXcolorgray 0 TeXcolorgray 155 1597 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 155 1597 a 177
1597 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 136.5737 a add def
/d 0.0 a add neg def /h 182.09827 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 177 1597 a -378 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 91.04913 0.0 91.04913 91.04913
45.52457 91.04913 0.0 45.52457 0.0 0.0   /Lineto /lineto load def 1
 setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop
pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0
ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div
def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.875  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 91.04913 0.0 136.5737 45.52457
136.5737 136.5737 91.04913 91.04913   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 91.04913 91.04913 45.52457
91.04913 22.76228 113.81142 45.52457 136.5737 136.5737 136.5737   /Lineto
/lineto load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def
} if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2
mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1
y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n
n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12
x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11 sub
Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add
def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add y11
Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.875
 setgray  1. .setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 45.52457 91.04913 0.0 45.52457
22.76228 113.81142   /Lineto /lineto load def 1  setlinejoin false
NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{
n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
1310 1597 a
currentpoint initclip moveto
 1310 1597 a 155 1597 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 155 1597 a 1259 1597
a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 1259 1597 a 1280 1597 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 171.62746 a add def
/d 0.0 a add neg def /h 239.00397 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1280 1597 a -189 x @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 68.74219 0.0 159.79132
90.59378 159.79132 204.4052 114.26675 158.88063 114.26675 204.4052
91.50447 181.64291 91.50447 67.8315 68.74219 45.06921 68.74219 22.30693
  /Lineto /lineto load def 1  setlinejoin false NArray n 2 eq { 0 0
/n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.875
 setgray  1. .setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 68.74219 45.06921 91.50447
67.8315 91.50447 181.64291 68.74219 181.64291 68.74219 158.88063 0.45534
158.88063 0.45534 136.11835 68.74219 136.11835 68.74219 67.8315 45.9799
45.06921 45.9799 0.0 68.74219 0.0   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 68.74219 158.88063 68.74219
181.64291 23.21762 181.64291 0.45534 158.88063   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.875  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 91.50447 181.64291 114.26675
204.4052 91.50447 204.4052 68.74219 181.64291   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.875  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 114.26675 158.88063 114.26675
181.18793 137.02904 204.4052 159.79132 204.4052   /Lineto /lineto load
def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt {
n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0
ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add
2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.875  setgray  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 68.28685 45.52457 45.52457 45.52457
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 91.04913 68.28685 68.28685 68.28685
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 2705 1597 a
currentpoint initclip moveto
 2705 1597 a 1259
1597 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 1259 1597 a 2508 1597 a
 currentpoint currentpoint translate 0.5 0.5 scale neg exch neg exch
translate
 2508 1597 a 2530 1597
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 204.86055 a add def
/d 0.0 a add neg def /h 204.86055 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 2530 1597 a -378 x @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 68.28685 68.28685 45.52457
45.52457 45.52457 68.28685 68.28685 91.04913 113.81142 91.04913 113.81142
68.28685 159.33598 68.28685 159.33598 136.5737 182.09827 136.5737 182.09827
0.0 68.28685 0.0   /Lineto /lineto load def 1  setlinejoin false NArray
n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt
{ CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1
x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div
def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 0.0 68.28685 45.52457 68.28685
45.52457 45.52457 0.0 45.52457   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 45.52457 68.28685 68.28685
91.04913 113.81142 91.04913 136.5737 113.81142 45.52457 113.81142 0.0
68.28685   /Lineto /lineto load def 1  setlinejoin false NArray n 2
eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed
} if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1
def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto
/n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub
x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11
sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos
add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add
y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.875
 setgray  1. .setopacityalpha  fill  grestore gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 113.81142 91.04913 113.81142
68.28685 159.33598 68.28685 159.33598 91.04913 136.5737 91.04913 136.5737
113.81142   /Lineto /lineto load def 1  setlinejoin false NArray n
2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt {
CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1
def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def
x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 182.09827 136.5737 159.33598
136.5737 182.09827 159.33598 204.86055 159.33598 204.86055 22.76228
182.09827 0.0   /Lineto /lineto load def 1  setlinejoin false NArray
n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat }{ n 3 gt
{ CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1
x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div
def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha
y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length x12 x11
sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos
dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos
mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside known
{ ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.
 1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 0.875  setgray  1. .setopacityalpha  fill  grestore
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 136.5737 91.04913 113.81142 68.28685
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 204.86055 159.33598 182.09827 136.5737
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
4230 1597 a
currentpoint initclip moveto
 4230 1597 a 2508 1597 a
 currentpoint currentpoint translate 1 0.5 div 1 0.5 div scale neg
exch neg exch translate
 2508 1597 a -128
1663 a
SDict begin H.S end
 -128 1663 a -128 1663 a
SDict begin 12 H.A end
 -128 1663 a -128 1663
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.4) cvn /DEST pdfmark end
 -128 1663 a 202 x FP(Exercice)h(n)297 1840 y Fb(o)343
1865 y FP(4)p 430 1840 3222 4 v -128 1979 a FN(ABCDEFGH)f(est)f(un)g
(pa)o(v\351,)i(I)f(est)f(le)g(milieu)h(de)f([EF])g(et)h(J)f(le)g
(milieu)h(de)g([HG].)p 0 TeXcolorgray 0 TeXcolorgray
1384 2720 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 0.0 45.52457 40.97217 68.28685
122.9165 68.28685 122.9165 22.76228 81.94434 0.0 0.0 0.0   /Lineto
/lineto load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def
} if n 3 lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2
mul -2 roll /y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1
y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n
n 2 sub def /drawArrows { x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12
x11 sub atan def /ArrowPos 0.  def /Length x12 x11 sub y12 y11 sub
Pyth def /dArrowPos 0.5  abs def { /ArrowPos ArrowPos dArrowPos add
def ArrowPos Length gt { exit } if x11 Alpha cos ArrowPos mul add y11
Alpha sin ArrowPos mul add currentdict /ArrowInside known { ArrowInside
} if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.
 1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos
add def x12 x11 sub ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11
add currentdict /ArrowInside known { ArrowInside } if pop pop } repeat
} ifelse pop pop Lineto } def n { 4 copy /y11 ED /x11 ED /y12 ED /x12
ED drawArrows } repeat x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED
/y12 y0 def /x12 x0 def drawArrows /y11 y0 def /x11 x0 def /y12 yy1
def /x12 xx1 def drawArrows pop pop closepath } ifelse   gsave 0.8
SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 81.94434 0.0 81.94434 45.52457 0.0
45.52457    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 122.9165 68.28685 81.94434 45.52457
   /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 122.9165 22.76228 40.97217
22.76228 0.0 0.0    /Lineto /lineto load def 1  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   0  setlinecap
[  5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0.5  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 40.97217 68.28685 40.97217
22.76228    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0.5  setgray  1. .setopacityalpha   0  setlinecap
[  5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ 81.94434 68.28685
40.97217 45.52457   false NArray  /DS 2.0 2. CLW mul add 2 div def
/PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto
gsave 1.  1.  scale (b) show grestore } bind def  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial
1384 2720 a
tx@Dict begin { -8.1943 -4.55238 } PutCoor PutBegin  end
 1384 2720 a 1356 2748 a FN(A)1384 2720 y
tx@Dict begin  PutEnd  end

1384 2720 a 1384 2720 a
tx@Dict begin { 81.94434 -4.55238 } PutCoor PutBegin  end
 1384 2720 a 1356 2748 a FN(B)1384
2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720 a
tx@Dict begin { 45.06963 52.35332 } PutCoor PutBegin  end
 1384 2720 a 1368 2748
a FN(I)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720 a
tx@Dict begin { 86.0418 75.1156 } PutCoor PutBegin  end
 1384 2720
a 1363 2748 a FN(J)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720
a
tx@Dict begin { 90.13864 40.97217 } PutCoor PutBegin  end
 1384 2720 a 1358 2748 a FN(F)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720
a 1384 2720 a
tx@Dict begin { -8.1943 45.52457 } PutCoor PutBegin  end
 1384 2720 a 1356 2748 a FN(E)1384 2720
y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720 a
tx@Dict begin { 32.77785 25.03865 } PutCoor PutBegin  end
 1384 2720 a 1354 2748 a FN(D)1384
2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720 a
tx@Dict begin { 131.11081 22.76228 } PutCoor PutBegin  end
 1384 2720 a 1356 2748
a FN(C)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720 a
tx@Dict begin { 127.01396 75.1156 } PutCoor PutBegin  end
 1384 2720
a 1354 2748 a FN(G)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720 a 1384 2720
a
tx@Dict begin { 40.97217 75.1156 } PutCoor PutBegin  end
 1384 2720 a 1352 2748 a FN(H)1384 2720 y
tx@Dict begin  PutEnd  end
 1384 2720
a -128 2772 a
SDict begin H.S end
 -128 2772 a -128 2772 a
SDict begin 12 H.A end
 -128 2772 a -128
2772 a
SDict begin [/View [/XYZ H.V]/Dest (Item.23) cvn /DEST pdfmark end
 -128 2772 a 0 TeXcolorgray 114 x FP(1.)p 0 TeXcolorgray
141 w FN(Donner)g(respectivement)f(:)-128 2916 y
SDict begin H.S end
 -128
2916 a -128 2916 a
SDict begin 12 H.A end
 -128 2916 a -128 2916 a
SDict begin [/View [/XYZ H.V]/Dest (Item.24) cvn /DEST pdfmark end
 -128 2916
a 0 TeXcolorgray 78 3014 a FN(\(a\))p 0 TeXcolorgray
41 w(Une)g(droite)h(parall\350le)g(\340)g(la)f(droite)h(\(IJ\),)g(non)f
(coplanaire)h(au)g(plan)g(\(EHF\))f(et)h(s\351cante)e(\340)i(la)f
(droite)h(\(GB\).)-128 3044 y
SDict begin H.S end
 -128 3044 a -128 3044 a
SDict begin 12 H.A end

-128 3044 a -128 3044 a
SDict begin [/View [/XYZ H.V]/Dest (Item.25) cvn /DEST pdfmark end
 -128 3044 a 0 TeXcolorgray 78
3142 a FN(\(b\))p 0 TeXcolorgray 41 w(Un)g(plan)g(parall\350le)g(au)g
(plan)g(\(IJG\))f(et)g(s\351cant)h(au)f(plan)h(\(EAD\).)-128
3173 y
SDict begin H.S end
 -128 3173 a -128 3173 a
SDict begin 12 H.A end
 -128 3173 a -128 3173
a
SDict begin [/View [/XYZ H.V]/Dest (Item.26) cvn /DEST pdfmark end
 -128 3173 a 0 TeXcolorgray 85 3271 a FN(\(c\))p 0 TeXcolorgray
42 w(Une)f(droite)h(parall\350le)g(au)f(plan)h(\(ABC\),)f(s\351cante)g
(au)g(plan)i(\(FGC\))e(et)g(confondue)g(dans)h(le)f(plan)h(\(HGF\).)
-128 3301 y
SDict begin H.S end
 -128 3301 a -128 3301 a
SDict begin 12 H.A end
 -128 3301 a -128
3301 a
SDict begin [/View [/XYZ H.V]/Dest (Item.27) cvn /DEST pdfmark end
 -128 3301 a 0 TeXcolorgray 98 x FP(2.)p 0 TeXcolorgray
141 w FN(\311tudier)g(la)g(position)g(relative)g(des)f(droites)g
(suivantes)h(:)-128 3429 y
SDict begin H.S end
 -128 3429 a -128 3429 a
SDict begin 12 H.A end
 -128
3429 a -128 3429 a
SDict begin [/View [/XYZ H.V]/Dest (Item.28) cvn /DEST pdfmark end
 -128 3429 a 0 TeXcolorgray 78 3527
a FN(\(a\))p 0 TeXcolorgray 41 w(La)g(droite)g(\(BH\))f(et)g(la)h
(droite)f(\(BC\).)-128 3551 y
SDict begin H.S end
 -128 3551 a -128 3551 a
SDict begin 12 H.A end

-128 3551 a -128 3551 a
SDict begin [/View [/XYZ H.V]/Dest (Item.29) cvn /DEST pdfmark end
 -128 3551 a 0 TeXcolorgray 78
3656 a FN(\(b\))p 0 TeXcolorgray 41 w(La)h(droite)g(\(EG\))e(et)i(la)f
(droite\(BC\).)-128 3679 y
SDict begin H.S end
 -128 3679 a -128 3679 a
SDict begin 12 H.A end
 -128
3679 a -128 3679 a
SDict begin [/View [/XYZ H.V]/Dest (Item.30) cvn /DEST pdfmark end
 -128 3679 a 0 TeXcolorgray 85 3784
a FN(\(c\))p 0 TeXcolorgray 42 w(La)h(droite)f(\(EG\))g(et)g(la)h
(droite\(AC\).)-128 3808 y
SDict begin H.S end
 -128 3808 a -128 3808 a
SDict begin 12 H.A end
 -128
3808 a -128 3808 a
SDict begin [/View [/XYZ H.V]/Dest (Item.31) cvn /DEST pdfmark end
 -128 3808 a 0 TeXcolorgray 104 x FP(3.)p
0 TeXcolorgray 141 w FN(Quel)g(est,)f(dans)h(c)o(hacun)h(des)e(cas)g
(suivants)n(,)i(l'intersection)f(des)f(deux)h(plans)g(:)-128
3942 y
SDict begin H.S end
 -128 3942 a -128 3942 a
SDict begin 12 H.A end
 -128 3942 a -128 3942
a
SDict begin [/View [/XYZ H.V]/Dest (Item.32) cvn /DEST pdfmark end
 -128 3942 a 0 TeXcolorgray 78 4040 a FN(\(a\))p 0 TeXcolorgray
41 w(Le)g(plan)g(\(EIA\))f(et)g(le)g(plan)i(\(FIC\).)-128
4071 y
SDict begin H.S end
 -128 4071 a -128 4071 a
SDict begin 12 H.A end
 -128 4071 a -128 4071
a
SDict begin [/View [/XYZ H.V]/Dest (Item.33) cvn /DEST pdfmark end
 -128 4071 a 0 TeXcolorgray 78 4169 a FN(\(b\))p 0 TeXcolorgray
41 w(Le)f(plan)g(\(EHI\))f(et)h(le)f(plan)h(\(FJG\).)-128
4199 y
SDict begin H.S end
 -128 4199 a -128 4199 a
SDict begin 12 H.A end
 -128 4199 a -128 4199
a
SDict begin [/View [/XYZ H.V]/Dest (Item.34) cvn /DEST pdfmark end
 -128 4199 a 0 TeXcolorgray 85 4297 a FN(\(c\))p 0 TeXcolorgray
42 w(Le)f(plan)i(\(DAB\))d(et)h(le)h(plan)g(\(FJG\).)-128
4356 y
SDict begin H.S end
 -128 4356 a -128 4356 a
SDict begin 12 H.A end
 -128 4356 a -128 4356
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.5) cvn /DEST pdfmark end
 -128 4356 a 186 x FP(Exercice)h(n)297 4517 y Fb(o)343
4542 y FP(5)p 430 4517 3222 4 v -128 4655 a FN(ABCDEFGH)28
b(est)e(un)i(cube)f(dont)g(l'ar\352te)g(mesure)f(2)h(cm.)h(P)g(et)e(Q)i
(sont)f(les)f(centres)h(respectifs)g(des)g(faces)g(EFGH)g(et)-128
4755 y(BCGF)-10 b(.)-128 4764 y
SDict begin H.S end
 -128 4764 a -128 4764
a
SDict begin 12 H.A end
 -128 4764 a -128 4764 a
SDict begin [/View [/XYZ H.V]/Dest (Item.35) cvn /DEST pdfmark end
 -128 4764 a 0 TeXcolorgray
71 x FP(1.)p 0 TeXcolorgray 141 w FN(Tracer)21 b(en)e(vraie)h(grandeur)
h(le)f(patron)g(du)g(cube)f(\(a)o(vec)h(les)f(points)h(P)78
4934 y(et)i(Q\).)-128 4963 y
SDict begin H.S end
 -128 4963 a -128 4963 a
SDict begin 12 H.A end

-128 4963 a -128 4963 a
SDict begin [/View [/XYZ H.V]/Dest (Item.36) cvn /DEST pdfmark end
 -128 4963 a 0 TeXcolorgray 100
x FP(2.)p 0 TeXcolorgray 141 w FN(Calculer)p 402 4994
120 5 v 25 w FF(E)5 b(P)g FN(.)-128 5078 y
SDict begin H.S end
 -128 5078
a -128 5078 a
SDict begin 12 H.A end
 -128 5078 a -128 5078 a
SDict begin [/View [/XYZ H.V]/Dest (Item.37) cvn /DEST pdfmark end
 -128 5078 a 0 TeXcolorgray
113 x FP(3.)p 0 TeXcolorgray 141 w FN(Le)22 b(triangle)h(AEP)e(est-il)g
(rectangle)14 b(?)22 b(J)n(usti\002er)-8 b(.)-128 5221
y
SDict begin H.S end
 -128 5221 a -128 5221 a
SDict begin 12 H.A end
 -128 5221 a -128 5221 a
SDict begin [/View [/XYZ H.V]/Dest (Item.38) cvn /DEST pdfmark end
 -128
5221 a 0 TeXcolorgray 98 x FP(4.)p 0 TeXcolorgray 141
w FN(En)22 b(d\351duire)g(que)p 646 5249 123 5 v 27 w
FF(A)5 b(P)21 b FC(\306)852 5254 y(p)p 915 5254 43 5
v 915 5319 a FN(6)h(cm.)-128 5349 y
SDict begin H.S end
 -128 5349 a -128
5349 a
SDict begin 12 H.A end
 -128 5349 a -128 5349 a
SDict begin [/View [/XYZ H.V]/Dest (Item.39) cvn /DEST pdfmark end
 -128 5349 a 0 TeXcolorgray
98 x FP(5.)p 0 TeXcolorgray 141 w FN(En)g(utilisant)g(le)g(triangle)g
(BEG)m(,)g(calculer)p 1433 5378 123 5 v 25 w FF(P)5 b(Q)t
FN(.)-128 5478 y
SDict begin H.S end
 -128 5478 a -128 5478 a
SDict begin 12 H.A end
 -128 5478 a
-128 5478 a
SDict begin [/View [/XYZ H.V]/Dest (Item.40) cvn /DEST pdfmark end
 -128 5478 a 0 TeXcolorgray 98 x FP(6.)p 0
TeXcolorgray 141 w FN(Quel)34 b(nom)f(peut-on)f(donner)i(au)f(solide)g
(GEBF)13 b(?)34 b(Calculer)g(alors)78 5675 y(son)21 b(volume)o(.)2445
5598 y @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  [ 0.0 54.62933 27.31467 81.944
81.944 81.944 81.944 27.31467 54.62933 0.0 0.0 0.0   /Lineto /lineto
load def 1  setlinejoin false NArray n 2 eq { 0 0 /n 3 def } if n 3
lt { n { pop pop } repeat }{ n 3 gt { CheckClosed } if n 2 mul -2 roll
/y0 ED /x0 ED /y1 ED /x1 ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1
add 2 div def /y1 y0 y1 add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows
{ x11 y11 0.5  1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos
0.  def /Length x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs
def { /ArrowPos ArrowPos dArrowPos add def ArrowPos Length gt { exit
} if x11 Alpha cos ArrowPos mul add y11 Alpha sin ArrowPos mul add
currentdict /ArrowInside known { ArrowInside } if pop pop } loop }{
/ArrowPos 0.  def /dArrowPos 1.  1 gt {1.0 1.  1.0 add div }{ 0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x12 x11 sub
ArrowPos mul x11 add y12 y11 sub ArrowPos mul y11 add currentdict /ArrowInside
known { ArrowInside } if pop pop } repeat } ifelse pop pop Lineto }
def n { 4 copy /y11 ED /x11 ED /y12 ED /x12 ED drawArrows } repeat
x1 y1 x0 y0 6 4 roll 2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def
drawArrows /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows
pop pop closepath } ifelse   gsave 0.8 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 54.62933 0.0 54.62933 54.62933 0.0
54.62933    /Lineto /lineto load def 1  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 81.944 81.944 54.62933 54.62933   
/Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 81.944 27.31467 27.31467 27.31467 0.0
0.0    /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinecap
[  5.0  3.0  0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 27.31467 81.944 27.31467 27.31467 
  /Lineto /lineto load def 1  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  3.0
 0.0  0.0 ] 0 0 add  DashLine  grestore end
 
@endspecial 2445 5598 a
tx@Dict begin { -5.46284 -5.46284 } PutCoor PutBegin  end
 2445 5598 a 2417
5626 a FN(A)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445 5598 a
tx@Dict begin { 54.62933 -5.46284 } PutCoor PutBegin  end
 2445
5598 a 2417 5626 a FN(B)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445
5598 a
tx@Dict begin { 60.09218 54.62933 } PutCoor PutBegin  end
 2445 5598 a 2419 5626 a FN(F)2445 5598 y
tx@Dict begin  PutEnd  end
 2445
5598 a 2445 5598 a
tx@Dict begin { -5.46284 54.62933 } PutCoor PutBegin  end
 2445 5598 a 2417 5626 a FN(E)2445
5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445 5598 a
tx@Dict begin { 21.8518 27.31467 } PutCoor PutBegin  end
 2445 5598 a 2415 5626
a FN(D)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445 5598 a
tx@Dict begin { 87.40685 27.31467 } PutCoor PutBegin  end
 2445 5598
a 2417 5626 a FN(C)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445 5598
a
tx@Dict begin { 81.944 87.40685 } PutCoor PutBegin  end
 2445 5598 a 2415 5626 a FN(G)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598
a 2445 5598 a
tx@Dict begin { 27.31467 87.40685 } PutCoor PutBegin  end
 2445 5598 a 2413 5626 a FN(H)2445 5598
y
tx@Dict begin  PutEnd  end
 2445 5598 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8194 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 54.62933 81.944 81.944
54.62933 0.0    /Lineto /lineto load def 1  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8194 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8194 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 81.944 27.31467 54.62933 54.62933
27.31467 81.944    /Lineto /lineto load def 1  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8194 SLW 0  setgray  1. .setopacityalpha   3.0 0 0 add
 DotLine  grestore end
 
@endspecial 2445 5598 a
tx@Dict begin { 40.972 73.74951 } PutCoor PutBegin  end
 2445
5598 a 2419 5626 a FN(P)2445 5598 y
tx@Dict begin  PutEnd  end
 2445 5598 a 2445
5598 a
tx@Dict begin { 73.74951 40.972 } PutCoor PutBegin  end
 2445 5598 a 2415 5619 a FN(Q)2445 5598 y
tx@Dict begin  PutEnd  end
 2445
5598 a 0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 17 17
TeXDict begin 17 16 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.17) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(17)p 109 -238 3780 2 v 0 TeXcolorgray 109 -121 a
SDict begin H.S end

109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121 a
SDict begin [/View [/XYZ H.V]/Dest (subsection.2.7.2) cvn /DEST pdfmark
end
 109 -121
a 0.932 0.464 0 TeXcolorrgb 83 x FJ(2.7.2)92 b(Exercices)27
b(de)g(routine)p 0 TeXcolorgray 109 17 a
SDict begin H.S end
 109 17 a 109
17 a
SDict begin 12 H.A end
 109 17 a 109 17 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.6) cvn /DEST pdfmark end
 109 17 a 201 x FP(Exercice)22
b(n)533 192 y Fb(o)579 218 y FP(6)p 667 192 3222 4 v
109 356 a FN(Dans)f(l'espace)g(muni)h(d'un)g(rep\350re)1247
268 y Fo(\263)1278 356 y FN(O;)1357 337 y FH(~)1371 356
y FF(i)s FG(,)1415 337 y FH(~)1432 356 y FF(j)t FG(,)1474
336 y FH(~)1483 356 y FF(k)1528 268 y Fo(\264)1560 356
y FN(,)g(on)f(consid\350re)g(les)g(points)28 b FF(A)s
FN(\(5;)8 b(0;)g(0\),)24 b FF(B)r FN(\(5;)8 b(9;)g(0\),)22
b FF(C)s FN(\(0;)8 b(9;)g(0\))22 b(et)h FF(S)s FN(\(0;)8
b(9;)g(9\).)p 0 TeXcolorgray 0 TeXcolorgray 1573 2456
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 250.38512 0.0  0.0 0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 22.76228 250.38512 0.0  22.76228
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 45.52457 250.38512 0.0  45.52457
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 68.28685 250.38512 0.0  68.28685
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 91.04913 250.38512 0.0  91.04913
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 113.81142 250.38512 0.0  113.81142
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 136.5737 250.38512 0.0  136.5737
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 250.38512 0.0  159.33598
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0 0.0  0 0.0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 22.76228 0.0  0 22.76228
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 45.52457 0.0  0 45.52457
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 68.28685 0.0  0 68.28685
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 91.04913 0.0  0 91.04913
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 113.81142 0.0  0
113.81142 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 136.5737 0.0  0 136.5737
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 159.33598 0.0  0
159.33598 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 182.09827 0.0  0
182.09827 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 204.86055 0.0  0
204.86055 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 227.62283 0.0  0
227.62283 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 250.38512 0.0  0
250.38512 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 0.0  227.62283 0.0 0.0
 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 22.76228 0.0  227.62283 22.76228
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 45.52457 0.0  227.62283 45.52457
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 68.28685 0.0  227.62283 68.28685
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 91.04913 0.0  227.62283 91.04913
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 113.81142 0.0  227.62283 113.81142
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 136.5737 0.0  227.62283 136.5737
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  227.62283 159.33598
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  0.0 0 0.0  0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  22.76228 0 0.0
 22.76228  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  45.52457 0 0.0
 45.52457  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  68.28685 0 0.0
 68.28685  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  91.04913 0 0.0
 91.04913  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  113.81142 0
0.0  113.81142  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  136.5737 0 0.0
 136.5737  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  159.33598 0
0.0  159.33598  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  182.09827 0
0.0  182.09827  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  204.86055 0
0.0  204.86055  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 159.33598 0.0  227.62283 0
0.0  227.62283  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  0.0 227.62283 0.0  0.0
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  22.76228 227.62283 0.0
 22.76228 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  45.52457 227.62283 0.0
 45.52457 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  68.28685 227.62283 0.0
 68.28685 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  91.04913 227.62283 0.0
 91.04913 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  113.81142 227.62283 0.0
 113.81142 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  136.5737 227.62283 0.0
 136.5737 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  159.33598 227.62283 0.0
 159.33598 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  182.09827 227.62283 0.0
 182.09827 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  204.86055 227.62283 0.0
 204.86055 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  227.62283 227.62283 0.0
 227.62283 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 227.62283 0.0
 250.38512 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 0.0 0.0  0 0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 22.76228 0.0
 0 22.76228  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 45.52457 0.0
 0 45.52457  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 68.28685 0.0
 0 68.28685  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 91.04913 0.0
 0 91.04913  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 113.81142 0.0
 0 113.81142  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 136.5737 0.0
 0 136.5737  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 159.33598 0.0
 0 159.33598  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 182.09827 0.0
 0 182.09827  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 204.86055 0.0
 0 204.86055  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  250.38512 227.62283 0.0
 0 227.62283  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.1 0.1 0.5  setrgbcolor  /ArrowA {
moveto } def /ArrowB { } def /ArrowInside { } def  [ 5 9 0 0 9 9 0
9 0 5 9 0 5 0 0 0 9 9  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.
 def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.
 def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def
/RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta 30.
 def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2
Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def
/Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true
def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation
false def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 22.76228
 mul } def /yUnit { 22.76228  mul } def convertStackTo2D end   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.1 0.1
0.5  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.75 SLW 0.1 0.1 0.5  setrgbcolor  /ArrowA {
moveto } def /ArrowB { } def /ArrowInside { } def  [ 0 9 0 5 0 0  tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 150.  def /Beta 30.  def /Sin1 Beta sin def /Sin2 Alpha sin
def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul
def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2
Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup
{tx@3DPlotDict begin} if /eulerRotation false def RotSet (set ) eq
currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 22.76228  mul } def /yUnit { 22.76228  mul } def
convertStackTo2D end   /Lineto /lineto load def 1  setlinejoin false
  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.75 SLW 0.1 0.1 0.5  setrgbcolor  1. .setopacityalpha 
 0  setlinecap [  3.0  4.0 ] 0 0 add  DashLine  grestore end
 
@endspecial 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573
2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1573 2456
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 7 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 11 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 10 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1573 2456 a 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573 2456 a 1573
2456 a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 1573 2456 a 1555 2473 a FF(x)1573 2456 y
tx@Dict begin  PutEnd  end
 1573
2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1573 2456
a 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573 2456 a 1573 2456 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 1573 2456 a 1557
2466 a FF(y)1573 2456 y
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573
2456 a 1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1573 2456 a 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573 2456
a 1573 2456 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 1573 2456 a 1556 2473 a FF(z)1573 2456
y
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573
2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial 1573 2456
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1573 2456 a 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573 2456 a 1573
2456 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1573 2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456
a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1573 2456 a 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573
2456 a 1573 2456 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1573 2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456
a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1573 2456 a 1573
2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1573 2456 a 1573 2456 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1573 2456 a 1573 2456
a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 5 5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573
2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  2.0 SLW
0.5 0 0.5  setrgbcolor  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  [ tx@NodeDict
begin tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0
} ifelse end   false NArray  /DS 2.0 2. CLW mul add 2 div def /Times-Roman
0. [2.3 0.0 0.0 2.3 -0.6486 -0.5819] FontDot /Dot { moveto gsave 1.
 1.  scale <2B> show grestore } bind def  newpath n { transform floor
.5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 9 6 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  2.0 SLW
0.5 0 0.5  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  [ tx@NodeDict
begin tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0
} ifelse end   false NArray  /DS 2.0 2. CLW mul add 2 div def /Times-Roman
0. [2.3 0.0 0.0 2.3 -0.6486 -0.5819] FontDot /Dot { moveto gsave 1.
 1.  scale <2B> show grestore } bind def  newpath n { transform floor
.5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 1543
2483 a FN(O)1573 2456 y
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED .4 -.2 .4 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573
2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial 1573 2456
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 1 0 0 TeXcolorrgb 1547 2475 a FH(~)1561
2494 y FF(i)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 .8 .4 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 1 0 0 TeXcolorrgb 1548 2468 a
FH(~)1565 2487 y FF(j)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573
2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .2 1 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end


@endspecial 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 1 0 0 TeXcolorrgb
1542 2475 a FH(~)1551 2495 y FF(k)p 0 TeXcolorgray 1573
2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 -.3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.1 0.1 0.5
TeXcolorrgb 1552 2476 a Fs(A)p 0 TeXcolorgray 1573 2456
a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 9.2 0.2 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end


@endspecial 1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.1 0.1 0.5 TeXcolorrgb
1552 2476 a Fs(C)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456
a 1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 9 -.3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.1 0.1 0.5 TeXcolorrgb 1552
2476 a Fs(B)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.6 9 9 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.1 0.1 0.5 TeXcolorrgb 1554
2476 a Fs(S)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a
1573 2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 5 5.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.5 0 0.5 TeXcolorrgb 1555 2476
a Fs(F)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 1573
2456 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 150.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 9 6.4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1573 2456 a @beginspecial @setspecial
  tx@Dict begin STP newpath 2.0 SLW 0.5 0 0.5  setrgbcolor  end
 
@endspecial
1573 2456 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1573 2456 a 0.5 0 0.5 TeXcolorrgb 1550 2476
a Fs(G)p 0 TeXcolorgray 1573 2456 a
tx@Dict begin  PutEnd  end
 1573 2456 a 109 3261
a
SDict begin H.S end
 109 3261 a 109 3261 a
SDict begin 12 H.A end
 109 3261 a 109 3261 a
SDict begin [/View [/XYZ H.V]/Dest (Item.41) cvn /DEST pdfmark end
 109 3261
a 0 TeXcolorgray 110 x FP(1.)p 0 TeXcolorgray 141 w FN(Placer)22
b(le)f(point)j FF(E)g FN(de)e(coordonn\351es)e(\(6;)8
b(4;)g(7\))22 b(dans)g(le)f(rep\350re)g(pr\351c\351dent.)109
3398 y
SDict begin H.S end
 109 3398 a 109 3398 a
SDict begin 12 H.A end
 109 3398 a 109 3398 a
SDict begin [/View [/XYZ H.V]/Dest (Item.42) cvn /DEST pdfmark end
 109
3398 a 0 TeXcolorgray 94 x FP(2.)p 0 TeXcolorgray 141
w FN(L)-8 b('abscisse)21 b(du)h(point)i FF(F)j FN(est)21
b(\351gale)h(\340)f(2,)h(lire)g(les)f(coordonn\351es)f(du)i(point)i
FF(F)6 b FN(.)109 3518 y
SDict begin H.S end
 109 3518 a 109 3518 a
SDict begin 12 H.A end
 109 3518
a 109 3518 a
SDict begin [/View [/XYZ H.V]/Dest (Item.43) cvn /DEST pdfmark end
 109 3518 a 0 TeXcolorgray 94 x FP(3.)p 0
TeXcolorgray 140 w FF(G)26 b FN(est)20 b(un)i(point)g(du)g(plan)g(\()r
FF(S)t(B)s(C)s FN(\),)f(lire)h(les)f(coordonn\351es)g(du)h(point)f
FF(G)t FN(.)109 3638 y
SDict begin H.S end
 109 3638 a 109 3638 a
SDict begin 12 H.A end
 109 3638
a 109 3638 a
SDict begin [/View [/XYZ H.V]/Dest (Item.44) cvn /DEST pdfmark end
 109 3638 a 0 TeXcolorgray 94 x FP(4.)p 0
TeXcolorgray 141 w FN(Les)g(points)j FF(E)s FN(,)f FF(F)28
b FN(et)20 b FF(G)26 b FN(sont-ils)21 b(align\351s)13
b(?)109 3780 y
SDict begin H.S end
 109 3780 a 109 3780 a
SDict begin 12 H.A end
 109 3780 a 109 3780
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.7) cvn /DEST pdfmark end
 109 3780 a 185 x FP(Exercice)22 b(n)533 3940 y Fb(o)579
3965 y FP(7)p 667 3940 3222 4 v 109 4079 a FN(Donner)f(une)g
(repr\351sentation)h(param\351trique)f(de)h(la)f(droite)j
FF(d)h FN(dans)d(c)o(hacun)h(des)e(cas)g(suivants)h(:)109
4120 y
SDict begin H.S end
 109 4120 a 109 4120 a
SDict begin 12 H.A end
 109 4120 a 109 4120 a
SDict begin [/View [/XYZ H.V]/Dest (Item.45) cvn /DEST pdfmark end
 109
4120 a 0 TeXcolorgray 83 x FP(1.)p 0 TeXcolorgray 143
w FF(d)j FN(passe)c(par)28 b FF(A)s FN(\()p FC(\241)p
FN(1;)8 b(2;)g(3\))22 b(et)g FF(B)r FN(\(1;)8 b FC(\241)p
FN(1;)g(1\).)109 4234 y
SDict begin H.S end
 109 4234 a 109 4234 a
SDict begin 12 H.A end
 109 4234
a 109 4234 a
SDict begin [/View [/XYZ H.V]/Dest (Item.46) cvn /DEST pdfmark end
 109 4234 a 0 TeXcolorgray 97 x FP(2.)p 0
TeXcolorgray 143 w FF(d)29 b FN(passe)24 b(par)32 b FF(A)s
FN(\(5;)8 b(6;)g(7\))26 b(et)f(poss\350de)f(le)h(vecteur)h(di-)315
4431 y(recteur)17 b FH(~)-44 b FF(u)17 b FN(\(0;)8 b(1;)g(2\).)p
0 TeXcolorgray 0 TeXcolorgray 2040 4120 a
SDict begin H.S end
 2040 4120 a
2040 4120 a
SDict begin 12 H.A end
 2040 4120 a 2040 4120 a
SDict begin [/View [/XYZ H.V]/Dest (Item.47) cvn /DEST pdfmark end
 2040 4120 a 0 TeXcolorgray
83 x FP(3.)p 0 TeXcolorgray 143 w FF(d)25 b FN(passe)c(par)28
b FF(A)s FN(\()p FC(\241)p FN(1;)8 b FC(\241)p FN(5;)g(3\))22
b(et)h FF(B)r FN(\(5;)8 b FC(\241)p FN(1;)g(1\).)2040
4234 y
SDict begin H.S end
 2040 4234 a 2040 4234 a
SDict begin 12 H.A end
 2040 4234 a 2040 4234
a
SDict begin [/View [/XYZ H.V]/Dest (Item.48) cvn /DEST pdfmark end
 2040 4234 a 0 TeXcolorgray 97 x FP(4.)p 0 TeXcolorgray
143 w FF(d)57 b FN(passe)c(par)59 b FF(A)s FN(\(3;)8
b FC(\241)p FN(6;)g(7\))54 b(et)f(est)g(dirig\351e)h(par)2238
4431 y FH(~)-40 b FF(v)15 b FN(\(3;)8 b FC(\241)p FN(1;)g
FC(\241)p FN(2\).)109 4456 y
SDict begin H.S end
 109 4456 a 109 4456 a
SDict begin 12 H.A end
 109
4456 a 109 4456 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.8) cvn /DEST pdfmark end
 109 4456 a 202 x FP(Exercice)22 b(n)533
4633 y Fb(o)579 4658 y FP(8)p 667 4633 3222 4 v 109 4771
a FN(Les)32 b(quatre)g(points)39 b FF(A)s FN(,)34 b FF(B)r
FN(,)f FF(C)i FN(et)g FF(D)h FN(de)c(l'espace)g(sont-ils)g(coplanaires)
13 b(?)33 b(Si)g(oui,)g(donner)f(le)g(syst\350me)g(d'\351quations)109
4871 y(param\351triques)21 b(du)h(plan)g(qui)g(les)f(contient)h(:)109
4797 y
SDict begin H.S end
 109 4797 a 109 4797 a
SDict begin 12 H.A end
 109 4797 a 109 4797 a
SDict begin [/View [/XYZ H.V]/Dest (Item.49) cvn /DEST pdfmark end
 109
4797 a 0 TeXcolorgray 198 x FP(1.)p 0 TeXcolorgray 147
w FF(A)s FN(\(1)p FG(,)p FN(2)p FG(,)p FN(2\),)h FF(B)r
FN(\()p FC(\241)p FN(1)p FG(,)10 b FC(\241)g FN(2)p FG(,)g
FC(\241)g FN(1\),)23 b FF(C)s FN(\(3)p FG(,)p FN(4)p
FG(,)p FN(4\))f(et)h FF(D)t FN(\()p FC(\241)p FN(2)p
FG(,)p FN(3)p FG(,)p FN(1\).)109 5074 y
SDict begin H.S end
 109 5074 a 109
5074 a
SDict begin 12 H.A end
 109 5074 a 109 5074 a
SDict begin [/View [/XYZ H.V]/Dest (Item.50) cvn /DEST pdfmark end
 109 5074 a 0 TeXcolorgray
149 x FP(2.)p 0 TeXcolorgray 147 w FF(A)s FN(\(0)p FG(,)p
FN(1)p FG(,)p FN(3\),)g FF(B)r FN(\(1)p FG(,)p FN(2)p
FG(,)10 b FC(\241)g FN(1\),)23 b FF(C)s FN(\(1)p FG(,)p
FN(1)p FG(,)10 b FC(\241)g FN(1\))22 b(et)h FF(D)t FN(\(1)p
FG(,)p FN(2)p FG(,)p FN(2\).)p 0 TeXcolorgray 0 TeXcolorgray
2040 4912 a
SDict begin H.S end
 2040 4912 a 2040 4912 a
SDict begin 12 H.A end
 2040 4912 a 2040
4912 a
SDict begin [/View [/XYZ H.V]/Dest (Item.51) cvn /DEST pdfmark end
 2040 4912 a 0 TeXcolorgray 83 x FP(3.)p 0 TeXcolorgray
147 w FF(A)s FN(\()p FC(\241)p FN(1)p FG(,)p FN(2)p FG(,)p
FN(4\),)h FF(B)r FN(\(3)p FG(,)10 b FC(\241)g FN(3)p
FG(,)p FN(0\),)22 b FF(C)s FN(\(1)p FG(,)p FN(3)p FG(,)p
FN(4\))g(et)h FF(D)t FN(\(5)p FG(,)p FN(1)p FG(,)10 b
FC(\241)g FN(6\).)2040 5024 y
SDict begin H.S end
 2040 5024 a 2040 5024 a
SDict begin 12 H.A end

2040 5024 a 2040 5024 a
SDict begin [/View [/XYZ H.V]/Dest (Item.52) cvn /DEST pdfmark end
 2040 5024 a 0 TeXcolorgray 99
x FP(4.)p 0 TeXcolorgray 147 w FF(A)s FN(\(2)p FG(,)t
FC(\241)t FN(1)p FG(,)p FN(0\),)20 b FF(B)r FN(\(0)p
FG(,)t FC(\241)t FN(4)p FG(,)p FN(5\),)e FF(C)s FN(\(4)p
FG(,)t FC(\241)t FN(13)p FG(,)p FN(13\))f(et)j FF(D)t
FN(\()p FC(\241)p FN(4)p FG(,)p FN(5)p FG(,)t FC(\241)2246
5223 y FN(3\).)109 5348 y(\(V)-6 b(oir)21 b(section)573
5349 y
SDict begin H.S end
 573 5349 a 0 TeXcolorgray -1 x FN(2.4)p 0 TeXcolorgray
681 5295 a
SDict begin H.R end
 681 5295 a 681 5348 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (section.2.4) cvn H.B /ANN pdfmark end
 681 5348 a 21 w FN(page)891
5349 y
SDict begin H.S end
 891 5349 a 0 TeXcolorgray -1 x FN(9)p 0 TeXcolorgray
934 5295 a
SDict begin H.R end
 934 5295 a 934 5348 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (section.2.4) cvn H.B /ANN pdfmark end
 934 5348 a FN(\))109
5364 y
SDict begin H.S end
 109 5364 a 109 5364 a
SDict begin 12 H.A end
 109 5364 a 109 5364 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.9) cvn /DEST pdfmark end
 109
5364 a 186 x FP(Exercice)h(n)533 5524 y Fb(o)579 5550
y FP(9)p 667 5524 3222 4 v 109 5688 a FN(Dans)16 b(l'espace)g(muni)h
(d'un)f(rep\350re)1221 5600 y Fo(\263)1253 5688 y FN(O;)1332
5669 y FH(~)1346 5688 y FF(i)s FG(,)1390 5669 y FH(~)1407
5688 y FF(j)s FG(,)1448 5668 y FH(~)1457 5688 y FF(k)1503
5600 y Fo(\264)1534 5688 y FN(,)h(on)f(consid\350re)h(les)f(points)22
b FF(A)s FN(\(2;)8 b FC(\241)p FN(1;)g(3\),)19 b FF(B)r
FN(\(3;)8 b(2;)g(1\),)17 b FF(C)s FN(\()p FC(\241)p FN(2;)8
b(3;)g(1\))17 b(et)h FF(D)t FN(\(6;)8 b(3;)g(0\).)109
5756 y
SDict begin H.S end
 109 5756 a 109 5756 a
SDict begin 12 H.A end
 109 5756 a 109 5756 a
SDict begin [/View [/XYZ H.V]/Dest (Item.53) cvn /DEST pdfmark end
 109
5756 a 0 TeXcolorgray 75 x FP(1.)p 0 TeXcolorgray 141
w FN(Les)21 b(points)28 b FF(A)s FN(,)23 b FF(B)g FN(et)f
FF(C)i FN(d\351terminent-ils)d(un)h(plan)14 b(?)22 b(Si)f(oui,)h(c)o
(herc)o(her)h(son)e(\351quation)g(cart\351sienne)o(.)315
5930 y(\(V)-6 b(oir)21 b(section)779 5931 y
SDict begin H.S end
 779 5931
a 0 TeXcolorgray -1 x FN(2.5.1)p 0 TeXcolorgray 951 5878
a
SDict begin H.R end
 951 5878 a 951 5930 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (section*.17) cvn H.B /ANN pdfmark end
 951 5930 a 21 w FN(page)1161
5931 y
SDict begin H.S end
 1161 5931 a 0 TeXcolorgray -1 x FN(10)p 0 TeXcolorgray
1247 5878 a
SDict begin H.R end
 1247 5878 a 1247 5930 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (section*.17) cvn H.B /ANN pdfmark end
 1247 5930 a FN(\))p
0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 18 18
TeXDict begin 18 17 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.18) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(18)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (Item.54) cvn /DEST pdfmark end
 -128 -121 a 0 TeXcolorgray 83 x FP(2.)p 0 TeXcolorgray
141 w FN(Calculer)23 b(les)e(coordonn\351es)f(du)i(point)k
FF(I)i FN(milieu)21 b(du)h(segment)f([)q FF(B)s(C)s FN(].)f(\(voir)i
(section)2713 -37 y
SDict begin H.S end
 2713 -37 a 0 TeXcolorgray -1 x FN(2.3.2)p
0 TeXcolorgray 2884 -91 a
SDict begin H.R end
 2884 -91 a 2884 -38 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (subsection.2.3.2) cvn H.B /ANN pdfmark end
 2884
-38 a 22 w FN(page)3095 -37 y
SDict begin H.S end
 3095 -37 a 0 TeXcolorgray
-1 x FN(8)p 0 TeXcolorgray 3137 -91 a
SDict begin H.R end
 3137 -91 a 3137
-38 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (subsection.2.3.2) cvn H.B /ANN pdfmark end
 3137 -38 a FN(\))-128 -8 y
SDict begin H.S end
 -128 -8 a -128 -8 a
SDict begin 12 H.A end

-128 -8 a -128 -8 a
SDict begin [/View [/XYZ H.V]/Dest (Item.55) cvn /DEST pdfmark end
 -128 -8 a 0 TeXcolorgray 98 x FP(3.)p
0 TeXcolorgray 141 w FN(Les)g(points)27 b FF(A)s FN(,)d
FF(B)r FN(,)e FF(C)i FN(et)f FF(D)j FN(sont-ils)21 b(coplanaires)13
b(?)-128 149 y
SDict begin H.S end
 -128 149 a -128 149 a
SDict begin 12 H.A end
 -128 149 a -128
149 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.10) cvn /DEST pdfmark
end
 -128 149 a 186 x FP(Exercice)23 b(n)297 310 y Fb(o)343
335 y FP(10)p 475 310 3178 4 v -128 448 a FN(Le)f(plan)g(\()6
b FF(A)t(B)s(C)s FN(\),)21 b(dessin\351)g(ci-dessous)g(dans)g(un)h
(rep\350re)f(de)h(l'espace)o(,)f(a)g(pour)h(\351quation)-128
597 y Fx(\225)g FN(3)s FF(x)11 b FC(\305)f FN(6)d FF(y)j
FC(\305)g FN(4)t FF(z)16 b FC(\306)e FN(9)1172 595 y
Fx(\225)22 b FN(2)s FF(x)11 b FC(\305)17 b FF(y)10 b
FC(\241)k FF(z)i FC(\306)e FN(6)2589 597 y Fx(\225)22
b FN(4)s FF(x)11 b FC(\305)f FN(2)d FF(y)j FC(\305)g
FN(3)t FF(z)16 b FC(\306)e FN(12)p 0 TeXcolorgray 0 TeXcolorgray
543 2305 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 293.6333 a add def
/d 0.0 a add neg def /h 191.20302 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 543 2305 a 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 7 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -5 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -2.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {}
def NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 5.5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5 SLW 0  setgray  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.5 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.5 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.5 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.5 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1677 1833 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1677 1833 a 1677
1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1677 1833 a 1677 1833 a
tx@Dict begin { 5.0 4.12 3.54 0.12 180.  Uput UUput } PutCoor PutBegin
 end
 1677 1833 a 1663 1847
a Fp(x)1677 1833 y
tx@Dict begin  PutEnd  end
 1677 1833 a 1677 1833 a
tx@Dict begin  PutEnd  end
 1677 1833
a 1677 1833 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1677 1833 a 1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1677 1833 a 1677
1833 a
tx@Dict begin { 5.0 4.43999 3.54 1.528 0.  Uput UUput } PutCoor PutBegin
 end
 1677 1833 a 1665 1841 a Fp(y)1677 1833 y
tx@Dict begin  PutEnd  end
 1677
1833 a 1677 1833 a
tx@Dict begin  PutEnd  end
 1677 1833 a 1677 1833 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1677 1833
a 1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1677 1833 a 1677 1833 a
tx@Dict begin { 5.0 4.008 3.54 0.12 90.  Uput UUput } PutCoor PutBegin
 end
 1677 1833 a 1663
1847 a Fp(z)1677 1833 y
tx@Dict begin  PutEnd  end
 1677 1833 a 1677 1833 a
tx@Dict begin  PutEnd  end
 1677
1833 a 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 0 -0.2 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end


@endspecial 1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 1660 1854 a Fx(1)1677
1833 y
tx@Dict begin  PutEnd  end
 1677 1833 a 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1 -0.2 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end
 
@endspecial 1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 1660
1854 a Fx(1)1677 1833 y
tx@Dict begin  PutEnd  end
 1677 1833 a 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 .2 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end
 
@endspecial 1677 1833
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 1660 1854 a Fx(1)1677 1833 y
tx@Dict begin  PutEnd  end
 1677 1833
a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0.1 0.05 0.5  setrgbcolor  tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 45.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { 3 0 0 } def /P2 { 0 6 0 } def /P3 { 0 0 4 } def
/SphericalCoor false def /xUnit { 22.76228  mul } def /yUnit { 22.76228
 mul } def P1 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D
/x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x1 x2D xUnit def /y1 y2D yUnit def P3 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x2 x2D xUnit def /y2 y2D yUnit
def [ x0 y0 x1 y1 x2 y2 x0 y0   /Lineto /lineto load def 1  setlinejoin
false   NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0
gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 90 rotate 45. rotate 0.5 SLW 0.5 0 0.5  setrgbcolor
6.0 0.0 0.0 LineFill  grestore gsave 1.25 SLW 0.1 0.05 0.5  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -4 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end

1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -3 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 3 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 4 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 6 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -4 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -3 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -1 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 3 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 4 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 5 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 6 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 7 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 4 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677 1833 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial 1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul exch
22.76228 mul exch } false /N@pst@A 10 {InitPnode } /NodeScale {} def
NewNode end end
 1677
1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  0.8 SLW 0.25  setgray
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  [ tx@NodeDict begin
tx@NodeDict /N@pst@A known { /N@pst@A load GetCenter } { 0 0 } ifelse
end   false NArray  /DS 2.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def  newpath n { transform floor .5 add exch
floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath end
 
@endspecial
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 3.2 -.2 0.2 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end
 
@endspecial
1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 0.1 0.05 0.5 TeXcolorrgb 1657
1856 a Fp(A)p 0 TeXcolorgray 1677 1833 a
tx@Dict begin  PutEnd  end
 1677 1833 a
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 6.2 0.2 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end
 
@endspecial
1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 0.1 0.05 0.5 TeXcolorrgb 1655
1855 a Fp(B)p 0 TeXcolorgray 1677 1833 a
tx@Dict begin  PutEnd  end
 1677 1833 a
1677 1833 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 45.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED .2 -.2 4.2 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  22.76228 mul
exch 22.76228 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1677 1833 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.25  setgray  end
 
@endspecial
1677 1833 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1677 1833 a 0.1 0.05 0.5 TeXcolorrgb 1654
1855 a Fp(C)p 0 TeXcolorgray 1677 1833 a
tx@Dict begin  PutEnd  end
 1677 1833 a
2981 2305 a
currentpoint initclip moveto
 2981 2305 a -128 2389 a
SDict begin H.S end
 -128 2389 a -128
2389 a
SDict begin 12 H.A end
 -128 2389 a -128 2389 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.11) cvn /DEST pdfmark
end
 -128 2389 a 201 x FP(Exercice)23
b(n)297 2565 y Fb(o)343 2590 y FP(11)p 475 2565 3178
4 v -128 2704 a FN(D\351terminer)f(une)f(\351quation)g(cart\351sienne)g
(du)h(plan)h FI(\303)e FN(dans)h(c)o(hacun)h(des)e(cas)g(suivants)h(:)
-128 2745 y
SDict begin H.S end
 -128 2745 a -128 2745 a
SDict begin 12 H.A end
 -128 2745 a -128
2745 a
SDict begin [/View [/XYZ H.V]/Dest (Item.56) cvn /DEST pdfmark end
 -128 2745 a 0 TeXcolorgray 83 x FP(1.)p 0 TeXcolorgray
141 w FI(\303)44 b FN(passe)g(par)50 b FF(A)s FN(\()p
FC(\241)p FN(1;)8 b(2;)g(3\))45 b(et)e(est)h(orthogonal)g(\340)75
2928 y FH(~)-45 b FF(n)r FN(\(2;)8 b(3;)g(5\))-128 2952
y
SDict begin H.S end
 -128 2952 a -128 2952 a
SDict begin 12 H.A end
 -128 2952 a -128 2952 a
SDict begin [/View [/XYZ H.V]/Dest (Item.57) cvn /DEST pdfmark end
 -128
2952 a 0 TeXcolorgray 96 x FP(2.)p 0 TeXcolorgray 141
w FI(\303)29 b FN(passe)e(par)35 b FF(A)s FN(\()p FC(\241)p
FN(1;)8 b FC(\241)p FN(2;)g FC(\241)p FN(3\))29 b(et)f(est)f
(orthogonal)i(\340)75 3147 y FH(~)-45 b FF(n)r FN(\(0;)8
b(1;)g(2\))p 0 TeXcolorgray 0 TeXcolorgray 1804 2745
a
SDict begin H.S end
 1804 2745 a 1804 2745 a
SDict begin 12 H.A end
 1804 2745 a 1804 2745 a
SDict begin [/View [/XYZ H.V]/Dest (Item.58) cvn /DEST pdfmark end
 1804
2745 a 0 TeXcolorgray 83 x FP(3.)p 0 TeXcolorgray 141
w FI(\303)21 b FN(passe)g(par)28 b FF(A)s FN(\(2;)8 b(6;)g(7\),)24
b FF(B)r FN(\()p FC(\241)p FN(3;)8 b(4;)g(6\))21 b(et)h
FF(C)s FN(\(1;)8 b(0;)g(0\))1804 2861 y
SDict begin H.S end
 1804 2861 a 1804
2861 a
SDict begin 12 H.A end
 1804 2861 a 1804 2861 a
SDict begin [/View [/XYZ H.V]/Dest (Item.59) cvn /DEST pdfmark end
 1804 2861 a 0 TeXcolorgray
95 x FP(4.)p 0 TeXcolorgray 141 w FI(\303)21 b FN(passe)g(par)28
b FF(A)s FN(\(1;)8 b(2;)g(3\),)24 b FF(B)r FN(\(4;)8
b(5;)g(6\))21 b(et)h FF(C)s FN(\(7;)8 b(8;)g(9\))-128
3172 y
SDict begin H.S end
 -128 3172 a -128 3172 a
SDict begin 12 H.A end
 -128 3172 a -128 3172
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.12) cvn /DEST pdfmark
end
 -128 3172 a 202 x FP(Exercice)23 b(n)297 3349 y Fb(o)343
3374 y FP(12)p 475 3349 3178 4 v -128 3487 a FN(D\351terminer)29
b(l'intersection)h(\351ventuelle)f(de)h(la)f(droite)j
FF(d)h FN(et)c(du)h(plan)g FI(\274)f FN(sac)o(hant)h(qu'une)f
(repr\351sentation)h(param\351-)-128 3683 y(trique)22
b(de)i FF(d)h FN(est)416 3524 y Fo(8)416 3592 y(<)416
3730 y(:)524 3581 y FF(x)15 b FC(\306)f FN(2)c FC(\305)g
FN(3)s FF(t)528 3681 y(y)k FC(\306)g FN(1)c FC(\241)g
FN(2)s FF(t)525 3781 y(z)16 b FC(\306)e FN(3)916 3683
y(o\371)25 b FF(t)15 b FC(2)g Fk(R)21 b FN(et)g(une)g(\351quation)h
(cart\351sienne)f(de)g FI(\274)g FN(est)g(3)s FF(x)11
b FC(\241)f FN(2)d FF(y)j FC(\305)k FF(z)i FC(\306)e
FN(3)-128 3811 y
SDict begin H.S end
 -128 3811 a -128 3811 a
SDict begin 12 H.A end
 -128 3811 a
-128 3811 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.13) cvn /DEST pdfmark
end
 -128 3811 a 141 x FP(Exercice)23 b(n)297
3927 y Fb(o)343 3952 y FP(13)p 475 3927 3178 4 v -128
4065 a FN(Calculer)g(la)e(distance)h(du)g(point)28 b
FF(A)d FN(au)d(plan)g FI(\274)f FN(:)-128 4095 y
SDict begin H.S end
 -128
4095 a -128 4095 a
SDict begin 12 H.A end
 -128 4095 a -128 4095 a
SDict begin [/View [/XYZ H.V]/Dest (Item.60) cvn /DEST pdfmark end
 -128 4095
a 0 TeXcolorgray 98 x FP(1.)p 0 TeXcolorgray 147 w FF(A)s
FN(\(1;)8 b(0;)g(2\))23 b(et)e FI(\274)14 b FC(\264)g
FN(2)s FF(x)d FC(\241)f FN(2)d FF(y)14 b FC(\306)g FN(3)-128
4223 y
SDict begin H.S end
 -128 4223 a -128 4223 a
SDict begin 12 H.A end
 -128 4223 a -128 4223
a
SDict begin [/View [/XYZ H.V]/Dest (Item.61) cvn /DEST pdfmark end
 -128 4223 a 0 TeXcolorgray 98 x FP(2.)p 0 TeXcolorgray
147 w FF(A)s FN(\(2;)8 b(1;)g(1\))23 b(et)e FI(\274)g
FN(est)g(le)g(plan)h(passant)g(par)h FF(B)r FN(\(1;)8
b(0;)g(0\),)21 b(de)h(vecteur)g(normal)c FH(~)-45 b FF(n)q
FN(\(2;)8 b(3;)g(4\).)-128 4450 y(\(V)-6 b(oir)22 b(section)337
4451 y
SDict begin H.S end
 337 4451 a 0 TeXcolorgray -1 x FN(2.5.3)p 0 TeXcolorgray
509 4397 a
SDict begin H.R end
 509 4397 a 509 4450 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (subsection.2.5.3) cvn H.B /ANN pdfmark end
 509 4450 a 21 w FN(page)719
4450 y
SDict begin H.S end
 719 4450 a 0 TeXcolorgray FN(12)p 0 TeXcolorgray
805 4397 a
SDict begin H.R end
 805 4397 a 805 4450 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
/Link/Dest (subsection.2.5.3) cvn H.B /ANN pdfmark end
 805 4450 a FN(\))-128
4466 y
SDict begin H.S end
 -128 4466 a -128 4466 a
SDict begin 12 H.A end
 -128 4466 a -128 4466
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.14) cvn /DEST pdfmark
end
 -128 4466 a 186 x FP(Exercice)h(n)297 4626 y Fb(o)343
4652 y FP(14)p 475 4627 3178 4 v -128 4765 a FN(Trouver)g(une)e
(\351quation)g(du)h(plan)h FI(\274)e FN(d\351\002ni)h(par)g(les)f
(\351l\351ments)f(suivants)n(.)-128 4795 y
SDict begin H.S end
 -128 4795
a -128 4795 a
SDict begin 12 H.A end
 -128 4795 a -128 4795 a
SDict begin [/View [/XYZ H.V]/Dest (Item.62) cvn /DEST pdfmark end
 -128 4795 a 0 TeXcolorgray
94 x FP(1.)p 0 TeXcolorgray 147 w FF(A)s FN(,)k FF(B)f
FN(et)f FF(C)i FN(sont)d(des)g(points)h(de)f FI(\274)78
4920 y
SDict begin H.S end
 78 4920 a 78 4920 a
SDict begin 12 H.A end
 78 4920 a 78 4920 a
SDict begin [/View [/XYZ H.V]/Dest (Item.63) cvn /DEST pdfmark end
 78 4920
a 0 TeXcolorgray 98 x FN(\(a\))p 0 TeXcolorgray 47 w
FF(A)s FN(\(0)p FG(,)p FN(0)p FG(,)p FN(1\),)j FF(B)r
FN(\(1)p FG(,)p FN(0)p FG(,)p FN(0\))d(et)h FF(C)s FN(\(0)p
FG(,)p FN(1)p FG(,)p FN(0\).)p 0 TeXcolorgray 0 TeXcolorgray
1907 4806 a
SDict begin H.S end
 1907 4806 a 1907 4806 a
SDict begin 12 H.A end
 1907 4806 a 1907
4806 a
SDict begin [/View [/XYZ H.V]/Dest (Item.64) cvn /DEST pdfmark end
 1907 4806 a 0 TeXcolorgray 83 x FN(\(b\))p 0 TeXcolorgray
47 w FF(A)s FN(\(1)p FG(,)p FN(1)p FG(,)p FN(1\),)h FF(B)r
FN(\(2)p FG(,)p FN(0)p FG(,)p FN(1\))e(et)h FF(C)s FN(\()p
FC(\241)p FN(1)p FG(,)p FN(2)p FG(,)p FN(4\).)1907 4918
y
SDict begin H.S end
 1907 4918 a 1907 4918 a
SDict begin 12 H.A end
 1907 4918 a 1907 4918 a
SDict begin [/View [/XYZ H.V]/Dest (Item.65) cvn /DEST pdfmark end
 1907
4918 a 0 TeXcolorgray 1914 5018 a FN(\(c\))p 0 TeXcolorgray
47 w FF(A)s FN(\(5)p FG(,)p FN(0)p FG(,)10 b FC(\241)g
FN(1\),)24 b FF(B)r FN(\(1)p FG(,)p FN(3)p FG(,)10 b
FC(\241)g FN(2\))21 b(et)h FF(C)s FN(\()p FC(\241)p FN(2)p
FG(,)p FN(4)p FG(,)p FN(5\).)-128 5043 y
SDict begin H.S end
 -128 5043 a
-128 5043 a
SDict begin 12 H.A end
 -128 5043 a -128 5043 a
SDict begin [/View [/XYZ H.V]/Dest (Item.66) cvn /DEST pdfmark end
 -128 5043 a 0 TeXcolorgray
113 x FP(2.)p 0 TeXcolorgray 147 w FF(A)j FN(est)c(un)h(point)g(de)f
FI(\274)p FN(,)c FH(~)-43 b FF(u)24 b FN(et)13 b FH(~)-40
b FF(v)22 b FN(sont)f(des)g(vecteurs)h(directeurs)g(de)f
FI(\274)78 5198 y
SDict begin H.S end
 78 5198 a 78 5198 a
SDict begin 12 H.A end
 78 5198 a 78 5198
a
SDict begin [/View [/XYZ H.V]/Dest (Item.67) cvn /DEST pdfmark end
 78 5198 a 0 TeXcolorgray 83 x FN(\(a\))p 0 TeXcolorgray
47 w FF(A)s FN(\(1)p FG(,)p FN(2)p FG(,)p FN(1\),)d FH(~)-43
b FF(u)r FN(\(4)p FG(,)p FN(0)p FG(,)p FN(3\))22 b(et)13
b FH(~)-40 b FF(v)q FN(\(1)p FG(,)p FN(3)p FG(,)10 b
FC(\241)g FN(1\).)p 0 TeXcolorgray 0 TeXcolorgray 1907
5198 a
SDict begin H.S end
 1907 5198 a 1907 5198 a
SDict begin 12 H.A end
 1907 5198 a 1907 5198
a
SDict begin [/View [/XYZ H.V]/Dest (Item.68) cvn /DEST pdfmark end
 1907 5198 a 0 TeXcolorgray 83 x FN(\(b\))p 0 TeXcolorgray
47 w FF(A)s FN(\(1)p FG(,)p FN(0)p FG(,)p FN(2\),)17
b FH(~)-43 b FF(u)s FN(\(2)p FG(,)10 b FC(\241)g FN(1)p
FG(,)p FN(3\))21 b(et)14 b FH(~)-40 b FF(v)p FN(\()p
FC(\241)p FN(1)p FG(,)p FN(4)p FG(,)p FN(5\).)-128 5306
y
SDict begin H.S end
 -128 5306 a -128 5306 a
SDict begin 12 H.A end
 -128 5306 a -128 5306 a
SDict begin [/View [/XYZ H.V]/Dest (Item.69) cvn /DEST pdfmark end
 -128
5306 a 0 TeXcolorgray 114 x FP(3.)p 0 TeXcolorgray 147
w FF(A)25 b FN(est)c(un)h(point)g(de)f FI(\274)p FN(,)j
FF(D)h FN(est)c(une)h(droite)f(contenue)g(dans)h FI(\274)78
5461 y
SDict begin H.S end
 78 5461 a 78 5461 a
SDict begin 12 H.A end
 78 5461 a 78 5461 a
SDict begin [/View [/XYZ H.V]/Dest (Item.70) cvn /DEST pdfmark end
 78 5461
a 0 TeXcolorgray 122 x FN(\(a\))p 0 TeXcolorgray 47 w
FF(A)s FN(\(4)p FG(,)p FN(1)p FG(,)10 b FC(\241)g FN(3\))23
b(et)e(\()r FF(D)t FN(\))13 b(:)855 5472 y Fo(\275)946
5531 y FF(x)e FC(\305)17 b FF(y)10 b FC(\241)k FF(z)e
FC(\305)e FN(3)k FC(\306)h FN(0)943 5631 y(4)s FF(x)c
FC(\241)17 b FF(y)10 b FC(\305)g FN(2)t FF(z)16 b FC(\306)e
FN(0)p 0 TeXcolorgray 0 TeXcolorgray 1907 5461 a
SDict begin H.S end
 1907
5461 a 1907 5461 a
SDict begin 12 H.A end
 1907 5461 a 1907 5461 a
SDict begin [/View [/XYZ H.V]/Dest (Item.71) cvn /DEST pdfmark end
 1907 5461
a 0 TeXcolorgray 171 x FN(\(b\))p 0 TeXcolorgray 47 w
FF(A)s FN(\(1)p FG(,)p FN(1)p FG(,)p FN(0\))22 b(et)f(\()r
FF(D)t FN(\))13 b(:)2608 5473 y Fo(8)2608 5542 y(<)2608
5680 y(:)2716 5531 y FF(x)i FC(\306)i FF(t)2720 5631
y(y)d FC(\306)g(\241)p FN(1)c FC(\305)g FN(2)s FF(t)2717
5730 y(z)16 b FC(\306)e FN(1)c FC(\241)g FN(3)s FF(t)p
0 TeXcolorgray 0 TeXcolorgray eop end
%%Page: 19 19
TeXDict begin 19 18 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.19) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(19)p 109 -238 3780 2 v 0 TeXcolorgray 109 -121 a
SDict begin H.S end

109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.15) cvn /DEST pdfmark
end
 109 -121
a 108 x FP(Exercice)22 b(n)533 -38 y Fb(o)579 -13 y FP(15)p
711 -38 3178 4 v 109 125 a FN(Dans)16 b(l'espace)g(muni)h(d'un)f
(rep\350re)1221 38 y Fo(\263)1253 125 y FN(O;)1332 106
y FH(~)1346 125 y FF(i)s FG(,)1390 106 y FH(~)1407 125
y FF(j)s FG(,)1448 105 y FH(~)1457 125 y FF(k)1503 38
y Fo(\264)1534 125 y FN(,)h(on)f(consid\350re)h(les)f(points)22
b FF(A)s FN(\(2;)8 b FC(\241)p FN(1;)g(3\),)19 b FF(B)r
FN(\(3;)8 b(2;)g(1\),)17 b FF(C)s FN(\()p FC(\241)p FN(2;)8
b(3;)g(1\))17 b(et)h FF(D)t FN(\(6;)8 b(3;)g(0\).)109
201 y
SDict begin H.S end
 109 201 a 109 201 a
SDict begin 12 H.A end
 109 201 a 109 201 a
SDict begin [/View [/XYZ H.V]/Dest (Item.72) cvn /DEST pdfmark end
 109 201
a 0 TeXcolorgray 79 x FP(1.)p 0 TeXcolorgray 141 w FN(Les)21
b(points)28 b FF(A)s FN(,)23 b FF(B)g FN(et)f FF(C)i
FN(d\351terminent-ils)d(un)h(plan)14 b(?)109 310 y
SDict begin H.S end
 109
310 a 109 310 a
SDict begin 12 H.A end
 109 310 a 109 310 a
SDict begin [/View [/XYZ H.V]/Dest (Item.73) cvn /DEST pdfmark end
 109 310 a 0 TeXcolorgray
98 x FP(2.)p 0 TeXcolorgray 141 w FN(Calculer)22 b(les)f
(coordonn\351es)f(du)i(point)k FF(I)i FN(milieu)22 b(du)g(segment)e([)q
FF(B)s(C)s FN(].)109 439 y
SDict begin H.S end
 109 439 a 109 439 a
SDict begin 12 H.A end
 109 439
a 109 439 a
SDict begin [/View [/XYZ H.V]/Dest (Item.74) cvn /DEST pdfmark end
 109 439 a 0 TeXcolorgray 98 x FP(3.)p 0 TeXcolorgray
141 w FN(Les)h(points)28 b FF(A)s FN(,)23 b FF(B)r FN(,)f
FF(C)i FN(et)g FF(D)h FN(sont-ils)c(coplanaires)13 b(?)109
596 y
SDict begin H.S end
 109 596 a 109 596 a
SDict begin 12 H.A end
 109 596 a 109 596 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.16) cvn /DEST pdfmark
end
 109 596
a 186 x FP(Exercice)22 b(n)533 756 y Fb(o)579 782 y FP(16)p
711 756 3178 4 v 109 920 a FN(L)-8 b('espace)34 b(est)f(rapport\351)h
(\340)g(un)h(rep\350re)e(orthonorm\351)1834 832 y Fo(\263)1866
920 y FN(O;)1945 901 y FH(~)1959 920 y FF(i)s FG(,)2003
901 y FH(~)2020 920 y FF(j)s FG(,)2061 900 y FH(~)2070
920 y FF(k)2116 832 y Fo(\264)2147 920 y FN(.)i(On)f(consid\350re)g
(les)g(points)40 b FF(A)s FN(\(2;)8 b FC(\241)p FN(1;)g(3\),)36
b FF(B)r FN(\()p FC(\241)p FN(2;)8 b(3;)g(1\),)110 1032
y FF(C)s FN(\()p FC(\241)p FN(2;)g(0;)g(4\),)24 b FF(D)t
FN(\(9;)8 b FC(\241)p FN(5;)g(8\))21 b(et)j FF(E)s FN(\()s
FF(x)q FN(;)15 b FF(y)p FN(;)8 b(6\).)109 1076 y
SDict begin H.S end
 109
1076 a 109 1076 a
SDict begin 12 H.A end
 109 1076 a 109 1076 a
SDict begin [/View [/XYZ H.V]/Dest (Item.75) cvn /DEST pdfmark end
 109 1076 a 0
TeXcolorgray 98 x FP(1.)p 0 TeXcolorgray 141 w FN(Montrer)21
b(que)g(les)g(points)28 b FF(A)s FN(,)23 b FF(B)g FN(et)f
FF(C)i FN(d\351terminent)e(un)g(plan.)109 1205 y
SDict begin H.S end
 109
1205 a 109 1205 a
SDict begin 12 H.A end
 109 1205 a 109 1205 a
SDict begin [/View [/XYZ H.V]/Dest (Item.76) cvn /DEST pdfmark end
 109 1205 a 0
TeXcolorgray 98 x FP(2.)p 0 TeXcolorgray 141 w FN(Le)f(point)j
FF(E)g FN(appartient)f(\340)e(la)h(droite)f(\()6 b FF(A)t(B)r
FN(\).)21 b(D\351terminer)h(son)f(abscisse)f(et)h(son)g(ordonn\351e)o
(.)109 1333 y
SDict begin H.S end
 109 1333 a 109 1333 a
SDict begin 12 H.A end
 109 1333 a 109 1333
a
SDict begin [/View [/XYZ H.V]/Dest (Item.77) cvn /DEST pdfmark end
 109 1333 a 0 TeXcolorgray 111 x FP(3.)p 0 TeXcolorgray
141 w FN(Montrer)g(que)g(les)g(vecteurs)1224 1389 y FC(\241)-30
b(\241)g(!)1226 1444 y FF(E)5 b(D)25 b FN(et)1462 1387
y FC(\241)-32 b(\241)f(!)1468 1444 y FF(A)t(B)23 b FN(sont)e
(orthogonaux.)109 1474 y
SDict begin H.S end
 109 1474 a 109 1474 a
SDict begin 12 H.A end
 109 1474
a 109 1474 a
SDict begin [/View [/XYZ H.V]/Dest (Item.78) cvn /DEST pdfmark end
 109 1474 a 0 TeXcolorgray 98 x FP(4.)p 0
TeXcolorgray 141 w FN(Montrer)g(que)g(la)h(droite)f(\()r
FF(E)5 b(D)t FN(\))21 b(est)g(perpendiculaire)i(au)f(plan)g(\()6
b FF(A)t(B)s(C)s FN(\).)109 1631 y
SDict begin H.S end
 109 1631 a 109 1631
a
SDict begin 12 H.A end
 109 1631 a 109 1631 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.17) cvn /DEST pdfmark
end
 109 1631 a 186 x FP(Exercice)22
b(n)533 1792 y Fb(o)579 1817 y FP(17)p 711 1792 3178
4 v 109 1955 a FN(Dans)f(l'espace)g(muni)h(d'un)g(rep\350re)1247
1868 y Fo(\263)1278 1955 y FN(O;)1357 1936 y FH(~)1371
1955 y FF(i)s FG(,)1415 1936 y FH(~)1432 1955 y FF(j)t
FG(,)1474 1935 y FH(~)1483 1955 y FF(k)1528 1868 y Fo(\264)1560
1955 y FN(,)g(on)f(consid\350re)g(les)g(points)28 b FF(A)s
FN(\()p FC(\241)p FN(2;)8 b(3;)g FC(\241)p FN(1\))22
b(et)h FF(B)r FN(\(1;)8 b(3;)g(2\).)109 2017 y
SDict begin H.S end
 109 2017
a 109 2017 a
SDict begin 12 H.A end
 109 2017 a 109 2017 a
SDict begin [/View [/XYZ H.V]/Dest (Item.79) cvn /DEST pdfmark end
 109 2017 a 0 TeXcolorgray
79 x FP(1.)p 0 TeXcolorgray 141 w FN(D\351terminer)21
b(les)g(coordonn\351es)f(du)i(point)h FF(C)h FN(intersection)e(de)g(la)
f(droite)h(\()6 b FF(A)t(B)r FN(\))20 b(a)o(vec)i(le)g(plan)g(\()s
FF(x)q(O)9 b(y)p FN(\).)109 2126 y
SDict begin H.S end
 109 2126 a 109 2126
a
SDict begin 12 H.A end
 109 2126 a 109 2126 a
SDict begin [/View [/XYZ H.V]/Dest (Item.80) cvn /DEST pdfmark end
 109 2126 a 0 TeXcolorgray 98
x FP(2.)p 0 TeXcolorgray 141 w FN(D\351terminer)21 b(les)g
(coordonn\351es)f(du)i(point)i FF(D)i FN(intersection)21
b(de)h(la)f(droite)h(\()6 b FF(A)t(B)r FN(\))21 b(a)o(vec)g(le)h(plan)g
(\()7 b FF(yO)f(z)r FN(\).)109 2254 y
SDict begin H.S end
 109 2254 a 109
2254 a
SDict begin 12 H.A end
 109 2254 a 109 2254 a
SDict begin [/View [/XYZ H.V]/Dest (Item.81) cvn /DEST pdfmark end
 109 2254 a 0 TeXcolorgray
98 x FP(3.)p 0 TeXcolorgray 141 w FN(La)22 b(droite)f(\()6
b FF(A)t(B)r FN(\))21 b(est-elle)f(s\351cante)h(a)o(vec)h(le)f(plan)i
(\()s FF(x)q(O)6 b(z)r FN(\))12 b(?)109 2397 y
SDict begin H.S end
 109 2397
a 109 2397 a
SDict begin 12 H.A end
 109 2397 a 109 2397 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.18) cvn /DEST pdfmark
end
 109 2397 a 186 x FP(Exercice)22
b(n)533 2558 y Fb(o)579 2583 y FP(18)p 711 2558 3178
4 v 109 2721 a FN(L)-8 b('espace)21 b(est)g(muni)h(d'un)g(rep\350re)f
(orthonormal)1651 2634 y Fo(\263)1682 2721 y FN(O;)1761
2702 y FH(~)1775 2721 y FF(i)s FG(,)1819 2702 y FH(~)1836
2721 y FF(j)t FG(,)1878 2701 y FH(~)1887 2721 y FF(k)1932
2634 y Fo(\264)1964 2721 y FN(.)109 2833 y(La)h(\002gure)g(ci-dessous)n
(,)f(repr\351sente)g(un)g(pa)o(v\351)i(droit)13 b(;)22
b(le)f(point)h(O)g(est)f(le)g(milieu)h(de)f([)6 b FF(A)f(D)t
FN(].)109 2933 y(Soit)23 b FF(P)k FN(le)22 b(milieu)f(du)h(segment)f([)
r FF(E)5 b(F)h FN(].)p 0 TeXcolorgray 0 TeXcolorgray
1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.116 0.565 1  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 34.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { -1  0  0  } def /P2 { 2 0 0 } def /P3 { 0 1 0 }
def /SphericalCoor false def /xUnit { 56.9055  mul } def /yUnit { 56.9055
 mul } def P1 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D
/x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x1 x2D xUnit x0 add def /y1 y2D yUnit y0 add def
P3 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x2
x2D xUnit x1 add def /y2 y2D yUnit y1 add def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x3 x2D xUnit neg x2 add def
/y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1 x2 y2 x3 y3 x0 y0   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   closepath end  gsave 1.5
SLW 0.116 0.565 1  setrgbcolor  1. .setopacityalpha   0  setlinecap
[  5.0  3.0  0.0  0.0 ] 2 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.116 0.565 1  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 34.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { -1  0  0  } def /P2 { 0 0 2 } def /P3 { 2 0 0 }
def /SphericalCoor false def /xUnit { 56.9055  mul } def /yUnit { 56.9055
 mul } def P1 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D
/x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x1 x2D xUnit x0 add def /y1 y2D yUnit y0 add def
P3 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x2
x2D xUnit x1 add def /y2 y2D yUnit y1 add def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x3 x2D xUnit neg x2 add def
/y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1 x2 y2 x3 y3 x0 y0   /Lineto
/lineto load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq
{ 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   closepath end  gsave 1.5
SLW 0.116 0.565 1  setrgbcolor  1. .setopacityalpha   0  setlinecap
[  5.0  3.0  0.0  0.0 ] 2 DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.116 0.565 1  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 34.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { -1 2 add 0 0 add 0 0 add } def /P2 { 0 0 2 } def
/P3 { 0 1 0 } def /SphericalCoor false def /xUnit { 56.9055  mul }
def /yUnit { 56.9055  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 1.5 SLW 0.116 0.565 1  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.116 0.565 1  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 34.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { -1 0 add 0 0 add 0 2 add } def /P2 { 2 0 0 } def
/P3 { 0 1 0 } def /SphericalCoor false def /xUnit { 56.9055  mul }
def /yUnit { 56.9055  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 1.5 SLW 0.116 0.565 1  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.116 0.565 1  setrgbcolor   tx@3DPlotDict
begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle 60.  def
/xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet (set ) def
/Alpha 34.  def /Beta 20.  def /Sin1 Beta sin def /Sin2 Alpha sin def
/Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def
/Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1
Cos2 mul def /showgrid true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict
begin} if /eulerRotation false def RotSet (set ) eq currentdict /MnewTOold
known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion
def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION
/ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION () def}
ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /P1 { -1 0 add 0 1 add 0 0 add } def /P2 { 0 0 2 } def
/P3 { 2 0 0 } def /SphericalCoor false def /xUnit { 56.9055  mul }
def /yUnit { 56.9055  mul } def P1 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x0 x2D xUnit def /y0 y2D yUnit def P2 saveCoor SphericalCoor
{ ConvertToCartesian } if ConvertTo2D /x1 x2D xUnit x0 add def /y1
y2D yUnit y0 add def P3 saveCoor SphericalCoor { ConvertToCartesian
} if ConvertTo2D /x2 x2D xUnit x1 add def /y2 y2D yUnit y1 add def
P2 saveCoor SphericalCoor { ConvertToCartesian } if ConvertTo2D /x3
x2D xUnit neg x2 add def /y3 y2D yUnit neg y2 add def [ x0 y0 x1 y1
x2 y2 x3 y3 x0 y0   /Lineto /lineto load def 1  setlinejoin false 
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5
2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   closepath end  gsave 1.5 SLW 0.116 0.565 1  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.75 0 0 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2.5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1644 4339 a 1644
4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644 4339 a 1644 4339 a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 1644 4339 a 1626 4357
a FF(x)1644 4339 y
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339
a 1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1644 4339 a 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644 4339 a 1644
4339 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 1644 4339 a 1628 4349 a FF(y)1644 4339 y
tx@Dict begin  PutEnd  end
 1644
4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1644 4339
a 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644 4339 a 1644 4339 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 1644 4339 a 1627
4357 a FF(z)1644 4339 y
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644
4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.75 SLW 1 0 0  setrgbcolor  end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.75 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.75 SLW 1 0 0 
setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.75 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.75 SLW 1 0 0 
setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.75 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.75 SLW 1 0 0 
setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial
1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1644 4339 a 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644 4339 a 1644
4339 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1644 4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339
a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1644 4339 a 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644
4339 a 1644 4339 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1644 4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339
a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1644 4339 a 1644
4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1644 4339 a 1644 4339 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1644 4339 a 1644 4339
a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0.1 0.15 -.1 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul
exch 56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644
4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 1644 4339
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 1614 4367 a FN(O)1644 4339 y
tx@Dict begin  PutEnd  end
 1644 4339
a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0.5 -.05 .05 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul
exch 56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 1 0 0 TeXcolorrgb 1618 4359 a
FH(~)1632 4377 y FF(i)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644
4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.1 0.5 .05 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul
exch 56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end


@endspecial 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 1 0 0 TeXcolorrgb
1619 4351 a FH(~)1636 4370 y FF(j)p 0 TeXcolorgray 1644
4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.1 .05 0.5 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul
exch 56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 1 0 0
TeXcolorrgb 1613 4358 a FH(~)1622 4378 y FF(k)p 0 TeXcolorgray
1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 -0.1 2.1 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5
TeXcolorrgb 1626 4362 a Fi(2)p 0 TeXcolorgray 1644 4339
a
tx@Dict begin  PutEnd  end
 1644 4339 a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.1 0.1 0 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end


@endspecial 1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb
1620 4362 a Fi(A)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339
a 1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.1 1.1 0 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1620
4362 a Fi(B)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1 1.1 0 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1620
4363 a Fi(C)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1.1 -0.2 0 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul
exch 56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1620
4362 a Fi(D)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1 1 2.1 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1619
4363 a Fi(G)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -1 0 2.1 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1620
4362 a Fi(H)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 -.1 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1622
4362 a Fi(E)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
1644 4339 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 34.  def /Beta
20.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 1 2.1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  56.9055 mul exch
56.9055 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1644 4339 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  end
 
@endspecial
1644 4339 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1644 4339 a 0.1 0.1 0.5 TeXcolorrgb 1624
4362 a Fi(F)p 0 TeXcolorgray 1644 4339 a
tx@Dict begin  PutEnd  end
 1644 4339 a
109 4998 a
SDict begin H.S end
 109 4998 a 109 4998 a
SDict begin 12 H.A end
 109 4998 a 109 4998
a
SDict begin [/View [/XYZ H.V]/Dest (Item.82) cvn /DEST pdfmark end
 109 4998 a 109 4998 a
SDict begin H.S end
 109 4998 a 109 4998 a
SDict begin 12 H.A end
 109 4998
a 109 4998 a
SDict begin [/View [/XYZ H.V]/Dest (Item.83) cvn /DEST pdfmark end
 109 4998 a 0 TeXcolorgray 114 x FP(1.)p
0 TeXcolorgray 0 TeXcolorgray 141 w FN(\(a\))p 0 TeXcolorgray
40 w(Quel)22 b(ensemble)e(de)i(points)f(de)h(l'espace)f(a)g(pour)h
(\351quation)j FF(z)16 b FC(\306)e FN(2)f(?)109 5143
y
SDict begin H.S end
 109 5143 a 109 5143 a
SDict begin 12 H.A end
 109 5143 a 109 5143 a
SDict begin [/View [/XYZ H.V]/Dest (Item.84) cvn /DEST pdfmark end
 109 5143
a 0 TeXcolorgray 315 5241 a FN(\(b\))p 0 TeXcolorgray
40 w(D\351terminer)22 b(une)f(\351quation)g(du)h(plan)g(\()6
b FF(A)t(B)t(F)g FN(\).)109 5271 y
SDict begin H.S end
 109 5271 a 109 5271
a
SDict begin 12 H.A end
 109 5271 a 109 5271 a
SDict begin [/View [/XYZ H.V]/Dest (Item.85) cvn /DEST pdfmark end
 109 5271 a 0 TeXcolorgray 322
5369 a FN(\(c\))p 0 TeXcolorgray 41 w(En)21 b(d\351duire)h(un)g
(syst\350me)f(d'\351quations)g(qui)h(caract\351rise)f(la)h(droite)g(\()
r FF(E)5 b(F)h FN(\).)109 5399 y
SDict begin H.S end
 109 5399 a 109 5399
a
SDict begin 12 H.A end
 109 5399 a 109 5399 a
SDict begin [/View [/XYZ H.V]/Dest (Item.86) cvn /DEST pdfmark end
 109 5399 a 109 5399 a
SDict begin H.S end
 109 5399
a 109 5399 a
SDict begin 12 H.A end
 109 5399 a 109 5399 a
SDict begin [/View [/XYZ H.V]/Dest (Item.87) cvn /DEST pdfmark end
 109 5399 a 0 TeXcolorgray
98 x FP(2.)p 0 TeXcolorgray 0 TeXcolorgray 141 w FN(\(a\))p
0 TeXcolorgray 40 w(Quelles)22 b(sont)f(les)g(coordonn\351es)f(des)i
(points)27 b FF(A)s FN(,)22 b FF(G)k FN(et)d FF(P)18
b FN(?)109 5527 y
SDict begin H.S end
 109 5527 a 109 5527 a
SDict begin 12 H.A end
 109 5527 a 109
5527 a
SDict begin [/View [/XYZ H.V]/Dest (Item.88) cvn /DEST pdfmark end
 109 5527 a 0 TeXcolorgray 315 5625 a FN(\(b\))p
0 TeXcolorgray 40 w(Placer)23 b(sur)f(la)f(\002gure)h(le)g(point)f
FF(Q)26 b FN(de)21 b(coordonn\351es)f(\(0;)8 b(0)p FG(,)p
FN(5;)g(0\).)109 5656 y
SDict begin H.S end
 109 5656 a 109 5656 a
SDict begin 12 H.A end
 109 5656
a 109 5656 a
SDict begin [/View [/XYZ H.V]/Dest (Item.89) cvn /DEST pdfmark end
 109 5656 a 0 TeXcolorgray 322 5754 a FN(\(c\))p
0 TeXcolorgray 41 w(D\351terminer)21 b(une)h(\351quation)f
(cart\351sienne)g(du)h(plan)g(\()6 b FF(A)f(P)g(Q)t FN(\).)109
5784 y
SDict begin H.S end
 109 5784 a 109 5784 a
SDict begin 12 H.A end
 109 5784 a 109 5784 a
SDict begin [/View [/XYZ H.V]/Dest (Item.90) cvn /DEST pdfmark end
 109
5784 a 109 5784 a
SDict begin H.S end
 109 5784 a 109 5784 a
SDict begin 12 H.A end
 109 5784 a 109
5784 a
SDict begin [/View [/XYZ H.V]/Dest (Item.91) cvn /DEST pdfmark end
 109 5784 a 0 TeXcolorgray 98 x FP(3.)p 0 TeXcolorgray
0 TeXcolorgray 141 w FN(\(a\))p 0 TeXcolorgray 40 w(Construire)22
b(sur)g(la)f(\002gure)h(les)g(segments)e([)r FF(P)5 b(Q)t
FN(])21 b(et)g([)6 b FF(A)r(G)t FN(].)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 20 20
TeXDict begin 20 19 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.20) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(20)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (Item.92) cvn /DEST pdfmark end
 -128 -121 a 0 TeXcolorgray 78 -38 a FN(\(b\))p 0 TeXcolorgray
41 w(Le)22 b(point)f FF(G)26 b FN(appartient-il)c(au)g(plan)g(\()6
b FF(A)f(P)g(Q)t FN(\))13 b(?)22 b(J)n(usti\002er)-8
b(.)-128 -8 y
SDict begin H.S end
 -128 -8 a -128 -8 a
SDict begin 12 H.A end
 -128 -8 a -128 -8 a
SDict begin [/View [/XYZ H.V]/Dest (Item.93) cvn /DEST pdfmark end

-128 -8 a 0 TeXcolorgray 98 x FP(4.)p 0 TeXcolorgray
141 w FN(On)33 b(construit)g(la)f(\002gure)h(pr\351c\351dente)f(\340)g
(l'aide)h(d'un)g(logiciel)g(de)f(g\351om\351trie)o(,)g(puis)h(on)f
(demande)f(au)i(logiciel)78 190 y(de)d(repr\351senter)f(le)g(point)h
(d'intersection)f(des)g(droites)h(\()6 b FF(A)r(G)t FN(\))29
b(et)g(\()r FF(P)5 b(Q)t FN(\).)30 b(Quelle)g(pourrait)g(\352tre)f(la)g
(r\351ponse)g(de)78 289 y(l'ordinateur)14 b(?)-128 333
y
SDict begin H.S end
 -128 333 a -128 333 a
SDict begin 12 H.A end
 -128 333 a -128 333 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.19) cvn /DEST pdfmark
end
 -128 333
a 201 x FP(Exercice)23 b(n)297 509 y Fb(o)343 534 y FP(19)p
475 509 3178 4 v -128 672 a FN(Dans)f(l'espace)f(muni)h(d'un)f
(rep\350re)1011 585 y Fo(\263)1042 672 y FN(O;)1121 654
y FH(~)1135 672 y FF(i)s FG(,)1179 654 y FH(~)1196 672
y FF(j)t FG(,)1238 652 y FH(~)1247 672 y FF(k)1292 585
y Fo(\264)1324 672 y FN(,)g(on)h(consid\350re)f(les)g(points)28
b FF(A)s FN(\()p FC(\241)p FN(1;)8 b(6;)g(7)p FG(,)p
FN(5\))23 b(et)f FF(B)r FN(\()p FC(\241)p FN(2;)8 b(8;)g(9\).)-128
748 y
SDict begin H.S end
 -128 748 a -128 748 a
SDict begin 12 H.A end
 -128 748 a -128 748 a
SDict begin [/View [/XYZ H.V]/Dest (Item.94) cvn /DEST pdfmark end
 -128
748 a 0 TeXcolorgray 79 x FP(1.)p 0 TeXcolorgray 141
w FN(D\351terminer)23 b(une)h(\351quation)f(cart\351sienne)g(du)h(plan)
i FF(P)j FN(parall\350le)24 b(\340)f(l'axe)h(\()p FF(O)6
b(z)r FN(\))23 b(et)g(passant)g(par)h(les)f(points)29
b FF(A)e FN(et)79 927 y FF(B)r FN(.)-128 942 y
SDict begin H.S end
 -128 942
a -128 942 a
SDict begin 12 H.A end
 -128 942 a -128 942 a
SDict begin [/View [/XYZ H.V]/Dest (Item.95) cvn /DEST pdfmark end
 -128 942 a 0 TeXcolorgray
113 x FP(2.)p 0 TeXcolorgray 141 w FN(D\351terminer)c(une)g
(\351quation)f(cart\351sienne)h(du)g(plan)g FF(Q)k FN(parall\350le)c
(\340)g(l'axe)g(\()p FF(O)9 b(y)p FN(\))23 b(et)f(passant)h(par)g(les)g
(points)29 b FF(A)d FN(et)79 1155 y FF(B)r FN(.)-128
1170 y
SDict begin H.S end
 -128 1170 a -128 1170 a
SDict begin 12 H.A end
 -128 1170 a -128 1170
a
SDict begin [/View [/XYZ H.V]/Dest (Item.96) cvn /DEST pdfmark end
 -128 1170 a 0 TeXcolorgray 113 x FP(3.)p 0 TeXcolorgray
141 w FN(Soit)d FF(d)j FN(la)c(droite)f(caract\351ris\351e)h(par)g(le)f
(syst\350me)f(:)1519 1337 y Fo(\275)1607 1395 y FN(2)s
FF(x)11 b FC(\305)17 b FF(y)122 b FC(\306)k FN(4)1607
1495 y(3)s FF(x)11 b FC(\305)f FN(2)t FF(z)85 b FC(\306)e
FN(12)78 1607 y(Les)22 b(points)27 b FF(A)e FN(et)d FF(B)h
FN(sont-ils)e(sur)h(la)g(droite)h FF(d)16 b FN(?)-128
1638 y
SDict begin H.S end
 -128 1638 a -128 1638 a
SDict begin 12 H.A end
 -128 1638 a -128 1638
a
SDict begin [/View [/XYZ H.V]/Dest (Item.97) cvn /DEST pdfmark end
 -128 1638 a 0 TeXcolorgray 113 x FP(4.)p 0 TeXcolorgray
141 w FN(Dans)29 b(le)f(rep\350re)641 1663 y Fo(\263)673
1751 y FN(O;)752 1732 y FH(~)766 1751 y FF(i)s FG(,)810
1732 y FH(~)827 1751 y FF(j)s FG(,)868 1731 y FH(~)877
1751 y FF(k)923 1663 y Fo(\264)954 1751 y FN(ci-dessous)n(,)g
(repr\351senter)g(les)g(plans)j FF(P)k FN(et)27 b FF(Q)32
b FN(par)d(leurs)g(traces)f(a)o(vec)h(les)f(plans)h(de)78
1863 y(base)21 b(ainsi)h(que)f(la)h(droite)g(\()6 b FF(A)t(B)r
FN(\).)p 0 TeXcolorgray 0 TeXcolorgray 1998 3967 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 256.073 0.0  0.0 0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 25.6073 256.073 0.0  25.6073
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 51.2146 256.073 0.0  51.2146
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 76.8219 256.073 0.0  76.8219
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 102.4292 256.073 0.0  102.4292
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 128.0365 256.073 0.0  128.0365
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 153.6438 256.073 0.0  153.6438
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 179.2511 256.073 0.0  179.2511
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 204.8584 256.073 0.0  204.8584
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 230.4657 256.073 0.0  230.4657
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 256.073 0.0  256.073
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0 0.0  0 0.0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 25.6073 0.0  0 25.6073
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 51.2146 0.0  0 51.2146
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 76.8219 0.0  0 76.8219
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 102.4292 0.0  0 102.4292
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 128.0365 0.0  0 128.0365
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 153.6438 0.0  0 153.6438
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 179.2511 0.0  0 179.2511
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 204.8584 0.0  0 204.8584
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 230.4657 0.0  0 230.4657
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 256.073 0.0  0 256.073
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 0.0  256.073 0.0 0.0  0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 25.6073 0.0  256.073 25.6073
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 51.2146 0.0  256.073 51.2146
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 76.8219 0.0  256.073 76.8219
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 102.4292 0.0  256.073 102.4292
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 128.0365 0.0  256.073 128.0365
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 153.6438 0.0  256.073 153.6438
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 179.2511 0.0  256.073 179.2511
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 204.8584 0.0  256.073 204.8584
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 230.4657 0.0  256.073 230.4657
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  256.073 256.073
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  0.0 0 0.0  0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  25.6073 0 0.0
 25.6073  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  51.2146 0 0.0
 51.2146  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  76.8219 0 0.0
 76.8219  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  102.4292 0 0.0
 102.4292  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  128.0365 0 0.0
 128.0365  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  153.6438 0 0.0
 153.6438  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  179.2511 0 0.0
 179.2511  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  204.8584 0 0.0
 204.8584  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  230.4657 0 0.0
 230.4657  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 256.073 0.0  256.073 0 0.0
 256.073  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  0.0 256.073 0.0  0.0 0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  25.6073 256.073 0.0  25.6073
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  51.2146 256.073 0.0  51.2146
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  76.8219 256.073 0.0  76.8219
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  102.4292 256.073 0.0 
102.4292 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  128.0365 256.073 0.0 
128.0365 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  153.6438 256.073 0.0 
153.6438 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  179.2511 256.073 0.0 
179.2511 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  204.8584 256.073 0.0 
204.8584 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  230.4657 256.073 0.0 
230.4657 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 256.073 0.0  256.073
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 0.0 0.0  0 0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 47.  def /Beta 19.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 0  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 25.6073 0.0  0
25.6073  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 51.2146 0.0  0
51.2146  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 76.8219 0.0  0
76.8219  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 102.4292 0.0 
0 102.4292  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 128.0365 0.0 
0 128.0365  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 153.6438 0.0 
0 153.6438  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 179.2511 0.0 
0 179.2511  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 204.8584 0.0 
0 204.8584  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 230.4657 0.0 
0 230.4657  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  256.073 256.073 0.0  0
256.073  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta 19.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998
3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1998 3967
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 10 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 10 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 10 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1998 3967 a 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3967 a 1998
3967 a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 1998 3967 a 1980 3985 a FF(x)1998 3967 y
tx@Dict begin  PutEnd  end
 1998
3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1998 3967
a 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3967 a 1998 3967 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 1998 3967 a 1982
3977 a FF(y)1998 3967 y
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998
3967 a 1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1998 3967 a 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3967
a 1998 3967 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 1998 3967 a 1981 3985 a FF(z)1998 3967
y
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998
3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial 1998 3967
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 1 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 1 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1998 3967 a 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3967 a 1998
3967 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1998 3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967
a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1998 3967 a 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998
3967 a 1998 3967 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1998 3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967
a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1998 3967 a 1998
3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3967 a 1998 3967 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1998 3967 a 1998 3967
a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998
3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial 1998 3967
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3967 a 1968 3995 a FN(O)1998 3967 y
tx@Dict begin  PutEnd  end
 1998 3967
a 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED .4 -.2 .4 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial
1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3967 a 1 0 0 TeXcolorrgb 1972 3987 a
FH(~)1986 4005 y FF(i)p 0 TeXcolorgray 1998 3967 a
tx@Dict begin  PutEnd  end
 1998
3967 a 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 .8 .4 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3967 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end


@endspecial 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3967 a 1 0 0 TeXcolorrgb
1973 3979 a FH(~)1990 3998 y FF(j)p 0 TeXcolorgray 1998
3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a 1998 3967 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 47.  def /Beta
19.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 0  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .2 1 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  25.6073 mul exch
25.6073 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3967 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial 1998 3967 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3967 a 1 0 0
TeXcolorrgb 1967 3986 a FH(~)1976 4006 y FF(k)p 0 TeXcolorgray
1998 3967 a
tx@Dict begin  PutEnd  end
 1998 3967 a -128 5000 a
SDict begin H.S end
 -128 5000 a -128
5000 a
SDict begin 12 H.A end
 -128 5000 a -128 5000 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.20) cvn /DEST pdfmark
end
 -128 5000 a 202 x FP(Exercice)23
b(n)297 5177 y Fb(o)343 5202 y FP(20)p 475 5177 3178
4 v -128 5340 a FN(L)-8 b('espace)22 b(est)f(muni)h(d'un)f(rep\350re)
949 5253 y Fo(\263)980 5340 y FN(O;)1059 5322 y FH(~)1073
5340 y FF(i)s FG(,)1117 5322 y FH(~)1134 5340 y FF(j)s
FG(,)1175 5320 y FH(~)1184 5340 y FF(k)1230 5253 y Fo(\264)1261
5340 y FN(orthonormal)h(repr\351sent\351)e(en)i(annexe)f(ci-dessous)n
(.)-128 5416 y
SDict begin H.S end
 -128 5416 a -128 5416 a
SDict begin 12 H.A end
 -128 5416 a -128
5416 a
SDict begin [/View [/XYZ H.V]/Dest (Item.98) cvn /DEST pdfmark end
 -128 5416 a 0 TeXcolorgray 79 x FP(1.)p 0 TeXcolorgray
141 w FN(Tracer)j(les)d(droites)i(d'intersection)f(du)h(plan)g
FI(\274)f FN(d'\351quation)g(5)s FF(x)11 b FC(\305)f
FN(5)d FF(y)k FC(\305)f FN(6)t FF(z)16 b FC(\306)f FN(15)22
b(a)o(vec)h(les)f(plans)h(de)f(coordonn\351es)78 5610
y(du)g(rep\350re)442 5522 y Fo(\263)473 5610 y FN(O;)552
5591 y FH(~)566 5610 y FF(i)s FG(,)610 5591 y FH(~)627
5610 y FF(j)s FG(,)668 5590 y FH(~)677 5610 y FF(k)723
5522 y Fo(\264)754 5610 y FN(.)-128 5671 y
SDict begin H.S end
 -128 5671
a -128 5671 a
SDict begin 12 H.A end
 -128 5671 a -128 5671 a
SDict begin [/View [/XYZ H.V]/Dest (Item.99) cvn /DEST pdfmark end
 -128 5671 a 0 TeXcolorgray
79 x FP(2.)p 0 TeXcolorgray 141 w FN(On)g(consid\350re)g(le)f(plan)h
FI(\303)14 b FC(\264)h FN(3)s FF(x)c FC(\305)f FN(4)d
FF(y)14 b FC(\306)g FN(6.)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Page: 21 21
TeXDict begin 21 20 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 100
-372 a
SDict begin H.S end
 100 -372 a 100 -372 a
SDict begin H.R end
 100 -372 a 100 -372 a
SDict begin [/View [/XYZ H.V]/Dest (page.21) cvn /DEST pdfmark end
 100
-372 a 0 TeXcolorgray 111 -269 a Fx(G)t(\311)t(O)t(M)t(\311)t(T)t(R)t
(I)t(E)23 b(D)t(A)t(N)t(S)h(L)m FN(')t Fx(E)t(S)t(P)q(A)t(C)t(E)2683
b FN(21)p 109 -238 3780 2 v 0 TeXcolorgray 109 -121 a
SDict begin H.S end

109 -121 a 109 -121 a
SDict begin 12 H.A end
 109 -121 a 109 -121 a
SDict begin [/View [/XYZ H.V]/Dest (Item.100) cvn /DEST pdfmark end
 109 -121
a 0 TeXcolorgray 315 -38 a FN(\(a\))p 0 TeXcolorgray
40 w(Pr\351ciser)23 b(la)e(nature)h(de)f(l'ensemble)f
FH(\242)i FN(des)f(points)k FF(M)h FN(de)21 b(l'espace)g(dont)h(les)f
(coordonn\351es)f(v\351ri\002ent)j(:)1741 15 y Fo(\275)1829
74 y FN(5)s FF(x)11 b FC(\305)f FN(5)d FF(y)j FC(\305)g
FN(6)t FF(z)84 b FC(\306)f FN(15)1988 173 y(3)s FF(x)11
b FC(\305)f FN(4)d FF(y)83 b FC(\306)126 b FN(6)109 221
y
SDict begin H.S end
 109 221 a 109 221 a
SDict begin 12 H.A end
 109 221 a 109 221 a
SDict begin [/View [/XYZ H.V]/Dest (Item.101) cvn /DEST pdfmark end
 109 221 a 0
TeXcolorgray 315 334 a FN(\(b\))p 0 TeXcolorgray 40 w(Repr\351senter)21
b(l'ensemble)f FH(\242)i FN(dans)f(le)h(rep\350re)1908
247 y Fo(\263)1939 334 y FN(O;)2018 316 y FH(~)2032 334
y FF(i)s FG(,)2076 316 y FH(~)2093 334 y FF(j)t FG(,)2135
314 y FH(~)2144 334 y FF(k)2189 247 y Fo(\264)2221 334
y FN(.)109 396 y
SDict begin H.S end
 109 396 a 109 396 a
SDict begin 12 H.A end
 109 396 a 109 396
a
SDict begin [/View [/XYZ H.V]/Dest (Item.102) cvn /DEST pdfmark end
 109 396 a 0 TeXcolorgray 79 x FP(3.)p 0 TeXcolorgray
141 w FN(On)f(donne)h(les)f(points)i FF(D)1116 477 y
FN(\()1142 475 y(1;)8 b(0;)g(0)1329 477 y(\))1356 475
y(,)24 b FF(E)1468 477 y FN(\()1493 475 y(0;)8 b FC(\241)p
FN(3;)g(0)1735 477 y(\))1762 475 y(,)24 b FF(F)1872 477
y FN(\()1898 475 y FC(\241)p FN(1;)8 b FC(\241)p FN(3;)g(4)2195
477 y(\))2243 475 y(et)20 b FF(G)2404 477 y FN(\()2430
475 y(0;)8 b(0;)g(4)2617 477 y(\))2644 475 y(.)109 505
y
SDict begin H.S end
 109 505 a 109 505 a
SDict begin 12 H.A end
 109 505 a 109 505 a
SDict begin [/View [/XYZ H.V]/Dest (Item.103) cvn /DEST pdfmark end
 109 505 a 0
TeXcolorgray 315 603 a FN(\(a\))p 0 TeXcolorgray 40 w(Montrer)22
b(que)f(les)g(points)j FF(D)t FN(,)g FF(E)g FN(et)f FF(F)k
FN(d\351terminent)22 b(un)f(plan.)109 633 y
SDict begin H.S end
 109 633 a
109 633 a
SDict begin 12 H.A end
 109 633 a 109 633 a
SDict begin [/View [/XYZ H.V]/Dest (Item.104) cvn /DEST pdfmark end
 109 633 a 0 TeXcolorgray
315 731 a FN(\(b\))p 0 TeXcolorgray 40 w(Les)h(points)h
FF(D)t FN(,)h FF(E)s FN(,)g FF(F)j FN(et)21 b FF(G)k
FN(sont-ils)d(coplanaires)13 b(?)109 762 y
SDict begin H.S end
 109 762 a
109 762 a
SDict begin 12 H.A end
 109 762 a 109 762 a
SDict begin [/View [/XYZ H.V]/Dest (Item.105) cvn /DEST pdfmark end
 109 762 a 0 TeXcolorgray
322 860 a FN(\(c\))p 0 TeXcolorgray 41 w(D\351terminer)21
b(une)h(\351quation)f(du)h(plan)g FI(\271)g FN(qui)f(contient)h(les)f
(points)j FF(D)t FN(,)g FF(E)s FN(,)f FF(F)6 b FN(.)109
892 y
SDict begin H.S end
 109 892 a 109 892 a
SDict begin 12 H.A end
 109 892 a 109 892 a
SDict begin [/View [/XYZ H.V]/Dest (Item.106) cvn /DEST pdfmark end
 109 892
a 0 TeXcolorgray 315 1005 a FN(\(d\))p 0 TeXcolorgray
41 w(Repr\351senter)20 b(l'intersection)i(des)f(trois)h(plans)g
FI(\274)p FN(,)f FI(\303)h FN(et)f FI(\271)g FN(dans)h(le)f(rep\350re)
2793 918 y Fo(\263)2824 1005 y FN(O;)2903 987 y FH(~)2917
1005 y FF(i)s FG(,)2961 987 y FH(~)2978 1005 y FF(j)t
FG(,)3020 985 y FH(~)3029 1005 y FF(k)3074 918 y Fo(\264)109
1067 y
SDict begin H.S end
 109 1067 a 109 1067 a
SDict begin 12 H.A end
 109 1067 a 109 1067 a
SDict begin [/View [/XYZ H.V]/Dest (Item.107) cvn /DEST pdfmark end
 109
1067 a 0 TeXcolorgray 79 x FP(4.)p 0 TeXcolorgray 141
w FN(R\351soudre)f(le)i(syst\350me)e(suivant)i(et)f(en)h(donner)f(une)h
(interpr\351tation)g(graphique)o(.)1643 1200 y Fo(8)1643
1269 y(<)1643 1406 y(:)1748 1258 y FN(12)s FF(x)11 b
FC(\241)f FN(4)d FF(y)j FC(\305)g FN(3)t FF(z)85 b FC(\306)e
FN(12)1791 1357 y(5)s FF(x)11 b FC(\305)f FN(5)d FF(y)j
FC(\305)g FN(6)t FF(z)85 b FC(\306)e FN(15)1951 1457
y(3)s FF(x)11 b FC(\305)f FN(4)d FF(y)83 b FC(\306)126
b FN(6)p 0 TeXcolorgray 0 TeXcolorgray 1998 3712 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 241.84831 0.0  0.0 0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 14.22636 241.84831 0.0  14.22636
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 28.45273 241.84831 0.0  28.45273
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.6791 241.84831 0.0  42.6791
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 56.90546 241.84831 0.0  56.90546
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 71.13182 241.84831 0.0  71.13182
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 85.35818 241.84831 0.0  85.35818
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 99.58455 241.84831 0.0  99.58455
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 113.81091 241.84831 0.0  113.81091
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 128.03728 241.84831 0.0  128.03728
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 142.26364 241.84831 0.0  142.26364
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 156.49 241.84831 0.0  156.49
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 170.71637 241.84831 0.0  170.71637
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 184.94273 241.84831 0.0  184.94273
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 199.1691 241.84831 0.0  199.1691
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 213.39546 241.84831 0.0  213.39546
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 227.62183 241.84831 0.0  227.62183
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84819 241.84831 0.0  241.84819
0 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0 0.0  0 0.0 0.0
  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 14.22636 0.0  0 14.22636
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 28.45273 0.0  0 28.45273
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 42.6791 0.0  0 42.6791
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 56.90546 0.0  0 56.90546
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 71.13182 0.0  0 71.13182
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 85.35818 0.0  0 85.35818
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 99.58455 0.0  0 99.58455
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 113.81091 0.0  0
113.81091 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 128.03728 0.0  0
128.03728 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 142.26364 0.0  0
142.26364 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 156.49 0.0  0 156.49
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 170.71637 0.0  0
170.71637 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 184.94273 0.0  0
184.94273 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 199.1691 0.0  0 199.1691
0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 213.39546 0.0  0
213.39546 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 227.62183 0.0  0
227.62183 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 241.84819 0.0  0
241.84819 0.0   tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0 0.0  241.84831 0.0 0.0
 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 14.22636 0.0  241.84831 14.22636
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 28.45273 0.0  241.84831 28.45273
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 42.6791 0.0  241.84831 42.6791
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 56.90546 0.0  241.84831 56.90546
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 71.13182 0.0  241.84831 71.13182
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 85.35818 0.0  241.84831 85.35818
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 99.58455 0.0  241.84831 99.58455
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 113.81091 0.0  241.84831 113.81091
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 128.03728 0.0  241.84831 128.03728
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 142.26364 0.0  241.84831 142.26364
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 156.49 0.0  241.84831 156.49
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 170.71637 0.0  241.84831 170.71637
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 184.94273 0.0  241.84831 184.94273
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 199.1691 0.0  241.84831 199.1691
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 213.39546 0.0  241.84831 213.39546
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 227.62183 0.0  241.84831 227.62183
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84819 0.0  241.84831 241.84819
0.0  0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  0.0 0 0.0  0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  14.22636 0 0.0
 14.22636  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  28.45273 0 0.0
 28.45273  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  42.6791 0 0.0
 42.6791  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  56.90546 0 0.0
 56.90546  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  71.13182 0 0.0
 71.13182  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  85.35818 0 0.0
 85.35818  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  99.58455 0 0.0
 99.58455  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  113.81091 0
0.0  113.81091  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  128.03728 0
0.0  128.03728  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  142.26364 0
0.0  142.26364  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  156.49 0 0.0
 156.49  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  170.71637 0
0.0  170.71637  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  184.94273 0
0.0  184.94273  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  199.1691 0 0.0
 199.1691  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  213.39546 0
0.0  213.39546  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  227.62183 0
0.0  227.62183  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 241.84831 0.0  241.84819 0
0.0  241.84819  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  0.0 241.84831 0.0  0.0
0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def
/RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def
/dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def
/RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def
/Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2
Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul
def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  14.22636 241.84831 0.0
 14.22636 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  28.45273 241.84831 0.0
 28.45273 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  42.6791 241.84831 0.0
 42.6791 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  56.90546 241.84831 0.0
 56.90546 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  71.13182 241.84831 0.0
 71.13182 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  85.35818 241.84831 0.0
 85.35818 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  99.58455 241.84831 0.0
 99.58455 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  113.81091 241.84831 0.0
 113.81091 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  128.03728 241.84831 0.0
 128.03728 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  142.26364 241.84831 0.0
 142.26364 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  156.49 241.84831 0.0 
156.49 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  170.71637 241.84831 0.0
 170.71637 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  184.94273 241.84831 0.0
 184.94273 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  199.1691 241.84831 0.0
 199.1691 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  213.39546 241.84831 0.0
 213.39546 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  227.62183 241.84831 0.0
 227.62183 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84819 241.84831 0.0
 241.84819 0  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 0.0 0.0  0 0.0
 tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.  def /RotAngle
60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec 0.  def /dxUnit
1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence (xyz ) def /RotSet
(set ) def /Alpha 145.  def /Beta 30.  def /Sin1 Beta sin def /Sin2
Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos def /Cos1Sin2 Cos1
Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2 Cos1 Cos2 mul def
/Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict tx@3DPlotDict
ne dup {tx@3DPlotDict begin} if /eulerRotation false def RotSet (set )
eq currentdict /MnewTOold known not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION
/SetMQuaternion def} {RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def
/PROCMQUATERNION /ConcatMQuaternion def} {/PROCMXYZ () def /PROCMQUATERNION
() def} ifelse } ifelse RotSequence (quaternion ) ne {PROCMXYZ} {PROCMQUATERNION}
ifelse cvx exec /RotSet (keep ) def {end} if /leftHanded false def
/coorType 1  def /SphericalCoorType 0  def 1 1 2  /zLight ED /yLight
ED /xLight ED /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /SphericalCoor
false def /xUnit { 1.0  mul } def /yUnit { 1.0  mul } def convertStackTo2D
end   /Lineto /lineto load def 1  setlinejoin false   NArray n 0 eq
not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add
dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1
ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.1 SLW 0.25  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 14.22636 0.0
 0 14.22636  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 28.45273 0.0
 0 28.45273  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 42.6791 0.0
 0 42.6791  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 56.90546 0.0
 0 56.90546  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 71.13182 0.0
 0 71.13182  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 85.35818 0.0
 0 85.35818  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 99.58455 0.0
 0 99.58455  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 113.81091 0.0
 0 113.81091  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 128.03728 0.0
 0 128.03728  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 142.26364 0.0
 0 142.26364  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 156.49 0.0 
0 156.49  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ 0.
 def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 170.71637 0.0
 0 170.71637  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 184.94273 0.0
 0 184.94273  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 199.1691 0.0
 0 199.1691  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 213.39546 0.0
 0 213.39546  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 227.62183 0.0
 0 227.62183  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.1 SLW 0.25  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 0.0  241.84831 241.84819 0.0
 0 241.84819  tx@3DPlotDict begin   /RotX 0.  def /RotY 0.  def /RotZ
0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec 0.  def /zRotVec
0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0 def /RotSequence
(xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta 30.  def /Sin1
Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def /Cos2 Alpha cos
def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2 mul def /Cos1Cos2
Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid true def currentdict
tx@3DPlotDict ne dup {tx@3DPlotDict begin} if /eulerRotation false
def RotSet (set ) eq currentdict /MnewTOold known not or {/PROCMXYZ
/SetMxyz def /PROCMQUATERNION /SetMQuaternion def} {RotSet (concat )
eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion def}
{/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED /dxUnit 1 def /dyUnit
1.0 def /dzUnit 1.0 def /SphericalCoor false def /xUnit { 1.0  mul
} def /yUnit { 1.0  mul } def convertStackTo2D end   /Lineto /lineto
load def 1  setlinejoin false   NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.1 SLW 0.25  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998
3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial 1998 3712
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 8.5 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 8.5 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 8.5 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.0 SLW 0  setgray  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.0 SLW 0  setgray 
/ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1998 3712 a 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3712 a 1998
3712 a
tx@Dict begin { 5.0 5.14998 4.42499 0.15 180.  Uput UUput } PutCoor
PutBegin  end
 1998 3712 a 1980 3730 a FF(x)1998 3712 y
tx@Dict begin  PutEnd  end
 1998
3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1998 3712
a 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3712 a 1998 3712 a
tx@Dict begin { 5.0 5.54999 4.42499 1.90999 0.  Uput UUput } PutCoor
PutBegin  end
 1998 3712 a 1982
3722 a FF(y)1998 3712 y
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998
3712 a 1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1998 3712 a 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3712
a 1998 3712 a
tx@Dict begin { 5.0 5.00998 4.42499 0.15 90.  Uput UUput } PutCoor
PutBegin  end
 1998 3712 a 1981 3730 a FF(z)1998 3712
y
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@xMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998
3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial 1998 3712
a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 2 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@xMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@yMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 2 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@yMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 0 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@zMin 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (keep ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 2 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@zMax 10 {InitPnode } /NodeScale {} def
NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.5 SLW 1 0 0  setrgbcolor  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@xMin
known { /N@xMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@yMin
known { /N@yMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.5 SLW 1 0 0  setrgbcolor
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax load
GetCenter } { 0 0 } ifelse end tx@NodeDict begin tx@NodeDict /N@zMin
known { /N@zMin load GetCenter } { 0 0 } ifelse end    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.5 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 180.  def grestore  end
 1998 3712 a 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@xMax known { /N@xMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3712 a 1998
3712 a
tx@Dict begin { 5.0 0.0 0.0 0.0 180.  Uput UUput } PutCoor PutBegin
 end
 1998 3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712
a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 1998 3712 a 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@yMax known { /N@yMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998
3712 a 1998 3712 a
tx@Dict begin { 5.0 0.0 0.0 0.0 0.  Uput UUput } PutCoor PutBegin 
end
 1998 3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712
a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  gsave STV CP T /ps@refangle 90.  def grestore  end
 1998 3712 a 1998
3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@zMax known { /N@zMax
load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin  end
 1998 3712 a 1998 3712 a
tx@Dict begin { 5.0 0.0 0.0 0.0 90.  Uput UUput } PutCoor PutBegin
 end
 1998 3712 a 1998 3712
a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 0 0 -.3 1.0 mul /z ED
1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul exch
28.45274 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998
3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial 1998 3712
a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3712 a 1968 3740 a FN(O)1998 3712 y
tx@Dict begin  PutEnd  end
 1998 3712
a 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED 1.5 -.2 .4 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul
exch 28.45274 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial
1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3712 a 1 0 0 TeXcolorrgb 1972 3732 a
FH(~)1986 3751 y FF(i)p 0 TeXcolorgray 1998 3712 a
tx@Dict begin  PutEnd  end
 1998
3712 a 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -0.2 1.5 .4 1.0 mul
/z ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul
exch 28.45274 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end


@endspecial 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3712 a 1 0 0 TeXcolorrgb
1973 3725 a FH(~)1990 3743 y FF(j)p 0 TeXcolorgray 1998
3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 1998 3712 a
tx@Dict begin tx@NodeDict begin { tx@3DPlotDict begin   /RotX 0.  def
/RotY 0.  def /RotZ 0.  def /RotAngle 60.  def /xRotVec 1.  def /yRotVec
0.  def /zRotVec 0.  def /dxUnit 1 def /dyUnit 1.0 def /dzUnit 1.0
def /RotSequence (xyz ) def /RotSet (set ) def /Alpha 145.  def /Beta
30.  def /Sin1 Beta sin def /Sin2 Alpha sin def /Cos1 Beta cos def
/Cos2 Alpha cos def /Cos1Sin2 Cos1 Sin2 mul def /Sin1Sin2 Sin1 Sin2
mul def /Cos1Cos2 Cos1 Cos2 mul def /Sin1Cos2 Sin1 Cos2 mul def /showgrid
true def currentdict tx@3DPlotDict ne dup {tx@3DPlotDict begin} if
/eulerRotation false def RotSet (set ) eq currentdict /MnewTOold known
not or {/PROCMXYZ /SetMxyz def /PROCMQUATERNION /SetMQuaternion def}
{RotSet (concat ) eq {/PROCMXYZ /ConcatMxyz def /PROCMQUATERNION /ConcatMQuaternion
def} {/PROCMXYZ () def /PROCMQUATERNION () def} ifelse } ifelse RotSequence
(quaternion ) ne {PROCMXYZ} {PROCMQUATERNION} ifelse cvx exec /RotSet
(keep ) def {end} if /leftHanded false def /coorType 1  def /SphericalCoorType
0  def 1 1 2  /zLight ED /yLight ED /xLight ED -.2 .2 1.5 1.0 mul /z
ED 1.0 mul /y ED 1 mul /x ED ConvertTo2D x2D y2D end  28.45274 mul
exch 28.45274 mul exch } false /N@temp@pstNode 10 {InitPnode } /NodeScale
{} def NewNode end end
 1998 3712 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.1 SLW 0.25  setgray  end
 
@endspecial 1998 3712 a
tx@Dict begin { tx@NodeDict begin tx@NodeDict /N@temp@pstNode known
{ /N@temp@pstNode load GetCenter } { 0 0 } ifelse end } PutCoor PutBegin
 end
 1998 3712 a 1 0 0
TeXcolorrgb 1967 3731 a FH(~)1976 3751 y FF(k)p 0 TeXcolorgray
1998 3712 a
tx@Dict begin  PutEnd  end
 1998 3712 a 109 4977 a
SDict begin H.S end
 109 4977 a 109 4977
a
SDict begin 12 H.A end
 109 4977 a 109 4977 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.21) cvn /DEST pdfmark
end
 109 4977 a 201 x FP(Exercice)22
b(n)533 5153 y Fb(o)579 5178 y FP(21)p 711 5153 3178
4 v 109 5317 a FN(L)-8 b('espace)21 b(est)g(muni)h(d'un)g(rep\350re)f
(orthonormal)1651 5229 y Fo(\263)1682 5317 y FN(O;)1761
5298 y FH(~)1775 5317 y FF(i)s FG(,)1819 5298 y FH(~)1836
5317 y FF(j)t FG(,)1878 5297 y FH(~)1887 5317 y FF(k)1932
5229 y Fo(\264)1964 5317 y FN(.)109 5429 y(Sur)28 b(le)g(dessin)f
(joint)h(en)g(annexe)o(,)g(on)g(a)g(plac\351)g(les)g(points)34
b FF(A)s FN(\(0)28 b(;)36 b(2)28 b(;)37 b(0\),)29 b FF(B)r
FN(\(0)d(;)37 b(0)28 b(;)36 b(6\),)29 b FF(C)s FN(\(4)f(;)36
b(0)28 b(;)37 b(0\),)30 b FF(D)t FN(\(0)d(;)37 b(4)27
b(;)37 b(0\))28 b(et)111 5528 y FF(E)s FN(\(0)20 b(;)30
b(0)22 b(;)30 b(4\).)109 5628 y(Soit)21 b FI(\274)g FN(le)g(plan)i
(d'\351quation)e(3)7 b FF(y)j FC(\305)k FF(z)i FC(\306)e
FN(6.)109 5727 y(Il)22 b(est)f(repr\351sent\351)f(par)i(ses)f(traces)g
(sur)h(le)f(plan)i(de)e(base)g(sur)g(le)h(dessin)f(joint)h(en)f(annexe)
o(.)109 5772 y
SDict begin H.S end
 109 5772 a 109 5772 a
SDict begin 12 H.A end
 109 5772 a 109 5772
a
SDict begin [/View [/XYZ H.V]/Dest (Item.108) cvn /DEST pdfmark end
 109 5772 a 109 5772 a
SDict begin H.S end
 109 5772 a 109 5772 a
SDict begin 12 H.A end
 109 5772
a 109 5772 a
SDict begin [/View [/XYZ H.V]/Dest (Item.109) cvn /DEST pdfmark end
 109 5772 a 0 TeXcolorgray 98 x FP(1.)p 0
TeXcolorgray 0 TeXcolorgray 141 w FN(\(a\))p 0 TeXcolorgray
40 w(D\351montrer)g(que)g(les)h(points)g FF(C)s FN(,)i
FF(D)h FN(et)e FF(E)i FN(d\351terminent)c(un)h(plan)g(que)f(l'on)g
(notera)g(\()q FF(C)5 b(D)h(E)s FN(\).)p 0 TeXcolorgray
0 TeXcolorgray eop end
%%Page: 22 22
TeXDict begin 22 21 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a -136
-372 a
SDict begin H.S end
 -136 -372 a -136 -372 a
SDict begin H.R end
 -136 -372 a -136 -372
a
SDict begin [/View [/XYZ H.V]/Dest (page.22) cvn /DEST pdfmark end
 -136 -372 a 0 TeXcolorgray -128 -269 a FN(22)3388 b
Fx(Math64FL)p -128 -238 3780 2 v 0 TeXcolorgray -128
-121 a
SDict begin H.S end
 -128 -121 a -128 -121 a
SDict begin 12 H.A end
 -128 -121 a -128 -121
a
SDict begin [/View [/XYZ H.V]/Dest (Item.110) cvn /DEST pdfmark end
 -128 -121 a 0 TeXcolorgray 78 -38 a FN(\(b\))p 0 TeXcolorgray
41 w(V\351ri\002er)22 b(que)f(le)g(plan)i(\()q FF(C)5
b(D)h(E)s FN(\))20 b(a)h(pour)h(\351quation)i FF(x)11
b FC(\305)17 b FF(y)10 b FC(\305)k FF(z)i FC(\306)f FN(4.)-128
-8 y
SDict begin H.S end
 -128 -8 a -128 -8 a
SDict begin 12 H.A end
 -128 -8 a -128 -8 a
SDict begin [/View [/XYZ H.V]/Dest (Item.111) cvn /DEST pdfmark end
 -128 -8
a -128 -8 a
SDict begin H.S end
 -128 -8 a -128 -8 a
SDict begin 12 H.A end
 -128 -8 a -128 -8 a
SDict begin [/View [/XYZ H.V]/Dest (Item.112) cvn /DEST pdfmark end
 -128
-8 a 0 TeXcolorgray 98 x FP(2.)p 0 TeXcolorgray 0 TeXcolorgray
141 w FN(\(a\))p 0 TeXcolorgray 41 w(J)n(usti\002er)22
b(que)f(les)g(plans)h FI(\274)g FN(et)f(\()q FF(C)5 b(D)h(E)s
FN(\))20 b(sont)h(s\351cants)n(.)h(On)f(note)g FH(\242)h
FN(leur)g(intersection.)-128 121 y
SDict begin H.S end
 -128 121 a -128 121
a
SDict begin 12 H.A end
 -128 121 a -128 121 a
SDict begin [/View [/XYZ H.V]/Dest (Item.113) cvn /DEST pdfmark end
 -128 121 a 0 TeXcolorgray 78
218 a FN(\(b\))p 0 TeXcolorgray 41 w(Sans)f(justi\002er)-8
b(,)23 b(repr\351senter)e FH(\242)g FN(en)h(couleur)f(\(ou)g(\340)h
(d\351faut)f(en)g(traits)h(pointill\351s\))g(sur)g(la)f(\002gure)i(en)e
(annexe)o(.)-128 249 y
SDict begin H.S end
 -128 249 a -128 249 a
SDict begin 12 H.A end
 -128 249
a -128 249 a
SDict begin [/View [/XYZ H.V]/Dest (Item.114) cvn /DEST pdfmark end
 -128 249 a 0 TeXcolorgray 98 x FP(3.)p 0
TeXcolorgray 141 w FN(On)h(consid\350re)g(les)f(points)i
FF(F)6 b FN(\(2)21 b(;)30 b(0)22 b(;)30 b(0\))21 b(et)f
FF(G)t FN(\(0)i(;)30 b(3)21 b(;)30 b(0\).)78 476 y(On)22
b(note)f FI(\303)g FN(le)h(plan)g(parall\350le)g(\340)g(l'axe)1313
388 y Fo(\263)1345 476 y FN(O;)1448 456 y FH(~)1458 476
y FF(k)1503 388 y Fo(\264)1556 476 y FN(et)f(contenant)g(les)g(points)j
FF(F)k FN(et)20 b FF(G)t FN(.)-128 537 y
SDict begin H.S end
 -128 537 a -128
537 a
SDict begin 12 H.A end
 -128 537 a -128 537 a
SDict begin [/View [/XYZ H.V]/Dest (Item.115) cvn /DEST pdfmark end
 -128 537 a 0 TeXcolorgray
78 616 a FN(\(a\))p 0 TeXcolorgray 41 w(Placer)j(sur)e(la)h(\002gure)g
(en)f(annexe)h(les)f(points)j FF(F)j FN(et)20 b FF(G)t
FN(.)213 730 y(Sans)i(justi\002er)-8 b(,)24 b(repr\351senter)f(le)g
(plan)h FI(\303)f FN(par)h(ses)e(traces)h(sur)g(les)g(plans)g(de)g
(base)o(,)g(d'une)g(autre)g(couleur)g(\(ou)213 830 y(\340)e(d\351faut)g
(en)h(larges)f(pointill\351s\),)i(sur)f(la)f(\002gure)h(en)g(annexe)o
(.)-128 860 y
SDict begin H.S end
 -128 860 a -128 860 a
SDict begin 12 H.A end
 -128 860 a -128 860
a
SDict begin [/View [/XYZ H.V]/Dest (Item.116) cvn /DEST pdfmark end
 -128 860 a 0 TeXcolorgray 78 958 a FN(\(b\))p 0 TeXcolorgray
41 w(D\351terminer)f(les)g(r\351els)j FF(a)e FN(et)h
FF(b)g FN(tels)f(que)h FF(a)s(x)11 b FC(\305)h FF(b)c(y)16
b FC(\306)e FN(6)22 b(soit)f(une)g(\351quation)g(du)h(plan)h
FI(\303)p FN(.)-128 991 y
SDict begin H.S end
 -128 991 a -128 991 a
SDict begin 12 H.A end
 -128
991 a -128 991 a
SDict begin [/View [/XYZ H.V]/Dest (Item.117) cvn /DEST pdfmark end
 -128 991 a 0 TeXcolorgray 95 x FP(4.)p
0 TeXcolorgray 141 w FN(L)-8 b('intersection)23 b(des)e(plans)h(\()q
FF(C)5 b(D)h(E)s FN(\))20 b(et)h FI(\303)h FN(est)e(la)i(droite)g
FH(\242)1871 1056 y Fw(0)1892 1086 y FN(.)78 1200 y(Sans)f(justi\002er)
-8 b(,)22 b(repr\351senter)f(la)h(droite)f FH(\242)1401
1170 y Fw(0)1423 1200 y FN(,)h(d'une)f(troisi\350me)f(couleur)i(\(ou)f
(\340)g(d\351faut)g(en)g(tr\350s)g(larges)h(pointill\351s\),)78
1300 y(sur)g(la)g(\002gure)g(en)f(annexe)o(.)-128 1330
y
SDict begin H.S end
 -128 1330 a -128 1330 a
SDict begin 12 H.A end
 -128 1330 a -128 1330 a
SDict begin [/View [/XYZ H.V]/Dest (Item.118) cvn /DEST pdfmark end
 -128
1330 a 0 TeXcolorgray 98 x FP(5.)p 0 TeXcolorgray 141
w FN(On)h(consid\350re)g(le)f(syst\350me)f(de)i(trois)f(\351quations)g
(\340)g(trois)h(inconnues)g(suivant)g(:)1515 1562 y Fo(8)1515
1631 y(<)1515 1769 y(:)1695 1620 y FN(3)7 b FF(y)j FC(\305)k
FF(z)84 b FC(\306)f FN(6)1622 1720 y FF(x)11 b FC(\305)17
b FF(y)10 b FC(\305)k FF(z)85 b FC(\306)e FN(4)1619 1820
y(3)s FF(x)11 b FC(\305)f FN(2)d FF(y)114 b FC(\306)83
b FN(6)-128 1892 y
SDict begin H.S end
 -128 1892 a -128 1892 a
SDict begin 12 H.A end
 -128 1892
a -128 1892 a
SDict begin [/View [/XYZ H.V]/Dest (Item.119) cvn /DEST pdfmark end
 -128 1892 a 0 TeXcolorgray 78 1972 a FN(\(a\))p
0 TeXcolorgray 41 w(R\351soudre)21 b(ce)g(syst\350me)o(.)-128
2002 y
SDict begin H.S end
 -128 2002 a -128 2002 a
SDict begin 12 H.A end
 -128 2002 a -128 2002
a
SDict begin [/View [/XYZ H.V]/Dest (Item.120) cvn /DEST pdfmark end
 -128 2002 a 0 TeXcolorgray 78 2100 a FN(\(b\))p 0 TeXcolorgray
41 w(Que)h(peut-on)f(alors)g(en)g(d\351duire)h(pour)g(les)f(droites)h
FH(\242)f FN(et)g FH(\242)2069 2070 y Fw(0)2104 2100
y FN(?)p 0 TeXcolorgray 0 TeXcolorgray 1715 3719 a
tx@Dict begin { 5.69057 170.71712 } PutCoor PutBegin  end
 1715
3719 a 1585 3740 a Fs(A)t(N)t(N)t(E)t(X)t(E)1715 3719
y
tx@Dict begin  PutEnd  end
 1715 3719 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray   gsave 0.1 SLW 0.5
 setgray -91.04913 -62.59627 102.43027 170.71712 0.0 0.0 22.76228 abs
22.76228 abs 1 0 { 0  setgray } 0.0 /Helvetica findfont 0.0 scalefont
setfont Grid grestore  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  
/showOrigin true def 102.43027  0 0.0  0 ArrowA CP 4 2 roll ArrowB
2 copy /yEnd exch def /xEnd exch def L  1  setlinejoin 0  setlinecap
stroke  stroke /yStart exch def /xStart exch def 0 dup 2 mod 0 eq false
and exch 2 lt true and or { /viceversa 0.0  102.43027  gt { true }{
false } ifelse def /epsilon 0.01 def /minTickline 0.0  def /maxTickline
147.95483  def /dT 1491749 abs 65536 div viceversa { neg } if def /subTNo
1 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 2.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 1.5 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  1  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  1  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 10 subTNo div 9.99 { /dx exch def /x cntTick dT
dx log mul add def x abs MaxValue abs le { false { x minTickline  moveto
x maxTickline  lineto } { x tickstart STsize mul  moveto x tickend
STsize mul  lineto } ifelse } if } for subTwidth SLW subTColor subLSstroke
grestore stroke /dsubT 0 def } if dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MaxValue abs le
{ false { cntsubTick minTickline STsize mul  moveto cntsubTick maxTickline
STsize mul  lineto } { cntsubTick tickstart STsize mul  moveto cntsubTick
tickend STsize mul  lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline  moveto cntTick
maxTickline  lineto } { cntTick tickstart  moveto cntTick tickend 
lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 10 subTNo div 9.99 { /dx exch
def /x cntTick dT dx log mul add def x abs MinValue abs le { false
{ x minTickline  moveto x maxTickline  lineto } { x tickstart STsize
mul  moveto x tickend STsize mul  lineto } ifelse } if } for /dsubT
0 def subTwidth SLW subTColor subLSstroke grestore } dsubT abs 0 gt
{ gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MinValue abs le { cntsubTick tickstart STsize mul  moveto cntsubTick
tickend STsize mul  lineto }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave cntTick tickstart  moveto cntTick tickend 
lineto Twidth SLW TColor LSstroke grestore }{ /showOrigin true def
} ifelse } for } if end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 0.0 147.95483 0.0 0.0    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.75 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 102.43027 0.0 0.0 0.0    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.75 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.75 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  
/showOrigin true def 0 147.95483  0 0.0  ArrowA CP 4 2 roll ArrowB
2 copy /yEnd exch def /xEnd exch def L  1  setlinejoin 0  setlinecap
stroke  stroke /yStart exch def /xStart exch def 0 dup 2 mod 0 eq true
and exch 2 lt false and or { /viceversa 0.0  147.95483  gt { true }{
false } ifelse def /epsilon 0.01 def /minTickline 0.0  def /maxTickline
102.43027  def /dT 1491749 abs 65536 div viceversa { neg } if def /subTNo
1 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 2.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 1.5 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  1  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  1  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 10 subTNo div 9.99 { /dx exch def /x cntTick
dT dx log mul add def x abs MaxValue abs le { false { x minTickline
exch moveto x maxTickline exch lineto } { x tickstart STsize mul exch
moveto x tickend STsize mul exch lineto } ifelse } if } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul exch
moveto cntsubTick maxTickline STsize mul exch lineto } { cntsubTick
tickstart STsize mul exch moveto cntsubTick tickend STsize mul exch
lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick dsubT add def
} repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave false { cntTick minTickline exch moveto cntTick maxTickline
exch lineto } { cntTick tickstart exch moveto cntTick tickend exch
lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 10 subTNo div 9.99 { /dx exch
def /x cntTick dT dx log mul add def x abs MinValue abs le { false
{ x minTickline exch moveto x maxTickline exch lineto } { x tickstart
STsize mul exch moveto x tickend STsize mul exch lineto } ifelse }
if } for /dsubT 0 def subTwidth SLW subTColor subLSstroke grestore
} dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1
sub { cntsubTick abs MinValue abs le { cntsubTick tickstart STsize
mul exch moveto cntsubTick tickend STsize mul exch lineto }{ exit }
ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth SLW
subTColor subLSstroke grestore } if showOrigin { gsave cntTick tickstart
exch moveto cntTick tickend exch lineto Twidth SLW TColor LSstroke
grestore }{ /showOrigin true def } ifelse } for } if end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 0.0 147.95483 0.0 0.0    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.75 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ 102.43027 0.0 0.0 0.0    /Lineto /lineto load def 1  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt
{ 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.75 SLW 0  setgray  1. .setopacityalpha   1  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  0.75 SLW 0  setgray
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0
h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg a neg rlineto
gsave fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def  [ -91.04913 -60.70023 0.0 0.0    /Lineto /lineto load def
1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.75 SLW 0  setgray  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.25 SLW 0.8 0.1 0.1
 setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale
 false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul
/a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg
a neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def /ArrowInside { } def  [ 22.76228 0.0 0.0 0.0    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.8 0.1
0.1  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.25 SLW 0.8 0.1 0.1
 setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale
 false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul
/a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg
a neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def /ArrowInside { } def  [ 0.0 22.76228 0.0 0.0    /Lineto /lineto
load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.8 0.1
0.1  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave fill grestore grestore 0 h a sub
moveto   EndArrow  } def /ArrowInside { } def  1.25 SLW 0.8 0.1 0.1
 setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale
 false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul dup /h ED mul
/a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h L w neg
a neg rlineto gsave fill grestore grestore 0 h a sub moveto   EndArrow
 } def /ArrowInside { } def  [ -17.0717 -11.38113 0.0 0.0    /Lineto
/lineto load def 1  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0.8 0.1
0.1  setrgbcolor  1. .setopacityalpha   1  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 1715
3719 a 1715 3719 a
tx@Dict begin { -7.96693 -5.69057 } PutCoor PutBegin  end
 1715 3719 a 0.8 0.1 0.1 TeXcolorrgb
1689 3820 a FH(~)1703 3838 y FF(i)p 0 TeXcolorgray 1715
3719 a
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 1715 3719 a 1715 3719
a
tx@Dict begin { 11.38113 0.0 } PutCoor PutBegin  end
 1715 3719 a 0.8 0.1 0.1 TeXcolorrgb 1690 3820 a FH(~)1707
3838 y FF(j)p 0 TeXcolorgray 1715 3719 a
tx@Dict begin  PutEnd  end
 1715 3719 a
1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle 180  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { 0.0 11.38113 } PutCoor PutBegin  end
 1715 3719 a 0.8 0.1 0.1
TeXcolorrgb 1619 3738 a FH(~)1628 3758 y FF(k)p 0 TeXcolorgray
1715 3719 a
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -45  def grestore  end
 1715 3719 a 1715
3719 a
tx@Dict begin { 0.0 0.0 } PutCoor PutBegin  end
 1715 3719 a 1638 3794 a Fx(O)1715 3719 y
tx@Dict begin  PutEnd  end
 1715
3719 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.1 0.05 0.5  setrgbcolor  /ArrowA {
moveto } def /ArrowB { } def /ArrowInside { } def  [ -48.36984 -62.59627
45.52457 0.0 0.0 136.5737 -91.50447 75.57094    /Lineto /lineto load
def 1  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def
} if () length 0 gt { 1.5 2.  CLW mul add dup 1.4  mul exch 0.4 mul
neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.5 SLW 0.1 0.05 0.5  setrgbcolor
 1. .setopacityalpha   1  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.5 SLW 0.6 0 0.48  setrgbcolor  [ 0.0 91.04913
91.04913 0.0 -68.28685 -45.52457   /Lineto /lineto load def 1  setlinejoin
false NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop } repeat
}{ n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1 ED /x1
ED /xx1 x1 def /yy1 y1 def x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1
add 2 div def x1 y1 moveto /n n 2 sub def /drawArrows { x11 y11 0.5
 1 gt { /Alpha y12 y11 sub x12 x11 sub atan def /ArrowPos 0.  def /Length
x12 x11 sub y12 y11 sub Pyth def /dArrowPos 0.5  abs def { /ArrowPos
ArrowPos dArrowPos add def ArrowPos Length gt { exit } if x11 Alpha
cos ArrowPos mul add y11 Alpha sin ArrowPos mul add currentdict /ArrowInside
known { ArrowInside } if pop pop } loop }{ /ArrowPos 0.  def /dArrowPos
1.  1 gt {1.0 1.  1.0 add div }{ 0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x12 x11 sub ArrowPos mul x11 add y12 y11
sub ArrowPos mul y11 add currentdict /ArrowInside known { ArrowInside
} if pop pop } repeat } ifelse pop pop Lineto } def n { 4 copy /y11
ED /x11 ED /y12 ED /x12 ED drawArrows } repeat x1 y1 x0 y0 6 4 roll
2 copy /y11 ED /x11 ED /y12 y0 def /x12 x0 def drawArrows /y11 y0 def
/x11 x0 def /y12 yy1 def /x12 xx1 def drawArrows pop pop closepath
} ifelse   gsave 1.5 SLW 0.6 0 0.48  setrgbcolor  1. .setopacityalpha
  1  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0.8 0.1 0.1  setrgbcolor  [ 0.0
91.04913 91.04913 0.0 -68.28685 -45.52457 45.52457 0.0 0.0 136.5737
  false NArray  /DS 6.0 0. CLW mul add 2 div def /Symbol 0. [1.8 0.0
0.0 1.8 -0.495 -0.4788] FontDot /Dot { moveto gsave 1.  1.  scale <B4>
show grestore } bind def  newpath n { transform floor .5 add exch floor
.5 add exch itransform Dot } repeat  end
 
@endspecial
1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle 0  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { -91.04913 -61.45808 } PutCoor PutBegin  end
 1715 3719 a 1759
3737 a FF(x)1715 3719 y
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 1715
3719 a 1715 3719 a
tx@Dict begin { 100.1539 0.0 } PutCoor PutBegin  end
 1715 3719 a 1699 3797 a FF(y)1715
3719 y
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle 135  def grestore  end
 1715 3719 a 1715 3719
a
tx@Dict begin { 0.0 142.26427 } PutCoor PutBegin  end
 1715 3719 a 1648 3688 a FF(z)1715 3719 y
tx@Dict begin  PutEnd  end
 1715 3719
a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -135  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { 45.52457 0.0 } PutCoor PutBegin  end
 1715 3719 a 0.1 0.05 0.5
TeXcolorrgb 1750 3805 a FF(A)p 0 TeXcolorgray 1715 3719
a
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle 45  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { 0.0 136.5737 } PutCoor PutBegin  end
 1715
3719 a 0.1 0.05 0.5 TeXcolorrgb 1745 3690 a FF(B)p 0
TeXcolorgray 1715 3719 a
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 1715
3719 a 1715 3719 a
tx@Dict begin { -68.28685 -45.52457 } PutCoor PutBegin  end
 1715 3719 a 0.6 0 0.48 TeXcolorrgb
1686 3817 a FF(C)p 0 TeXcolorgray 1715 3719 a
tx@Dict begin  PutEnd  end
 1715 3719
a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle -90  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { 91.04913 0.0 } PutCoor PutBegin  end
 1715 3719 a 0.6 0 0.48
TeXcolorrgb 1684 3816 a FF(D)p 0 TeXcolorgray 1715 3719
a
tx@Dict begin  PutEnd  end
 1715 3719 a 1715 3719 a
tx@Dict begin  gsave STV CP T /ps@refangle 180  def grestore  end
 1715 3719 a 1715 3719 a
tx@Dict begin { 0.0 91.04913 } PutCoor PutBegin  end
 1715
3719 a 0.6 0 0.48 TeXcolorrgb 1615 3747 a FF(E)p 0 TeXcolorgray
1715 3719 a
tx@Dict begin  PutEnd  end
 1715 3719 a -128 4322 a
SDict begin H.S end
 -128 4322 a -128
4322 a
SDict begin 12 H.A end
 -128 4322 a -128 4322 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.22) cvn /DEST pdfmark
end
 -128 4322 a 202 x FP(Exercice)i(n)297
4498 y Fb(o)343 4524 y FP(22)p 475 4499 3178 4 v -128
4637 a FN(On)f(donne)27 b FF(A)s FN(\(5;)8 b(0;)g(1\),)24
b FF(B)r FN(\(2;)8 b(3;)g(4\),)23 b FF(C)s FN(\(1;)8
b(1;)g(1\))21 b(et)j FF(D)t FN(\(0;)8 b(0;)g(3\).)22
b(Etudier)g(l'intersection)f(des)h(droites)f(\()6 b FF(A)t(B)r
FN(\))21 b(et)g(\()q FF(C)5 b(D)t FN(\).)-128 4651 y
SDict begin H.S end

-128 4651 a -128 4651 a
SDict begin 12 H.A end
 -128 4651 a -128 4651 a
SDict begin [/View [/XYZ H.V]/Dest (exercice.23) cvn /DEST pdfmark
end
 -128
4651 a 188 x FP(Exercice)23 b(n)297 4814 y Fb(o)343 4839
y FP(23)p 475 4814 3178 4 v -128 4952 a FN(On)28 b(consid\350re)g(les)f
(plans)h FI(\274)f FN(d'\351quation)j FF(x)13 b FC(\305)19
b FF(y)12 b FC(\241)g FN(2)19 b FC(\306)g FN(0)28 b(et)f
FI(\303)g FN(d'\351quation)h FC(\241)s FF(x)13 b FC(\305)f
FN(2)7 b FF(y)k FC(\305)16 b FF(z)21 b FC(\306)e FN(0.)28
b(D\351terminer)f(l'\351ventuelle)-128 5051 y(intersection)22
b(des)f(plans)h FI(\274)f FN(et)g FI(\303)p FN(.)-128
5070 y
SDict begin H.S end
 -128 5070 a -128 5070 a
SDict begin 12 H.A end
 -128 5070 a -128 5070
a
SDict begin [/View [/XYZ H.V]/Dest (exercice.24) cvn /DEST pdfmark
end
 -128 5070 a 183 x FP(Exercice)i(n)297 5228 y Fb(o)343
5253 y FP(24)p 475 5228 3178 4 v -128 5367 a FN(On)f(consid\350re)g
(trois)f(plans)h FI(\274)p FN(,)g FI(\303)f FN(et)g FI(\301)h
FN(dont)f(on)g(conna\356t)h(une)g(\351quation)f(cart\351sienne)g(:)595
5484 y FI(\274)14 b FC(\264)g FN(2)s FF(x)d FC(\241)17
b FF(y)10 b FC(\305)k FF(z)i FC(\306)e FN(2)99 b(et)f
FI(\303)14 b FC(\264)g FN(4)s FF(x)d FC(\241)f FN(2)d
FF(y)j FC(\305)g FN(3)t FF(z)16 b FC(\306)e FN(1)99 b(et)f
FI(\301)14 b FC(\264)k FF(x)11 b FC(\305)17 b FF(y)10
b FC(\305)k FF(z)i FC(\306)e FN(1)-128 5602 y(Etudier)22
b(l'intersection)g(des)f(plans)h FI(\274)p FN(,)g FI(\303)f
FN(et)g FI(\301)p FN(.)p 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
